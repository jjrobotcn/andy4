// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor.proto

#ifndef PROTOBUF_INCLUDED_sensor_2eproto
#define PROTOBUF_INCLUDED_sensor_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensor_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_sensor_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_sensor_2eproto();
namespace sensorService {
class DataAgv;
class DataAgvDefaultTypeInternal;
extern DataAgvDefaultTypeInternal _DataAgv_default_instance_;
class DataObs;
class DataObsDefaultTypeInternal;
extern DataObsDefaultTypeInternal _DataObs_default_instance_;
class DataObs_DataEntry_DoNotUse;
class DataObs_DataEntry_DoNotUseDefaultTypeInternal;
extern DataObs_DataEntry_DoNotUseDefaultTypeInternal _DataObs_DataEntry_DoNotUse_default_instance_;
class DataTouch;
class DataTouchDefaultTypeInternal;
extern DataTouchDefaultTypeInternal _DataTouch_default_instance_;
class DataTouch_TouchedEntry_DoNotUse;
class DataTouch_TouchedEntry_DoNotUseDefaultTypeInternal;
extern DataTouch_TouchedEntry_DoNotUseDefaultTypeInternal _DataTouch_TouchedEntry_DoNotUse_default_instance_;
class GetDetectRequest;
class GetDetectRequestDefaultTypeInternal;
extern GetDetectRequestDefaultTypeInternal _GetDetectRequest_default_instance_;
class GetDetectResponse;
class GetDetectResponseDefaultTypeInternal;
extern GetDetectResponseDefaultTypeInternal _GetDetectResponse_default_instance_;
class GetMotionInductionRequest;
class GetMotionInductionRequestDefaultTypeInternal;
extern GetMotionInductionRequestDefaultTypeInternal _GetMotionInductionRequest_default_instance_;
class GetMotionInductionResponse;
class GetMotionInductionResponseDefaultTypeInternal;
extern GetMotionInductionResponseDefaultTypeInternal _GetMotionInductionResponse_default_instance_;
class GetTouchRequest;
class GetTouchRequestDefaultTypeInternal;
extern GetTouchRequestDefaultTypeInternal _GetTouchRequest_default_instance_;
class GetTouchResponse;
class GetTouchResponseDefaultTypeInternal;
extern GetTouchResponseDefaultTypeInternal _GetTouchResponse_default_instance_;
class RawRequest;
class RawRequestDefaultTypeInternal;
extern RawRequestDefaultTypeInternal _RawRequest_default_instance_;
class RawResponse;
class RawResponseDefaultTypeInternal;
extern RawResponseDefaultTypeInternal _RawResponse_default_instance_;
class UpdateReq;
class UpdateReqDefaultTypeInternal;
extern UpdateReqDefaultTypeInternal _UpdateReq_default_instance_;
}  // namespace sensorService
namespace google {
namespace protobuf {
template<> ::sensorService::DataAgv* Arena::CreateMaybeMessage<::sensorService::DataAgv>(Arena*);
template<> ::sensorService::DataObs* Arena::CreateMaybeMessage<::sensorService::DataObs>(Arena*);
template<> ::sensorService::DataObs_DataEntry_DoNotUse* Arena::CreateMaybeMessage<::sensorService::DataObs_DataEntry_DoNotUse>(Arena*);
template<> ::sensorService::DataTouch* Arena::CreateMaybeMessage<::sensorService::DataTouch>(Arena*);
template<> ::sensorService::DataTouch_TouchedEntry_DoNotUse* Arena::CreateMaybeMessage<::sensorService::DataTouch_TouchedEntry_DoNotUse>(Arena*);
template<> ::sensorService::GetDetectRequest* Arena::CreateMaybeMessage<::sensorService::GetDetectRequest>(Arena*);
template<> ::sensorService::GetDetectResponse* Arena::CreateMaybeMessage<::sensorService::GetDetectResponse>(Arena*);
template<> ::sensorService::GetMotionInductionRequest* Arena::CreateMaybeMessage<::sensorService::GetMotionInductionRequest>(Arena*);
template<> ::sensorService::GetMotionInductionResponse* Arena::CreateMaybeMessage<::sensorService::GetMotionInductionResponse>(Arena*);
template<> ::sensorService::GetTouchRequest* Arena::CreateMaybeMessage<::sensorService::GetTouchRequest>(Arena*);
template<> ::sensorService::GetTouchResponse* Arena::CreateMaybeMessage<::sensorService::GetTouchResponse>(Arena*);
template<> ::sensorService::RawRequest* Arena::CreateMaybeMessage<::sensorService::RawRequest>(Arena*);
template<> ::sensorService::RawResponse* Arena::CreateMaybeMessage<::sensorService::RawResponse>(Arena*);
template<> ::sensorService::UpdateReq* Arena::CreateMaybeMessage<::sensorService::UpdateReq>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sensorService {

enum DetectDirection {
  _ZERO_DIR = 0,
  RELEASE_DIR = 1,
  LEFT = 2,
  CENTER = 3,
  RIGHT = 4,
  DetectDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DetectDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DetectDirection_IsValid(int value);
const DetectDirection DetectDirection_MIN = _ZERO_DIR;
const DetectDirection DetectDirection_MAX = RIGHT;
const int DetectDirection_ARRAYSIZE = DetectDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectDirection_descriptor();
inline const ::std::string& DetectDirection_Name(DetectDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectDirection_descriptor(), value);
}
inline bool DetectDirection_Parse(
    const ::std::string& name, DetectDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectDirection>(
    DetectDirection_descriptor(), name, value);
}
enum DetectDistance {
  _ZERO_DIS = 0,
  RELEASE_DIS = 1,
  CLOSE = 2,
  MEDIUM = 3,
  LONG = 4,
  DetectDistance_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DetectDistance_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DetectDistance_IsValid(int value);
const DetectDistance DetectDistance_MIN = _ZERO_DIS;
const DetectDistance DetectDistance_MAX = LONG;
const int DetectDistance_ARRAYSIZE = DetectDistance_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectDistance_descriptor();
inline const ::std::string& DetectDistance_Name(DetectDistance value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectDistance_descriptor(), value);
}
inline bool DetectDistance_Parse(
    const ::std::string& name, DetectDistance* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectDistance>(
    DetectDistance_descriptor(), name, value);
}
enum DataType {
  UNKNOWN = 0,
  OBS = 1,
  AGV = 2,
  TOUCH = 4,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = UNKNOWN;
const DataType DataType_MAX = TOUCH;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class GetDetectRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.GetDetectRequest) */ {
 public:
  GetDetectRequest();
  virtual ~GetDetectRequest();

  GetDetectRequest(const GetDetectRequest& from);

  inline GetDetectRequest& operator=(const GetDetectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDetectRequest(GetDetectRequest&& from) noexcept
    : GetDetectRequest() {
    *this = ::std::move(from);
  }

  inline GetDetectRequest& operator=(GetDetectRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetDetectRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDetectRequest* internal_default_instance() {
    return reinterpret_cast<const GetDetectRequest*>(
               &_GetDetectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GetDetectRequest* other);
  friend void swap(GetDetectRequest& a, GetDetectRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDetectRequest* New() const final {
    return CreateMaybeMessage<GetDetectRequest>(nullptr);
  }

  GetDetectRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDetectRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDetectRequest& from);
  void MergeFrom(const GetDetectRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensorService.GetDetectRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class GetDetectResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.GetDetectResponse) */ {
 public:
  GetDetectResponse();
  virtual ~GetDetectResponse();

  GetDetectResponse(const GetDetectResponse& from);

  inline GetDetectResponse& operator=(const GetDetectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDetectResponse(GetDetectResponse&& from) noexcept
    : GetDetectResponse() {
    *this = ::std::move(from);
  }

  inline GetDetectResponse& operator=(GetDetectResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetDetectResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDetectResponse* internal_default_instance() {
    return reinterpret_cast<const GetDetectResponse*>(
               &_GetDetectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GetDetectResponse* other);
  friend void swap(GetDetectResponse& a, GetDetectResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDetectResponse* New() const final {
    return CreateMaybeMessage<GetDetectResponse>(nullptr);
  }

  GetDetectResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDetectResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDetectResponse& from);
  void MergeFrom(const GetDetectResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDetectResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensorService.DetectDirection direction = 1;
  void clear_direction();
  static const int kDirectionFieldNumber = 1;
  ::sensorService::DetectDirection direction() const;
  void set_direction(::sensorService::DetectDirection value);

  // .sensorService.DetectDistance distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  ::sensorService::DetectDistance distance() const;
  void set_distance(::sensorService::DetectDistance value);

  // @@protoc_insertion_point(class_scope:sensorService.GetDetectResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int direction_;
  int distance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class GetMotionInductionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.GetMotionInductionRequest) */ {
 public:
  GetMotionInductionRequest();
  virtual ~GetMotionInductionRequest();

  GetMotionInductionRequest(const GetMotionInductionRequest& from);

  inline GetMotionInductionRequest& operator=(const GetMotionInductionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMotionInductionRequest(GetMotionInductionRequest&& from) noexcept
    : GetMotionInductionRequest() {
    *this = ::std::move(from);
  }

  inline GetMotionInductionRequest& operator=(GetMotionInductionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetMotionInductionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMotionInductionRequest* internal_default_instance() {
    return reinterpret_cast<const GetMotionInductionRequest*>(
               &_GetMotionInductionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetMotionInductionRequest* other);
  friend void swap(GetMotionInductionRequest& a, GetMotionInductionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMotionInductionRequest* New() const final {
    return CreateMaybeMessage<GetMotionInductionRequest>(nullptr);
  }

  GetMotionInductionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMotionInductionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMotionInductionRequest& from);
  void MergeFrom(const GetMotionInductionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMotionInductionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensorService.GetMotionInductionRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class GetMotionInductionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.GetMotionInductionResponse) */ {
 public:
  GetMotionInductionResponse();
  virtual ~GetMotionInductionResponse();

  GetMotionInductionResponse(const GetMotionInductionResponse& from);

  inline GetMotionInductionResponse& operator=(const GetMotionInductionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMotionInductionResponse(GetMotionInductionResponse&& from) noexcept
    : GetMotionInductionResponse() {
    *this = ::std::move(from);
  }

  inline GetMotionInductionResponse& operator=(GetMotionInductionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetMotionInductionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMotionInductionResponse* internal_default_instance() {
    return reinterpret_cast<const GetMotionInductionResponse*>(
               &_GetMotionInductionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetMotionInductionResponse* other);
  friend void swap(GetMotionInductionResponse& a, GetMotionInductionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMotionInductionResponse* New() const final {
    return CreateMaybeMessage<GetMotionInductionResponse>(nullptr);
  }

  GetMotionInductionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMotionInductionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMotionInductionResponse& from);
  void MergeFrom(const GetMotionInductionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMotionInductionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool left = 1;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  bool left() const;
  void set_left(bool value);

  // bool right = 2;
  void clear_right();
  static const int kRightFieldNumber = 2;
  bool right() const;
  void set_right(bool value);

  // @@protoc_insertion_point(class_scope:sensorService.GetMotionInductionResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool left_;
  bool right_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class GetTouchRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.GetTouchRequest) */ {
 public:
  GetTouchRequest();
  virtual ~GetTouchRequest();

  GetTouchRequest(const GetTouchRequest& from);

  inline GetTouchRequest& operator=(const GetTouchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTouchRequest(GetTouchRequest&& from) noexcept
    : GetTouchRequest() {
    *this = ::std::move(from);
  }

  inline GetTouchRequest& operator=(GetTouchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetTouchRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTouchRequest* internal_default_instance() {
    return reinterpret_cast<const GetTouchRequest*>(
               &_GetTouchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetTouchRequest* other);
  friend void swap(GetTouchRequest& a, GetTouchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTouchRequest* New() const final {
    return CreateMaybeMessage<GetTouchRequest>(nullptr);
  }

  GetTouchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTouchRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTouchRequest& from);
  void MergeFrom(const GetTouchRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTouchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensorService.GetTouchRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class GetTouchResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.GetTouchResponse) */ {
 public:
  GetTouchResponse();
  virtual ~GetTouchResponse();

  GetTouchResponse(const GetTouchResponse& from);

  inline GetTouchResponse& operator=(const GetTouchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTouchResponse(GetTouchResponse&& from) noexcept
    : GetTouchResponse() {
    *this = ::std::move(from);
  }

  inline GetTouchResponse& operator=(GetTouchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetTouchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTouchResponse* internal_default_instance() {
    return reinterpret_cast<const GetTouchResponse*>(
               &_GetTouchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetTouchResponse* other);
  friend void swap(GetTouchResponse& a, GetTouchResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTouchResponse* New() const final {
    return CreateMaybeMessage<GetTouchResponse>(nullptr);
  }

  GetTouchResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTouchResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTouchResponse& from);
  void MergeFrom(const GetTouchResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTouchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool hand_left = 1;
  void clear_hand_left();
  static const int kHandLeftFieldNumber = 1;
  bool hand_left() const;
  void set_hand_left(bool value);

  // bool hand_right = 2;
  void clear_hand_right();
  static const int kHandRightFieldNumber = 2;
  bool hand_right() const;
  void set_hand_right(bool value);

  // bool head = 3;
  void clear_head();
  static const int kHeadFieldNumber = 3;
  bool head() const;
  void set_head(bool value);

  // @@protoc_insertion_point(class_scope:sensorService.GetTouchResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool hand_left_;
  bool hand_right_;
  bool head_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class DataObs_DataEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<DataObs_DataEntry_DoNotUse, 
    ::std::string, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<DataObs_DataEntry_DoNotUse, 
    ::std::string, ::google::protobuf::int32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    0 > SuperType;
  DataObs_DataEntry_DoNotUse();
  DataObs_DataEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const DataObs_DataEntry_DoNotUse& other);
  static const DataObs_DataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataObs_DataEntry_DoNotUse*>(&_DataObs_DataEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class DataObs final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.DataObs) */ {
 public:
  DataObs();
  virtual ~DataObs();

  DataObs(const DataObs& from);

  inline DataObs& operator=(const DataObs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataObs(DataObs&& from) noexcept
    : DataObs() {
    *this = ::std::move(from);
  }

  inline DataObs& operator=(DataObs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DataObs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataObs* internal_default_instance() {
    return reinterpret_cast<const DataObs*>(
               &_DataObs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DataObs* other);
  friend void swap(DataObs& a, DataObs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataObs* New() const final {
    return CreateMaybeMessage<DataObs>(nullptr);
  }

  DataObs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataObs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataObs& from);
  void MergeFrom(const DataObs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataObs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, int32> data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
      data() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:sensorService.DataObs)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      DataObs_DataEntry_DoNotUse,
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class DataAgv final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.DataAgv) */ {
 public:
  DataAgv();
  virtual ~DataAgv();

  DataAgv(const DataAgv& from);

  inline DataAgv& operator=(const DataAgv& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataAgv(DataAgv&& from) noexcept
    : DataAgv() {
    *this = ::std::move(from);
  }

  inline DataAgv& operator=(DataAgv&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DataAgv& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataAgv* internal_default_instance() {
    return reinterpret_cast<const DataAgv*>(
               &_DataAgv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DataAgv* other);
  friend void swap(DataAgv& a, DataAgv& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataAgv* New() const final {
    return CreateMaybeMessage<DataAgv>(nullptr);
  }

  DataAgv* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataAgv>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataAgv& from);
  void MergeFrom(const DataAgv& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataAgv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  bool data(int index) const;
  void set_data(int index, bool value);
  void add_data(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      data() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_data();

  // string card_id = 1;
  void clear_card_id();
  static const int kCardIdFieldNumber = 1;
  const ::std::string& card_id() const;
  void set_card_id(const ::std::string& value);
  #if LANG_CXX11
  void set_card_id(::std::string&& value);
  #endif
  void set_card_id(const char* value);
  void set_card_id(const char* value, size_t size);
  ::std::string* mutable_card_id();
  ::std::string* release_card_id();
  void set_allocated_card_id(::std::string* card_id);

  // @@protoc_insertion_point(class_scope:sensorService.DataAgv)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< bool > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr card_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class DataTouch_TouchedEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<DataTouch_TouchedEntry_DoNotUse, 
    ::std::string, bool,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<DataTouch_TouchedEntry_DoNotUse, 
    ::std::string, bool,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
    0 > SuperType;
  DataTouch_TouchedEntry_DoNotUse();
  DataTouch_TouchedEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const DataTouch_TouchedEntry_DoNotUse& other);
  static const DataTouch_TouchedEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DataTouch_TouchedEntry_DoNotUse*>(&_DataTouch_TouchedEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class DataTouch final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.DataTouch) */ {
 public:
  DataTouch();
  virtual ~DataTouch();

  DataTouch(const DataTouch& from);

  inline DataTouch& operator=(const DataTouch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataTouch(DataTouch&& from) noexcept
    : DataTouch() {
    *this = ::std::move(from);
  }

  inline DataTouch& operator=(DataTouch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DataTouch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataTouch* internal_default_instance() {
    return reinterpret_cast<const DataTouch*>(
               &_DataTouch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(DataTouch* other);
  friend void swap(DataTouch& a, DataTouch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataTouch* New() const final {
    return CreateMaybeMessage<DataTouch>(nullptr);
  }

  DataTouch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataTouch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataTouch& from);
  void MergeFrom(const DataTouch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTouch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bool> touched = 1;
  int touched_size() const;
  void clear_touched();
  static const int kTouchedFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, bool >&
      touched() const;
  ::google::protobuf::Map< ::std::string, bool >*
      mutable_touched();

  // @@protoc_insertion_point(class_scope:sensorService.DataTouch)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      DataTouch_TouchedEntry_DoNotUse,
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 > touched_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class UpdateReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.UpdateReq) */ {
 public:
  UpdateReq();
  virtual ~UpdateReq();

  UpdateReq(const UpdateReq& from);

  inline UpdateReq& operator=(const UpdateReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateReq(UpdateReq&& from) noexcept
    : UpdateReq() {
    *this = ::std::move(from);
  }

  inline UpdateReq& operator=(UpdateReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UpdateReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateReq* internal_default_instance() {
    return reinterpret_cast<const UpdateReq*>(
               &_UpdateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(UpdateReq* other);
  friend void swap(UpdateReq& a, UpdateReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateReq* New() const final {
    return CreateMaybeMessage<UpdateReq>(nullptr);
  }

  UpdateReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateReq& from);
  void MergeFrom(const UpdateReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensorService.DataObs obs = 2;
  bool has_obs() const;
  void clear_obs();
  static const int kObsFieldNumber = 2;
  const ::sensorService::DataObs& obs() const;
  ::sensorService::DataObs* release_obs();
  ::sensorService::DataObs* mutable_obs();
  void set_allocated_obs(::sensorService::DataObs* obs);

  // .sensorService.DataAgv agv = 3;
  bool has_agv() const;
  void clear_agv();
  static const int kAgvFieldNumber = 3;
  const ::sensorService::DataAgv& agv() const;
  ::sensorService::DataAgv* release_agv();
  ::sensorService::DataAgv* mutable_agv();
  void set_allocated_agv(::sensorService::DataAgv* agv);

  // .sensorService.DataTouch touch = 5;
  bool has_touch() const;
  void clear_touch();
  static const int kTouchFieldNumber = 5;
  const ::sensorService::DataTouch& touch() const;
  ::sensorService::DataTouch* release_touch();
  ::sensorService::DataTouch* mutable_touch();
  void set_allocated_touch(::sensorService::DataTouch* touch);

  // .sensorService.DataType dtype = 1;
  void clear_dtype();
  static const int kDtypeFieldNumber = 1;
  ::sensorService::DataType dtype() const;
  void set_dtype(::sensorService::DataType value);

  // @@protoc_insertion_point(class_scope:sensorService.UpdateReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sensorService::DataObs* obs_;
  ::sensorService::DataAgv* agv_;
  ::sensorService::DataTouch* touch_;
  int dtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class RawRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.RawRequest) */ {
 public:
  RawRequest();
  virtual ~RawRequest();

  RawRequest(const RawRequest& from);

  inline RawRequest& operator=(const RawRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawRequest(RawRequest&& from) noexcept
    : RawRequest() {
    *this = ::std::move(from);
  }

  inline RawRequest& operator=(RawRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RawRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawRequest* internal_default_instance() {
    return reinterpret_cast<const RawRequest*>(
               &_RawRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RawRequest* other);
  friend void swap(RawRequest& a, RawRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawRequest* New() const final {
    return CreateMaybeMessage<RawRequest>(nullptr);
  }

  RawRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawRequest& from);
  void MergeFrom(const RawRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sensorService.RawRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// -------------------------------------------------------------------

class RawResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensorService.RawResponse) */ {
 public:
  RawResponse();
  virtual ~RawResponse();

  RawResponse(const RawResponse& from);

  inline RawResponse& operator=(const RawResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawResponse(RawResponse&& from) noexcept
    : RawResponse() {
    *this = ::std::move(from);
  }

  inline RawResponse& operator=(RawResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RawResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawResponse* internal_default_instance() {
    return reinterpret_cast<const RawResponse*>(
               &_RawResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RawResponse* other);
  friend void swap(RawResponse& a, RawResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawResponse* New() const final {
    return CreateMaybeMessage<RawResponse>(nullptr);
  }

  RawResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawResponse& from);
  void MergeFrom(const RawResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensorService.DataObs obs = 2;
  bool has_obs() const;
  void clear_obs();
  static const int kObsFieldNumber = 2;
  const ::sensorService::DataObs& obs() const;
  ::sensorService::DataObs* release_obs();
  ::sensorService::DataObs* mutable_obs();
  void set_allocated_obs(::sensorService::DataObs* obs);

  // .sensorService.DataAgv agv = 3;
  bool has_agv() const;
  void clear_agv();
  static const int kAgvFieldNumber = 3;
  const ::sensorService::DataAgv& agv() const;
  ::sensorService::DataAgv* release_agv();
  ::sensorService::DataAgv* mutable_agv();
  void set_allocated_agv(::sensorService::DataAgv* agv);

  // .sensorService.DataTouch touch = 5;
  bool has_touch() const;
  void clear_touch();
  static const int kTouchFieldNumber = 5;
  const ::sensorService::DataTouch& touch() const;
  ::sensorService::DataTouch* release_touch();
  ::sensorService::DataTouch* mutable_touch();
  void set_allocated_touch(::sensorService::DataTouch* touch);

  // .sensorService.DataType dtype = 1;
  void clear_dtype();
  static const int kDtypeFieldNumber = 1;
  ::sensorService::DataType dtype() const;
  void set_dtype(::sensorService::DataType value);

  // @@protoc_insertion_point(class_scope:sensorService.RawResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sensorService::DataObs* obs_;
  ::sensorService::DataAgv* agv_;
  ::sensorService::DataTouch* touch_;
  int dtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensor_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetDetectRequest

// -------------------------------------------------------------------

// GetDetectResponse

// .sensorService.DetectDirection direction = 1;
inline void GetDetectResponse::clear_direction() {
  direction_ = 0;
}
inline ::sensorService::DetectDirection GetDetectResponse::direction() const {
  // @@protoc_insertion_point(field_get:sensorService.GetDetectResponse.direction)
  return static_cast< ::sensorService::DetectDirection >(direction_);
}
inline void GetDetectResponse::set_direction(::sensorService::DetectDirection value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:sensorService.GetDetectResponse.direction)
}

// .sensorService.DetectDistance distance = 2;
inline void GetDetectResponse::clear_distance() {
  distance_ = 0;
}
inline ::sensorService::DetectDistance GetDetectResponse::distance() const {
  // @@protoc_insertion_point(field_get:sensorService.GetDetectResponse.distance)
  return static_cast< ::sensorService::DetectDistance >(distance_);
}
inline void GetDetectResponse::set_distance(::sensorService::DetectDistance value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:sensorService.GetDetectResponse.distance)
}

// -------------------------------------------------------------------

// GetMotionInductionRequest

// -------------------------------------------------------------------

// GetMotionInductionResponse

// bool left = 1;
inline void GetMotionInductionResponse::clear_left() {
  left_ = false;
}
inline bool GetMotionInductionResponse::left() const {
  // @@protoc_insertion_point(field_get:sensorService.GetMotionInductionResponse.left)
  return left_;
}
inline void GetMotionInductionResponse::set_left(bool value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:sensorService.GetMotionInductionResponse.left)
}

// bool right = 2;
inline void GetMotionInductionResponse::clear_right() {
  right_ = false;
}
inline bool GetMotionInductionResponse::right() const {
  // @@protoc_insertion_point(field_get:sensorService.GetMotionInductionResponse.right)
  return right_;
}
inline void GetMotionInductionResponse::set_right(bool value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:sensorService.GetMotionInductionResponse.right)
}

// -------------------------------------------------------------------

// GetTouchRequest

// -------------------------------------------------------------------

// GetTouchResponse

// bool hand_left = 1;
inline void GetTouchResponse::clear_hand_left() {
  hand_left_ = false;
}
inline bool GetTouchResponse::hand_left() const {
  // @@protoc_insertion_point(field_get:sensorService.GetTouchResponse.hand_left)
  return hand_left_;
}
inline void GetTouchResponse::set_hand_left(bool value) {
  
  hand_left_ = value;
  // @@protoc_insertion_point(field_set:sensorService.GetTouchResponse.hand_left)
}

// bool hand_right = 2;
inline void GetTouchResponse::clear_hand_right() {
  hand_right_ = false;
}
inline bool GetTouchResponse::hand_right() const {
  // @@protoc_insertion_point(field_get:sensorService.GetTouchResponse.hand_right)
  return hand_right_;
}
inline void GetTouchResponse::set_hand_right(bool value) {
  
  hand_right_ = value;
  // @@protoc_insertion_point(field_set:sensorService.GetTouchResponse.hand_right)
}

// bool head = 3;
inline void GetTouchResponse::clear_head() {
  head_ = false;
}
inline bool GetTouchResponse::head() const {
  // @@protoc_insertion_point(field_get:sensorService.GetTouchResponse.head)
  return head_;
}
inline void GetTouchResponse::set_head(bool value) {
  
  head_ = value;
  // @@protoc_insertion_point(field_set:sensorService.GetTouchResponse.head)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataObs

// map<string, int32> data = 1;
inline int DataObs::data_size() const {
  return data_.size();
}
inline void DataObs::clear_data() {
  data_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
DataObs::data() const {
  // @@protoc_insertion_point(field_map:sensorService.DataObs.data)
  return data_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
DataObs::mutable_data() {
  // @@protoc_insertion_point(field_mutable_map:sensorService.DataObs.data)
  return data_.MutableMap();
}

// -------------------------------------------------------------------

// DataAgv

// string card_id = 1;
inline void DataAgv::clear_card_id() {
  card_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataAgv::card_id() const {
  // @@protoc_insertion_point(field_get:sensorService.DataAgv.card_id)
  return card_id_.GetNoArena();
}
inline void DataAgv::set_card_id(const ::std::string& value) {
  
  card_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sensorService.DataAgv.card_id)
}
#if LANG_CXX11
inline void DataAgv::set_card_id(::std::string&& value) {
  
  card_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sensorService.DataAgv.card_id)
}
#endif
inline void DataAgv::set_card_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  card_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sensorService.DataAgv.card_id)
}
inline void DataAgv::set_card_id(const char* value, size_t size) {
  
  card_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sensorService.DataAgv.card_id)
}
inline ::std::string* DataAgv::mutable_card_id() {
  
  // @@protoc_insertion_point(field_mutable:sensorService.DataAgv.card_id)
  return card_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataAgv::release_card_id() {
  // @@protoc_insertion_point(field_release:sensorService.DataAgv.card_id)
  
  return card_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataAgv::set_allocated_card_id(::std::string* card_id) {
  if (card_id != nullptr) {
    
  } else {
    
  }
  card_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), card_id);
  // @@protoc_insertion_point(field_set_allocated:sensorService.DataAgv.card_id)
}

// repeated bool data = 2;
inline int DataAgv::data_size() const {
  return data_.size();
}
inline void DataAgv::clear_data() {
  data_.Clear();
}
inline bool DataAgv::data(int index) const {
  // @@protoc_insertion_point(field_get:sensorService.DataAgv.data)
  return data_.Get(index);
}
inline void DataAgv::set_data(int index, bool value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:sensorService.DataAgv.data)
}
inline void DataAgv::add_data(bool value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:sensorService.DataAgv.data)
}
inline const ::google::protobuf::RepeatedField< bool >&
DataAgv::data() const {
  // @@protoc_insertion_point(field_list:sensorService.DataAgv.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< bool >*
DataAgv::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:sensorService.DataAgv.data)
  return &data_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DataTouch

// map<string, bool> touched = 1;
inline int DataTouch::touched_size() const {
  return touched_.size();
}
inline void DataTouch::clear_touched() {
  touched_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, bool >&
DataTouch::touched() const {
  // @@protoc_insertion_point(field_map:sensorService.DataTouch.touched)
  return touched_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, bool >*
DataTouch::mutable_touched() {
  // @@protoc_insertion_point(field_mutable_map:sensorService.DataTouch.touched)
  return touched_.MutableMap();
}

// -------------------------------------------------------------------

// UpdateReq

// .sensorService.DataType dtype = 1;
inline void UpdateReq::clear_dtype() {
  dtype_ = 0;
}
inline ::sensorService::DataType UpdateReq::dtype() const {
  // @@protoc_insertion_point(field_get:sensorService.UpdateReq.dtype)
  return static_cast< ::sensorService::DataType >(dtype_);
}
inline void UpdateReq::set_dtype(::sensorService::DataType value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:sensorService.UpdateReq.dtype)
}

// .sensorService.DataObs obs = 2;
inline bool UpdateReq::has_obs() const {
  return this != internal_default_instance() && obs_ != nullptr;
}
inline void UpdateReq::clear_obs() {
  if (GetArenaNoVirtual() == nullptr && obs_ != nullptr) {
    delete obs_;
  }
  obs_ = nullptr;
}
inline const ::sensorService::DataObs& UpdateReq::obs() const {
  const ::sensorService::DataObs* p = obs_;
  // @@protoc_insertion_point(field_get:sensorService.UpdateReq.obs)
  return p != nullptr ? *p : *reinterpret_cast<const ::sensorService::DataObs*>(
      &::sensorService::_DataObs_default_instance_);
}
inline ::sensorService::DataObs* UpdateReq::release_obs() {
  // @@protoc_insertion_point(field_release:sensorService.UpdateReq.obs)
  
  ::sensorService::DataObs* temp = obs_;
  obs_ = nullptr;
  return temp;
}
inline ::sensorService::DataObs* UpdateReq::mutable_obs() {
  
  if (obs_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensorService::DataObs>(GetArenaNoVirtual());
    obs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensorService.UpdateReq.obs)
  return obs_;
}
inline void UpdateReq::set_allocated_obs(::sensorService::DataObs* obs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete obs_;
  }
  if (obs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      obs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obs, submessage_arena);
    }
    
  } else {
    
  }
  obs_ = obs;
  // @@protoc_insertion_point(field_set_allocated:sensorService.UpdateReq.obs)
}

// .sensorService.DataAgv agv = 3;
inline bool UpdateReq::has_agv() const {
  return this != internal_default_instance() && agv_ != nullptr;
}
inline void UpdateReq::clear_agv() {
  if (GetArenaNoVirtual() == nullptr && agv_ != nullptr) {
    delete agv_;
  }
  agv_ = nullptr;
}
inline const ::sensorService::DataAgv& UpdateReq::agv() const {
  const ::sensorService::DataAgv* p = agv_;
  // @@protoc_insertion_point(field_get:sensorService.UpdateReq.agv)
  return p != nullptr ? *p : *reinterpret_cast<const ::sensorService::DataAgv*>(
      &::sensorService::_DataAgv_default_instance_);
}
inline ::sensorService::DataAgv* UpdateReq::release_agv() {
  // @@protoc_insertion_point(field_release:sensorService.UpdateReq.agv)
  
  ::sensorService::DataAgv* temp = agv_;
  agv_ = nullptr;
  return temp;
}
inline ::sensorService::DataAgv* UpdateReq::mutable_agv() {
  
  if (agv_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensorService::DataAgv>(GetArenaNoVirtual());
    agv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensorService.UpdateReq.agv)
  return agv_;
}
inline void UpdateReq::set_allocated_agv(::sensorService::DataAgv* agv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete agv_;
  }
  if (agv) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      agv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agv, submessage_arena);
    }
    
  } else {
    
  }
  agv_ = agv;
  // @@protoc_insertion_point(field_set_allocated:sensorService.UpdateReq.agv)
}

// .sensorService.DataTouch touch = 5;
inline bool UpdateReq::has_touch() const {
  return this != internal_default_instance() && touch_ != nullptr;
}
inline void UpdateReq::clear_touch() {
  if (GetArenaNoVirtual() == nullptr && touch_ != nullptr) {
    delete touch_;
  }
  touch_ = nullptr;
}
inline const ::sensorService::DataTouch& UpdateReq::touch() const {
  const ::sensorService::DataTouch* p = touch_;
  // @@protoc_insertion_point(field_get:sensorService.UpdateReq.touch)
  return p != nullptr ? *p : *reinterpret_cast<const ::sensorService::DataTouch*>(
      &::sensorService::_DataTouch_default_instance_);
}
inline ::sensorService::DataTouch* UpdateReq::release_touch() {
  // @@protoc_insertion_point(field_release:sensorService.UpdateReq.touch)
  
  ::sensorService::DataTouch* temp = touch_;
  touch_ = nullptr;
  return temp;
}
inline ::sensorService::DataTouch* UpdateReq::mutable_touch() {
  
  if (touch_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensorService::DataTouch>(GetArenaNoVirtual());
    touch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensorService.UpdateReq.touch)
  return touch_;
}
inline void UpdateReq::set_allocated_touch(::sensorService::DataTouch* touch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete touch_;
  }
  if (touch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      touch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, touch, submessage_arena);
    }
    
  } else {
    
  }
  touch_ = touch;
  // @@protoc_insertion_point(field_set_allocated:sensorService.UpdateReq.touch)
}

// -------------------------------------------------------------------

// RawRequest

// -------------------------------------------------------------------

// RawResponse

// .sensorService.DataType dtype = 1;
inline void RawResponse::clear_dtype() {
  dtype_ = 0;
}
inline ::sensorService::DataType RawResponse::dtype() const {
  // @@protoc_insertion_point(field_get:sensorService.RawResponse.dtype)
  return static_cast< ::sensorService::DataType >(dtype_);
}
inline void RawResponse::set_dtype(::sensorService::DataType value) {
  
  dtype_ = value;
  // @@protoc_insertion_point(field_set:sensorService.RawResponse.dtype)
}

// .sensorService.DataObs obs = 2;
inline bool RawResponse::has_obs() const {
  return this != internal_default_instance() && obs_ != nullptr;
}
inline void RawResponse::clear_obs() {
  if (GetArenaNoVirtual() == nullptr && obs_ != nullptr) {
    delete obs_;
  }
  obs_ = nullptr;
}
inline const ::sensorService::DataObs& RawResponse::obs() const {
  const ::sensorService::DataObs* p = obs_;
  // @@protoc_insertion_point(field_get:sensorService.RawResponse.obs)
  return p != nullptr ? *p : *reinterpret_cast<const ::sensorService::DataObs*>(
      &::sensorService::_DataObs_default_instance_);
}
inline ::sensorService::DataObs* RawResponse::release_obs() {
  // @@protoc_insertion_point(field_release:sensorService.RawResponse.obs)
  
  ::sensorService::DataObs* temp = obs_;
  obs_ = nullptr;
  return temp;
}
inline ::sensorService::DataObs* RawResponse::mutable_obs() {
  
  if (obs_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensorService::DataObs>(GetArenaNoVirtual());
    obs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensorService.RawResponse.obs)
  return obs_;
}
inline void RawResponse::set_allocated_obs(::sensorService::DataObs* obs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete obs_;
  }
  if (obs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      obs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obs, submessage_arena);
    }
    
  } else {
    
  }
  obs_ = obs;
  // @@protoc_insertion_point(field_set_allocated:sensorService.RawResponse.obs)
}

// .sensorService.DataAgv agv = 3;
inline bool RawResponse::has_agv() const {
  return this != internal_default_instance() && agv_ != nullptr;
}
inline void RawResponse::clear_agv() {
  if (GetArenaNoVirtual() == nullptr && agv_ != nullptr) {
    delete agv_;
  }
  agv_ = nullptr;
}
inline const ::sensorService::DataAgv& RawResponse::agv() const {
  const ::sensorService::DataAgv* p = agv_;
  // @@protoc_insertion_point(field_get:sensorService.RawResponse.agv)
  return p != nullptr ? *p : *reinterpret_cast<const ::sensorService::DataAgv*>(
      &::sensorService::_DataAgv_default_instance_);
}
inline ::sensorService::DataAgv* RawResponse::release_agv() {
  // @@protoc_insertion_point(field_release:sensorService.RawResponse.agv)
  
  ::sensorService::DataAgv* temp = agv_;
  agv_ = nullptr;
  return temp;
}
inline ::sensorService::DataAgv* RawResponse::mutable_agv() {
  
  if (agv_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensorService::DataAgv>(GetArenaNoVirtual());
    agv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensorService.RawResponse.agv)
  return agv_;
}
inline void RawResponse::set_allocated_agv(::sensorService::DataAgv* agv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete agv_;
  }
  if (agv) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      agv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, agv, submessage_arena);
    }
    
  } else {
    
  }
  agv_ = agv;
  // @@protoc_insertion_point(field_set_allocated:sensorService.RawResponse.agv)
}

// .sensorService.DataTouch touch = 5;
inline bool RawResponse::has_touch() const {
  return this != internal_default_instance() && touch_ != nullptr;
}
inline void RawResponse::clear_touch() {
  if (GetArenaNoVirtual() == nullptr && touch_ != nullptr) {
    delete touch_;
  }
  touch_ = nullptr;
}
inline const ::sensorService::DataTouch& RawResponse::touch() const {
  const ::sensorService::DataTouch* p = touch_;
  // @@protoc_insertion_point(field_get:sensorService.RawResponse.touch)
  return p != nullptr ? *p : *reinterpret_cast<const ::sensorService::DataTouch*>(
      &::sensorService::_DataTouch_default_instance_);
}
inline ::sensorService::DataTouch* RawResponse::release_touch() {
  // @@protoc_insertion_point(field_release:sensorService.RawResponse.touch)
  
  ::sensorService::DataTouch* temp = touch_;
  touch_ = nullptr;
  return temp;
}
inline ::sensorService::DataTouch* RawResponse::mutable_touch() {
  
  if (touch_ == nullptr) {
    auto* p = CreateMaybeMessage<::sensorService::DataTouch>(GetArenaNoVirtual());
    touch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensorService.RawResponse.touch)
  return touch_;
}
inline void RawResponse::set_allocated_touch(::sensorService::DataTouch* touch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete touch_;
  }
  if (touch) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      touch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, touch, submessage_arena);
    }
    
  } else {
    
  }
  touch_ = touch;
  // @@protoc_insertion_point(field_set_allocated:sensorService.RawResponse.touch)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sensorService

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sensorService::DetectDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensorService::DetectDirection>() {
  return ::sensorService::DetectDirection_descriptor();
}
template <> struct is_proto_enum< ::sensorService::DetectDistance> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensorService::DetectDistance>() {
  return ::sensorService::DetectDistance_descriptor();
}
template <> struct is_proto_enum< ::sensorService::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensorService::DataType>() {
  return ::sensorService::DataType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_sensor_2eproto
