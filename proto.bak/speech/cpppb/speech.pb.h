// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speech.proto

#ifndef PROTOBUF_INCLUDED_speech_2eproto
#define PROTOBUF_INCLUDED_speech_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_speech_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_speech_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_speech_2eproto();
namespace speechService {
class ErrorInfo;
class ErrorInfoDefaultTypeInternal;
extern ErrorInfoDefaultTypeInternal _ErrorInfo_default_instance_;
class GetVoiceVolumeRequest;
class GetVoiceVolumeRequestDefaultTypeInternal;
extern GetVoiceVolumeRequestDefaultTypeInternal _GetVoiceVolumeRequest_default_instance_;
class GetVoiceVolumeResponse;
class GetVoiceVolumeResponseDefaultTypeInternal;
extern GetVoiceVolumeResponseDefaultTypeInternal _GetVoiceVolumeResponse_default_instance_;
class HibernateRequest;
class HibernateRequestDefaultTypeInternal;
extern HibernateRequestDefaultTypeInternal _HibernateRequest_default_instance_;
class HibernateResponse;
class HibernateResponseDefaultTypeInternal;
extern HibernateResponseDefaultTypeInternal _HibernateResponse_default_instance_;
class ListenSpeechEventRequest;
class ListenSpeechEventRequestDefaultTypeInternal;
extern ListenSpeechEventRequestDefaultTypeInternal _ListenSpeechEventRequest_default_instance_;
class ListenSpeechEventResponse;
class ListenSpeechEventResponseDefaultTypeInternal;
extern ListenSpeechEventResponseDefaultTypeInternal _ListenSpeechEventResponse_default_instance_;
class ResultInfo;
class ResultInfoDefaultTypeInternal;
extern ResultInfoDefaultTypeInternal _ResultInfo_default_instance_;
class SetParamsRequest;
class SetParamsRequestDefaultTypeInternal;
extern SetParamsRequestDefaultTypeInternal _SetParamsRequest_default_instance_;
class SetParamsResponse;
class SetParamsResponseDefaultTypeInternal;
extern SetParamsResponseDefaultTypeInternal _SetParamsResponse_default_instance_;
class SetVoiceVolumeRequest;
class SetVoiceVolumeRequestDefaultTypeInternal;
extern SetVoiceVolumeRequestDefaultTypeInternal _SetVoiceVolumeRequest_default_instance_;
class SetVoiceVolumeResponse;
class SetVoiceVolumeResponseDefaultTypeInternal;
extern SetVoiceVolumeResponseDefaultTypeInternal _SetVoiceVolumeResponse_default_instance_;
class SpeechStopRequest;
class SpeechStopRequestDefaultTypeInternal;
extern SpeechStopRequestDefaultTypeInternal _SpeechStopRequest_default_instance_;
class SpeechStopResponse;
class SpeechStopResponseDefaultTypeInternal;
extern SpeechStopResponseDefaultTypeInternal _SpeechStopResponse_default_instance_;
class TextToSpeechRequest;
class TextToSpeechRequestDefaultTypeInternal;
extern TextToSpeechRequestDefaultTypeInternal _TextToSpeechRequest_default_instance_;
class TextToSpeechResponse;
class TextToSpeechResponseDefaultTypeInternal;
extern TextToSpeechResponseDefaultTypeInternal _TextToSpeechResponse_default_instance_;
class VadInfo;
class VadInfoDefaultTypeInternal;
extern VadInfoDefaultTypeInternal _VadInfo_default_instance_;
class VoiceVolumeInfo;
class VoiceVolumeInfoDefaultTypeInternal;
extern VoiceVolumeInfoDefaultTypeInternal _VoiceVolumeInfo_default_instance_;
class WakeUpInfo;
class WakeUpInfoDefaultTypeInternal;
extern WakeUpInfoDefaultTypeInternal _WakeUpInfo_default_instance_;
class WakeUpRequest;
class WakeUpRequestDefaultTypeInternal;
extern WakeUpRequestDefaultTypeInternal _WakeUpRequest_default_instance_;
class WakeUpResponse;
class WakeUpResponseDefaultTypeInternal;
extern WakeUpResponseDefaultTypeInternal _WakeUpResponse_default_instance_;
}  // namespace speechService
namespace google {
namespace protobuf {
template<> ::speechService::ErrorInfo* Arena::CreateMaybeMessage<::speechService::ErrorInfo>(Arena*);
template<> ::speechService::GetVoiceVolumeRequest* Arena::CreateMaybeMessage<::speechService::GetVoiceVolumeRequest>(Arena*);
template<> ::speechService::GetVoiceVolumeResponse* Arena::CreateMaybeMessage<::speechService::GetVoiceVolumeResponse>(Arena*);
template<> ::speechService::HibernateRequest* Arena::CreateMaybeMessage<::speechService::HibernateRequest>(Arena*);
template<> ::speechService::HibernateResponse* Arena::CreateMaybeMessage<::speechService::HibernateResponse>(Arena*);
template<> ::speechService::ListenSpeechEventRequest* Arena::CreateMaybeMessage<::speechService::ListenSpeechEventRequest>(Arena*);
template<> ::speechService::ListenSpeechEventResponse* Arena::CreateMaybeMessage<::speechService::ListenSpeechEventResponse>(Arena*);
template<> ::speechService::ResultInfo* Arena::CreateMaybeMessage<::speechService::ResultInfo>(Arena*);
template<> ::speechService::SetParamsRequest* Arena::CreateMaybeMessage<::speechService::SetParamsRequest>(Arena*);
template<> ::speechService::SetParamsResponse* Arena::CreateMaybeMessage<::speechService::SetParamsResponse>(Arena*);
template<> ::speechService::SetVoiceVolumeRequest* Arena::CreateMaybeMessage<::speechService::SetVoiceVolumeRequest>(Arena*);
template<> ::speechService::SetVoiceVolumeResponse* Arena::CreateMaybeMessage<::speechService::SetVoiceVolumeResponse>(Arena*);
template<> ::speechService::SpeechStopRequest* Arena::CreateMaybeMessage<::speechService::SpeechStopRequest>(Arena*);
template<> ::speechService::SpeechStopResponse* Arena::CreateMaybeMessage<::speechService::SpeechStopResponse>(Arena*);
template<> ::speechService::TextToSpeechRequest* Arena::CreateMaybeMessage<::speechService::TextToSpeechRequest>(Arena*);
template<> ::speechService::TextToSpeechResponse* Arena::CreateMaybeMessage<::speechService::TextToSpeechResponse>(Arena*);
template<> ::speechService::VadInfo* Arena::CreateMaybeMessage<::speechService::VadInfo>(Arena*);
template<> ::speechService::VoiceVolumeInfo* Arena::CreateMaybeMessage<::speechService::VoiceVolumeInfo>(Arena*);
template<> ::speechService::WakeUpInfo* Arena::CreateMaybeMessage<::speechService::WakeUpInfo>(Arena*);
template<> ::speechService::WakeUpRequest* Arena::CreateMaybeMessage<::speechService::WakeUpRequest>(Arena*);
template<> ::speechService::WakeUpResponse* Arena::CreateMaybeMessage<::speechService::WakeUpResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace speechService {

enum SpeechEvent {
  UNKNOWN_EVENT = 0,
  WAKE_UP = 1,
  HIBERNATE = 2,
  ERROR = 3,
  VAD = 4,
  RESULT = 5,
  TTS_START = 6,
  TTS_END = 7,
  SpeechEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  SpeechEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool SpeechEvent_IsValid(int value);
const SpeechEvent SpeechEvent_MIN = UNKNOWN_EVENT;
const SpeechEvent SpeechEvent_MAX = TTS_END;
const int SpeechEvent_ARRAYSIZE = SpeechEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeechEvent_descriptor();
inline const ::std::string& SpeechEvent_Name(SpeechEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeechEvent_descriptor(), value);
}
inline bool SpeechEvent_Parse(
    const ::std::string& name, SpeechEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeechEvent>(
    SpeechEvent_descriptor(), name, value);
}
enum ErrorType {
  UNKNOWN_ERROR_TYPE = 0,
  ERR_TIMEOUT = 1,
  ERR_PARAMS = 2,
  ERR_AUTH = 3,
  ERR_NETWORK = 4,
  ERR_NOT_READY = 5,
  ERR_CONFIG = 6,
  ErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = UNKNOWN_ERROR_TYPE;
const ErrorType ErrorType_MAX = ERR_CONFIG;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum VadType {
  UNKNOWM_VAD_TYPE = 0,
  START = 1,
  END = 2,
  TIMEOUT = 3,
  VOLUME_CHANGE = 4,
  VadType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  VadType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool VadType_IsValid(int value);
const VadType VadType_MIN = UNKNOWM_VAD_TYPE;
const VadType VadType_MAX = VOLUME_CHANGE;
const int VadType_ARRAYSIZE = VadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VadType_descriptor();
inline const ::std::string& VadType_Name(VadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VadType_descriptor(), value);
}
inline bool VadType_Parse(
    const ::std::string& name, VadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VadType>(
    VadType_descriptor(), name, value);
}
// ===================================================================

class ErrorInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.ErrorInfo) */ {
 public:
  ErrorInfo();
  virtual ~ErrorInfo();

  ErrorInfo(const ErrorInfo& from);

  inline ErrorInfo& operator=(const ErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorInfo(ErrorInfo&& from) noexcept
    : ErrorInfo() {
    *this = ::std::move(from);
  }

  inline ErrorInfo& operator=(ErrorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ErrorInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorInfo* internal_default_instance() {
    return reinterpret_cast<const ErrorInfo*>(
               &_ErrorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ErrorInfo* other);
  friend void swap(ErrorInfo& a, ErrorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorInfo* New() const final {
    return CreateMaybeMessage<ErrorInfo>(nullptr);
  }

  ErrorInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorInfo& from);
  void MergeFrom(const ErrorInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string info = 2;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // string code = 3;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // .speechService.ErrorType error_type = 1;
  void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  ::speechService::ErrorType error_type() const;
  void set_error_type(::speechService::ErrorType value);

  // @@protoc_insertion_point(class_scope:speechService.ErrorInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  int error_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class VadInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.VadInfo) */ {
 public:
  VadInfo();
  virtual ~VadInfo();

  VadInfo(const VadInfo& from);

  inline VadInfo& operator=(const VadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VadInfo(VadInfo&& from) noexcept
    : VadInfo() {
    *this = ::std::move(from);
  }

  inline VadInfo& operator=(VadInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VadInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VadInfo* internal_default_instance() {
    return reinterpret_cast<const VadInfo*>(
               &_VadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(VadInfo* other);
  friend void swap(VadInfo& a, VadInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VadInfo* New() const final {
    return CreateMaybeMessage<VadInfo>(nullptr);
  }

  VadInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VadInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VadInfo& from);
  void MergeFrom(const VadInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VadInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speechService.VadType vad_type = 1;
  void clear_vad_type();
  static const int kVadTypeFieldNumber = 1;
  ::speechService::VadType vad_type() const;
  void set_vad_type(::speechService::VadType value);

  // uint32 vol = 2;
  void clear_vol();
  static const int kVolFieldNumber = 2;
  ::google::protobuf::uint32 vol() const;
  void set_vol(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:speechService.VadInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int vad_type_;
  ::google::protobuf::uint32 vol_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class WakeUpInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.WakeUpInfo) */ {
 public:
  WakeUpInfo();
  virtual ~WakeUpInfo();

  WakeUpInfo(const WakeUpInfo& from);

  inline WakeUpInfo& operator=(const WakeUpInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WakeUpInfo(WakeUpInfo&& from) noexcept
    : WakeUpInfo() {
    *this = ::std::move(from);
  }

  inline WakeUpInfo& operator=(WakeUpInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WakeUpInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WakeUpInfo* internal_default_instance() {
    return reinterpret_cast<const WakeUpInfo*>(
               &_WakeUpInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WakeUpInfo* other);
  friend void swap(WakeUpInfo& a, WakeUpInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WakeUpInfo* New() const final {
    return CreateMaybeMessage<WakeUpInfo>(nullptr);
  }

  WakeUpInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WakeUpInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WakeUpInfo& from);
  void MergeFrom(const WakeUpInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WakeUpInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 angle = 1;
  void clear_angle();
  static const int kAngleFieldNumber = 1;
  ::google::protobuf::int32 angle() const;
  void set_angle(::google::protobuf::int32 value);

  // int32 beam = 2;
  void clear_beam();
  static const int kBeamFieldNumber = 2;
  ::google::protobuf::int32 beam() const;
  void set_beam(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:speechService.WakeUpInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 angle_;
  ::google::protobuf::int32 beam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class ResultInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.ResultInfo) */ {
 public:
  ResultInfo();
  virtual ~ResultInfo();

  ResultInfo(const ResultInfo& from);

  inline ResultInfo& operator=(const ResultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResultInfo(ResultInfo&& from) noexcept
    : ResultInfo() {
    *this = ::std::move(from);
  }

  inline ResultInfo& operator=(ResultInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ResultInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultInfo* internal_default_instance() {
    return reinterpret_cast<const ResultInfo*>(
               &_ResultInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResultInfo* other);
  friend void swap(ResultInfo& a, ResultInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResultInfo* New() const final {
    return CreateMaybeMessage<ResultInfo>(nullptr);
  }

  ResultInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResultInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResultInfo& from);
  void MergeFrom(const ResultInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string words = 1;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 1;
  const ::std::string& words(int index) const;
  ::std::string* mutable_words(int index);
  void set_words(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_words(int index, ::std::string&& value);
  #endif
  void set_words(int index, const char* value);
  void set_words(int index, const char* value, size_t size);
  ::std::string* add_words();
  void add_words(const ::std::string& value);
  #if LANG_CXX11
  void add_words(::std::string&& value);
  #endif
  void add_words(const char* value);
  void add_words(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& words() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_words();

  // bool sentence_complete = 2;
  void clear_sentence_complete();
  static const int kSentenceCompleteFieldNumber = 2;
  bool sentence_complete() const;
  void set_sentence_complete(bool value);

  // @@protoc_insertion_point(class_scope:speechService.ResultInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> words_;
  bool sentence_complete_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class ListenSpeechEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.ListenSpeechEventRequest) */ {
 public:
  ListenSpeechEventRequest();
  virtual ~ListenSpeechEventRequest();

  ListenSpeechEventRequest(const ListenSpeechEventRequest& from);

  inline ListenSpeechEventRequest& operator=(const ListenSpeechEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListenSpeechEventRequest(ListenSpeechEventRequest&& from) noexcept
    : ListenSpeechEventRequest() {
    *this = ::std::move(from);
  }

  inline ListenSpeechEventRequest& operator=(ListenSpeechEventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListenSpeechEventRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenSpeechEventRequest* internal_default_instance() {
    return reinterpret_cast<const ListenSpeechEventRequest*>(
               &_ListenSpeechEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ListenSpeechEventRequest* other);
  friend void swap(ListenSpeechEventRequest& a, ListenSpeechEventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListenSpeechEventRequest* New() const final {
    return CreateMaybeMessage<ListenSpeechEventRequest>(nullptr);
  }

  ListenSpeechEventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenSpeechEventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenSpeechEventRequest& from);
  void MergeFrom(const ListenSpeechEventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenSpeechEventRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool with_vad_vol = 1;
  void clear_with_vad_vol();
  static const int kWithVadVolFieldNumber = 1;
  bool with_vad_vol() const;
  void set_with_vad_vol(bool value);

  // @@protoc_insertion_point(class_scope:speechService.ListenSpeechEventRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool with_vad_vol_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class ListenSpeechEventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.ListenSpeechEventResponse) */ {
 public:
  ListenSpeechEventResponse();
  virtual ~ListenSpeechEventResponse();

  ListenSpeechEventResponse(const ListenSpeechEventResponse& from);

  inline ListenSpeechEventResponse& operator=(const ListenSpeechEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListenSpeechEventResponse(ListenSpeechEventResponse&& from) noexcept
    : ListenSpeechEventResponse() {
    *this = ::std::move(from);
  }

  inline ListenSpeechEventResponse& operator=(ListenSpeechEventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListenSpeechEventResponse& default_instance();

  enum SpeechEventOneofCase {
    kWakeUpInfo = 2,
    kVadInfo = 3,
    kResultInfo = 4,
    kErrorInfo = 5,
    SPEECH_EVENT_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenSpeechEventResponse* internal_default_instance() {
    return reinterpret_cast<const ListenSpeechEventResponse*>(
               &_ListenSpeechEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ListenSpeechEventResponse* other);
  friend void swap(ListenSpeechEventResponse& a, ListenSpeechEventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListenSpeechEventResponse* New() const final {
    return CreateMaybeMessage<ListenSpeechEventResponse>(nullptr);
  }

  ListenSpeechEventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenSpeechEventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenSpeechEventResponse& from);
  void MergeFrom(const ListenSpeechEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenSpeechEventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speechService.SpeechEvent event_type = 1;
  void clear_event_type();
  static const int kEventTypeFieldNumber = 1;
  ::speechService::SpeechEvent event_type() const;
  void set_event_type(::speechService::SpeechEvent value);

  // .speechService.WakeUpInfo wake_up_info = 2;
  bool has_wake_up_info() const;
  void clear_wake_up_info();
  static const int kWakeUpInfoFieldNumber = 2;
  const ::speechService::WakeUpInfo& wake_up_info() const;
  ::speechService::WakeUpInfo* release_wake_up_info();
  ::speechService::WakeUpInfo* mutable_wake_up_info();
  void set_allocated_wake_up_info(::speechService::WakeUpInfo* wake_up_info);

  // .speechService.VadInfo vad_info = 3;
  bool has_vad_info() const;
  void clear_vad_info();
  static const int kVadInfoFieldNumber = 3;
  const ::speechService::VadInfo& vad_info() const;
  ::speechService::VadInfo* release_vad_info();
  ::speechService::VadInfo* mutable_vad_info();
  void set_allocated_vad_info(::speechService::VadInfo* vad_info);

  // .speechService.ResultInfo result_info = 4;
  bool has_result_info() const;
  void clear_result_info();
  static const int kResultInfoFieldNumber = 4;
  const ::speechService::ResultInfo& result_info() const;
  ::speechService::ResultInfo* release_result_info();
  ::speechService::ResultInfo* mutable_result_info();
  void set_allocated_result_info(::speechService::ResultInfo* result_info);

  // .speechService.ErrorInfo error_info = 5;
  bool has_error_info() const;
  void clear_error_info();
  static const int kErrorInfoFieldNumber = 5;
  const ::speechService::ErrorInfo& error_info() const;
  ::speechService::ErrorInfo* release_error_info();
  ::speechService::ErrorInfo* mutable_error_info();
  void set_allocated_error_info(::speechService::ErrorInfo* error_info);

  void clear_speech_event_oneof();
  SpeechEventOneofCase speech_event_oneof_case() const;
  // @@protoc_insertion_point(class_scope:speechService.ListenSpeechEventResponse)
 private:
  class HasBitSetters;
  void set_has_wake_up_info();
  void set_has_vad_info();
  void set_has_result_info();
  void set_has_error_info();

  inline bool has_speech_event_oneof() const;
  inline void clear_has_speech_event_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int event_type_;
  union SpeechEventOneofUnion {
    SpeechEventOneofUnion() {}
    ::speechService::WakeUpInfo* wake_up_info_;
    ::speechService::VadInfo* vad_info_;
    ::speechService::ResultInfo* result_info_;
    ::speechService::ErrorInfo* error_info_;
  } speech_event_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class TextToSpeechRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.TextToSpeechRequest) */ {
 public:
  TextToSpeechRequest();
  virtual ~TextToSpeechRequest();

  TextToSpeechRequest(const TextToSpeechRequest& from);

  inline TextToSpeechRequest& operator=(const TextToSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextToSpeechRequest(TextToSpeechRequest&& from) noexcept
    : TextToSpeechRequest() {
    *this = ::std::move(from);
  }

  inline TextToSpeechRequest& operator=(TextToSpeechRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TextToSpeechRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextToSpeechRequest* internal_default_instance() {
    return reinterpret_cast<const TextToSpeechRequest*>(
               &_TextToSpeechRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TextToSpeechRequest* other);
  friend void swap(TextToSpeechRequest& a, TextToSpeechRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextToSpeechRequest* New() const final {
    return CreateMaybeMessage<TextToSpeechRequest>(nullptr);
  }

  TextToSpeechRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextToSpeechRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextToSpeechRequest& from);
  void MergeFrom(const TextToSpeechRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextToSpeechRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:speechService.TextToSpeechRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class TextToSpeechResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.TextToSpeechResponse) */ {
 public:
  TextToSpeechResponse();
  virtual ~TextToSpeechResponse();

  TextToSpeechResponse(const TextToSpeechResponse& from);

  inline TextToSpeechResponse& operator=(const TextToSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextToSpeechResponse(TextToSpeechResponse&& from) noexcept
    : TextToSpeechResponse() {
    *this = ::std::move(from);
  }

  inline TextToSpeechResponse& operator=(TextToSpeechResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TextToSpeechResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextToSpeechResponse* internal_default_instance() {
    return reinterpret_cast<const TextToSpeechResponse*>(
               &_TextToSpeechResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TextToSpeechResponse* other);
  friend void swap(TextToSpeechResponse& a, TextToSpeechResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextToSpeechResponse* New() const final {
    return CreateMaybeMessage<TextToSpeechResponse>(nullptr);
  }

  TextToSpeechResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextToSpeechResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextToSpeechResponse& from);
  void MergeFrom(const TextToSpeechResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextToSpeechResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.TextToSpeechResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class SpeechStopRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.SpeechStopRequest) */ {
 public:
  SpeechStopRequest();
  virtual ~SpeechStopRequest();

  SpeechStopRequest(const SpeechStopRequest& from);

  inline SpeechStopRequest& operator=(const SpeechStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeechStopRequest(SpeechStopRequest&& from) noexcept
    : SpeechStopRequest() {
    *this = ::std::move(from);
  }

  inline SpeechStopRequest& operator=(SpeechStopRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SpeechStopRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechStopRequest* internal_default_instance() {
    return reinterpret_cast<const SpeechStopRequest*>(
               &_SpeechStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SpeechStopRequest* other);
  friend void swap(SpeechStopRequest& a, SpeechStopRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeechStopRequest* New() const final {
    return CreateMaybeMessage<SpeechStopRequest>(nullptr);
  }

  SpeechStopRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeechStopRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeechStopRequest& from);
  void MergeFrom(const SpeechStopRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechStopRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.SpeechStopRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class SpeechStopResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.SpeechStopResponse) */ {
 public:
  SpeechStopResponse();
  virtual ~SpeechStopResponse();

  SpeechStopResponse(const SpeechStopResponse& from);

  inline SpeechStopResponse& operator=(const SpeechStopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeechStopResponse(SpeechStopResponse&& from) noexcept
    : SpeechStopResponse() {
    *this = ::std::move(from);
  }

  inline SpeechStopResponse& operator=(SpeechStopResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SpeechStopResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechStopResponse* internal_default_instance() {
    return reinterpret_cast<const SpeechStopResponse*>(
               &_SpeechStopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SpeechStopResponse* other);
  friend void swap(SpeechStopResponse& a, SpeechStopResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeechStopResponse* New() const final {
    return CreateMaybeMessage<SpeechStopResponse>(nullptr);
  }

  SpeechStopResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeechStopResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeechStopResponse& from);
  void MergeFrom(const SpeechStopResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechStopResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.SpeechStopResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class WakeUpRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.WakeUpRequest) */ {
 public:
  WakeUpRequest();
  virtual ~WakeUpRequest();

  WakeUpRequest(const WakeUpRequest& from);

  inline WakeUpRequest& operator=(const WakeUpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WakeUpRequest(WakeUpRequest&& from) noexcept
    : WakeUpRequest() {
    *this = ::std::move(from);
  }

  inline WakeUpRequest& operator=(WakeUpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WakeUpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WakeUpRequest* internal_default_instance() {
    return reinterpret_cast<const WakeUpRequest*>(
               &_WakeUpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(WakeUpRequest* other);
  friend void swap(WakeUpRequest& a, WakeUpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WakeUpRequest* New() const final {
    return CreateMaybeMessage<WakeUpRequest>(nullptr);
  }

  WakeUpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WakeUpRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WakeUpRequest& from);
  void MergeFrom(const WakeUpRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WakeUpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string after_wake_up_speech_text = 1;
  void clear_after_wake_up_speech_text();
  static const int kAfterWakeUpSpeechTextFieldNumber = 1;
  const ::std::string& after_wake_up_speech_text() const;
  void set_after_wake_up_speech_text(const ::std::string& value);
  #if LANG_CXX11
  void set_after_wake_up_speech_text(::std::string&& value);
  #endif
  void set_after_wake_up_speech_text(const char* value);
  void set_after_wake_up_speech_text(const char* value, size_t size);
  ::std::string* mutable_after_wake_up_speech_text();
  ::std::string* release_after_wake_up_speech_text();
  void set_allocated_after_wake_up_speech_text(::std::string* after_wake_up_speech_text);

  // @@protoc_insertion_point(class_scope:speechService.WakeUpRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr after_wake_up_speech_text_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class WakeUpResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.WakeUpResponse) */ {
 public:
  WakeUpResponse();
  virtual ~WakeUpResponse();

  WakeUpResponse(const WakeUpResponse& from);

  inline WakeUpResponse& operator=(const WakeUpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WakeUpResponse(WakeUpResponse&& from) noexcept
    : WakeUpResponse() {
    *this = ::std::move(from);
  }

  inline WakeUpResponse& operator=(WakeUpResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WakeUpResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WakeUpResponse* internal_default_instance() {
    return reinterpret_cast<const WakeUpResponse*>(
               &_WakeUpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(WakeUpResponse* other);
  friend void swap(WakeUpResponse& a, WakeUpResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WakeUpResponse* New() const final {
    return CreateMaybeMessage<WakeUpResponse>(nullptr);
  }

  WakeUpResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WakeUpResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WakeUpResponse& from);
  void MergeFrom(const WakeUpResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WakeUpResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.WakeUpResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class HibernateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.HibernateRequest) */ {
 public:
  HibernateRequest();
  virtual ~HibernateRequest();

  HibernateRequest(const HibernateRequest& from);

  inline HibernateRequest& operator=(const HibernateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HibernateRequest(HibernateRequest&& from) noexcept
    : HibernateRequest() {
    *this = ::std::move(from);
  }

  inline HibernateRequest& operator=(HibernateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HibernateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HibernateRequest* internal_default_instance() {
    return reinterpret_cast<const HibernateRequest*>(
               &_HibernateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(HibernateRequest* other);
  friend void swap(HibernateRequest& a, HibernateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HibernateRequest* New() const final {
    return CreateMaybeMessage<HibernateRequest>(nullptr);
  }

  HibernateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HibernateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HibernateRequest& from);
  void MergeFrom(const HibernateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HibernateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.HibernateRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class HibernateResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.HibernateResponse) */ {
 public:
  HibernateResponse();
  virtual ~HibernateResponse();

  HibernateResponse(const HibernateResponse& from);

  inline HibernateResponse& operator=(const HibernateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HibernateResponse(HibernateResponse&& from) noexcept
    : HibernateResponse() {
    *this = ::std::move(from);
  }

  inline HibernateResponse& operator=(HibernateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HibernateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HibernateResponse* internal_default_instance() {
    return reinterpret_cast<const HibernateResponse*>(
               &_HibernateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(HibernateResponse* other);
  friend void swap(HibernateResponse& a, HibernateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HibernateResponse* New() const final {
    return CreateMaybeMessage<HibernateResponse>(nullptr);
  }

  HibernateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HibernateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HibernateResponse& from);
  void MergeFrom(const HibernateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HibernateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.HibernateResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class VoiceVolumeInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.VoiceVolumeInfo) */ {
 public:
  VoiceVolumeInfo();
  virtual ~VoiceVolumeInfo();

  VoiceVolumeInfo(const VoiceVolumeInfo& from);

  inline VoiceVolumeInfo& operator=(const VoiceVolumeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoiceVolumeInfo(VoiceVolumeInfo&& from) noexcept
    : VoiceVolumeInfo() {
    *this = ::std::move(from);
  }

  inline VoiceVolumeInfo& operator=(VoiceVolumeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VoiceVolumeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoiceVolumeInfo* internal_default_instance() {
    return reinterpret_cast<const VoiceVolumeInfo*>(
               &_VoiceVolumeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(VoiceVolumeInfo* other);
  friend void swap(VoiceVolumeInfo& a, VoiceVolumeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoiceVolumeInfo* New() const final {
    return CreateMaybeMessage<VoiceVolumeInfo>(nullptr);
  }

  VoiceVolumeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoiceVolumeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VoiceVolumeInfo& from);
  void MergeFrom(const VoiceVolumeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceVolumeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 vol = 1;
  void clear_vol();
  static const int kVolFieldNumber = 1;
  ::google::protobuf::uint32 vol() const;
  void set_vol(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:speechService.VoiceVolumeInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 vol_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class SetVoiceVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.SetVoiceVolumeRequest) */ {
 public:
  SetVoiceVolumeRequest();
  virtual ~SetVoiceVolumeRequest();

  SetVoiceVolumeRequest(const SetVoiceVolumeRequest& from);

  inline SetVoiceVolumeRequest& operator=(const SetVoiceVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetVoiceVolumeRequest(SetVoiceVolumeRequest&& from) noexcept
    : SetVoiceVolumeRequest() {
    *this = ::std::move(from);
  }

  inline SetVoiceVolumeRequest& operator=(SetVoiceVolumeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SetVoiceVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetVoiceVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const SetVoiceVolumeRequest*>(
               &_SetVoiceVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(SetVoiceVolumeRequest* other);
  friend void swap(SetVoiceVolumeRequest& a, SetVoiceVolumeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetVoiceVolumeRequest* New() const final {
    return CreateMaybeMessage<SetVoiceVolumeRequest>(nullptr);
  }

  SetVoiceVolumeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetVoiceVolumeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetVoiceVolumeRequest& from);
  void MergeFrom(const SetVoiceVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVoiceVolumeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speechService.VoiceVolumeInfo voice_volume_info = 1;
  bool has_voice_volume_info() const;
  void clear_voice_volume_info();
  static const int kVoiceVolumeInfoFieldNumber = 1;
  const ::speechService::VoiceVolumeInfo& voice_volume_info() const;
  ::speechService::VoiceVolumeInfo* release_voice_volume_info();
  ::speechService::VoiceVolumeInfo* mutable_voice_volume_info();
  void set_allocated_voice_volume_info(::speechService::VoiceVolumeInfo* voice_volume_info);

  // @@protoc_insertion_point(class_scope:speechService.SetVoiceVolumeRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::speechService::VoiceVolumeInfo* voice_volume_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class SetVoiceVolumeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.SetVoiceVolumeResponse) */ {
 public:
  SetVoiceVolumeResponse();
  virtual ~SetVoiceVolumeResponse();

  SetVoiceVolumeResponse(const SetVoiceVolumeResponse& from);

  inline SetVoiceVolumeResponse& operator=(const SetVoiceVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetVoiceVolumeResponse(SetVoiceVolumeResponse&& from) noexcept
    : SetVoiceVolumeResponse() {
    *this = ::std::move(from);
  }

  inline SetVoiceVolumeResponse& operator=(SetVoiceVolumeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SetVoiceVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetVoiceVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const SetVoiceVolumeResponse*>(
               &_SetVoiceVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(SetVoiceVolumeResponse* other);
  friend void swap(SetVoiceVolumeResponse& a, SetVoiceVolumeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetVoiceVolumeResponse* New() const final {
    return CreateMaybeMessage<SetVoiceVolumeResponse>(nullptr);
  }

  SetVoiceVolumeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetVoiceVolumeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetVoiceVolumeResponse& from);
  void MergeFrom(const SetVoiceVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVoiceVolumeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speechService.VoiceVolumeInfo voice_volume_info = 1;
  bool has_voice_volume_info() const;
  void clear_voice_volume_info();
  static const int kVoiceVolumeInfoFieldNumber = 1;
  const ::speechService::VoiceVolumeInfo& voice_volume_info() const;
  ::speechService::VoiceVolumeInfo* release_voice_volume_info();
  ::speechService::VoiceVolumeInfo* mutable_voice_volume_info();
  void set_allocated_voice_volume_info(::speechService::VoiceVolumeInfo* voice_volume_info);

  // @@protoc_insertion_point(class_scope:speechService.SetVoiceVolumeResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::speechService::VoiceVolumeInfo* voice_volume_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class GetVoiceVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.GetVoiceVolumeRequest) */ {
 public:
  GetVoiceVolumeRequest();
  virtual ~GetVoiceVolumeRequest();

  GetVoiceVolumeRequest(const GetVoiceVolumeRequest& from);

  inline GetVoiceVolumeRequest& operator=(const GetVoiceVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVoiceVolumeRequest(GetVoiceVolumeRequest&& from) noexcept
    : GetVoiceVolumeRequest() {
    *this = ::std::move(from);
  }

  inline GetVoiceVolumeRequest& operator=(GetVoiceVolumeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetVoiceVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVoiceVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const GetVoiceVolumeRequest*>(
               &_GetVoiceVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetVoiceVolumeRequest* other);
  friend void swap(GetVoiceVolumeRequest& a, GetVoiceVolumeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVoiceVolumeRequest* New() const final {
    return CreateMaybeMessage<GetVoiceVolumeRequest>(nullptr);
  }

  GetVoiceVolumeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetVoiceVolumeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetVoiceVolumeRequest& from);
  void MergeFrom(const GetVoiceVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVoiceVolumeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.GetVoiceVolumeRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class GetVoiceVolumeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.GetVoiceVolumeResponse) */ {
 public:
  GetVoiceVolumeResponse();
  virtual ~GetVoiceVolumeResponse();

  GetVoiceVolumeResponse(const GetVoiceVolumeResponse& from);

  inline GetVoiceVolumeResponse& operator=(const GetVoiceVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVoiceVolumeResponse(GetVoiceVolumeResponse&& from) noexcept
    : GetVoiceVolumeResponse() {
    *this = ::std::move(from);
  }

  inline GetVoiceVolumeResponse& operator=(GetVoiceVolumeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetVoiceVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVoiceVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const GetVoiceVolumeResponse*>(
               &_GetVoiceVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetVoiceVolumeResponse* other);
  friend void swap(GetVoiceVolumeResponse& a, GetVoiceVolumeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVoiceVolumeResponse* New() const final {
    return CreateMaybeMessage<GetVoiceVolumeResponse>(nullptr);
  }

  GetVoiceVolumeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetVoiceVolumeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetVoiceVolumeResponse& from);
  void MergeFrom(const GetVoiceVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVoiceVolumeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .speechService.VoiceVolumeInfo voice_volume_info = 1;
  bool has_voice_volume_info() const;
  void clear_voice_volume_info();
  static const int kVoiceVolumeInfoFieldNumber = 1;
  const ::speechService::VoiceVolumeInfo& voice_volume_info() const;
  ::speechService::VoiceVolumeInfo* release_voice_volume_info();
  ::speechService::VoiceVolumeInfo* mutable_voice_volume_info();
  void set_allocated_voice_volume_info(::speechService::VoiceVolumeInfo* voice_volume_info);

  // @@protoc_insertion_point(class_scope:speechService.GetVoiceVolumeResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::speechService::VoiceVolumeInfo* voice_volume_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class SetParamsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.SetParamsRequest) */ {
 public:
  SetParamsRequest();
  virtual ~SetParamsRequest();

  SetParamsRequest(const SetParamsRequest& from);

  inline SetParamsRequest& operator=(const SetParamsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetParamsRequest(SetParamsRequest&& from) noexcept
    : SetParamsRequest() {
    *this = ::std::move(from);
  }

  inline SetParamsRequest& operator=(SetParamsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SetParamsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetParamsRequest* internal_default_instance() {
    return reinterpret_cast<const SetParamsRequest*>(
               &_SetParamsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(SetParamsRequest* other);
  friend void swap(SetParamsRequest& a, SetParamsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetParamsRequest* New() const final {
    return CreateMaybeMessage<SetParamsRequest>(nullptr);
  }

  SetParamsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetParamsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetParamsRequest& from);
  void MergeFrom(const SetParamsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetParamsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes params = 1;
  void clear_params();
  static const int kParamsFieldNumber = 1;
  const ::std::string& params() const;
  void set_params(const ::std::string& value);
  #if LANG_CXX11
  void set_params(::std::string&& value);
  #endif
  void set_params(const char* value);
  void set_params(const void* value, size_t size);
  ::std::string* mutable_params();
  ::std::string* release_params();
  void set_allocated_params(::std::string* params);

  // @@protoc_insertion_point(class_scope:speechService.SetParamsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr params_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// -------------------------------------------------------------------

class SetParamsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:speechService.SetParamsResponse) */ {
 public:
  SetParamsResponse();
  virtual ~SetParamsResponse();

  SetParamsResponse(const SetParamsResponse& from);

  inline SetParamsResponse& operator=(const SetParamsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetParamsResponse(SetParamsResponse&& from) noexcept
    : SetParamsResponse() {
    *this = ::std::move(from);
  }

  inline SetParamsResponse& operator=(SetParamsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SetParamsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetParamsResponse* internal_default_instance() {
    return reinterpret_cast<const SetParamsResponse*>(
               &_SetParamsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(SetParamsResponse* other);
  friend void swap(SetParamsResponse& a, SetParamsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetParamsResponse* New() const final {
    return CreateMaybeMessage<SetParamsResponse>(nullptr);
  }

  SetParamsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetParamsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetParamsResponse& from);
  void MergeFrom(const SetParamsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetParamsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:speechService.SetParamsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_speech_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ErrorInfo

// .speechService.ErrorType error_type = 1;
inline void ErrorInfo::clear_error_type() {
  error_type_ = 0;
}
inline ::speechService::ErrorType ErrorInfo::error_type() const {
  // @@protoc_insertion_point(field_get:speechService.ErrorInfo.error_type)
  return static_cast< ::speechService::ErrorType >(error_type_);
}
inline void ErrorInfo::set_error_type(::speechService::ErrorType value) {
  
  error_type_ = value;
  // @@protoc_insertion_point(field_set:speechService.ErrorInfo.error_type)
}

// string info = 2;
inline void ErrorInfo::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ErrorInfo::info() const {
  // @@protoc_insertion_point(field_get:speechService.ErrorInfo.info)
  return info_.GetNoArena();
}
inline void ErrorInfo::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechService.ErrorInfo.info)
}
#if LANG_CXX11
inline void ErrorInfo::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechService.ErrorInfo.info)
}
#endif
inline void ErrorInfo::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechService.ErrorInfo.info)
}
inline void ErrorInfo::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechService.ErrorInfo.info)
}
inline ::std::string* ErrorInfo::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:speechService.ErrorInfo.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorInfo::release_info() {
  // @@protoc_insertion_point(field_release:speechService.ErrorInfo.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorInfo::set_allocated_info(::std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:speechService.ErrorInfo.info)
}

// string code = 3;
inline void ErrorInfo::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ErrorInfo::code() const {
  // @@protoc_insertion_point(field_get:speechService.ErrorInfo.code)
  return code_.GetNoArena();
}
inline void ErrorInfo::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechService.ErrorInfo.code)
}
#if LANG_CXX11
inline void ErrorInfo::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechService.ErrorInfo.code)
}
#endif
inline void ErrorInfo::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechService.ErrorInfo.code)
}
inline void ErrorInfo::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechService.ErrorInfo.code)
}
inline ::std::string* ErrorInfo::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:speechService.ErrorInfo.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorInfo::release_code() {
  // @@protoc_insertion_point(field_release:speechService.ErrorInfo.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorInfo::set_allocated_code(::std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:speechService.ErrorInfo.code)
}

// -------------------------------------------------------------------

// VadInfo

// .speechService.VadType vad_type = 1;
inline void VadInfo::clear_vad_type() {
  vad_type_ = 0;
}
inline ::speechService::VadType VadInfo::vad_type() const {
  // @@protoc_insertion_point(field_get:speechService.VadInfo.vad_type)
  return static_cast< ::speechService::VadType >(vad_type_);
}
inline void VadInfo::set_vad_type(::speechService::VadType value) {
  
  vad_type_ = value;
  // @@protoc_insertion_point(field_set:speechService.VadInfo.vad_type)
}

// uint32 vol = 2;
inline void VadInfo::clear_vol() {
  vol_ = 0u;
}
inline ::google::protobuf::uint32 VadInfo::vol() const {
  // @@protoc_insertion_point(field_get:speechService.VadInfo.vol)
  return vol_;
}
inline void VadInfo::set_vol(::google::protobuf::uint32 value) {
  
  vol_ = value;
  // @@protoc_insertion_point(field_set:speechService.VadInfo.vol)
}

// -------------------------------------------------------------------

// WakeUpInfo

// int32 angle = 1;
inline void WakeUpInfo::clear_angle() {
  angle_ = 0;
}
inline ::google::protobuf::int32 WakeUpInfo::angle() const {
  // @@protoc_insertion_point(field_get:speechService.WakeUpInfo.angle)
  return angle_;
}
inline void WakeUpInfo::set_angle(::google::protobuf::int32 value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:speechService.WakeUpInfo.angle)
}

// int32 beam = 2;
inline void WakeUpInfo::clear_beam() {
  beam_ = 0;
}
inline ::google::protobuf::int32 WakeUpInfo::beam() const {
  // @@protoc_insertion_point(field_get:speechService.WakeUpInfo.beam)
  return beam_;
}
inline void WakeUpInfo::set_beam(::google::protobuf::int32 value) {
  
  beam_ = value;
  // @@protoc_insertion_point(field_set:speechService.WakeUpInfo.beam)
}

// -------------------------------------------------------------------

// ResultInfo

// repeated string words = 1;
inline int ResultInfo::words_size() const {
  return words_.size();
}
inline void ResultInfo::clear_words() {
  words_.Clear();
}
inline const ::std::string& ResultInfo::words(int index) const {
  // @@protoc_insertion_point(field_get:speechService.ResultInfo.words)
  return words_.Get(index);
}
inline ::std::string* ResultInfo::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:speechService.ResultInfo.words)
  return words_.Mutable(index);
}
inline void ResultInfo::set_words(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:speechService.ResultInfo.words)
  words_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResultInfo::set_words(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:speechService.ResultInfo.words)
  words_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResultInfo::set_words(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  words_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speechService.ResultInfo.words)
}
inline void ResultInfo::set_words(int index, const char* value, size_t size) {
  words_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speechService.ResultInfo.words)
}
inline ::std::string* ResultInfo::add_words() {
  // @@protoc_insertion_point(field_add_mutable:speechService.ResultInfo.words)
  return words_.Add();
}
inline void ResultInfo::add_words(const ::std::string& value) {
  words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speechService.ResultInfo.words)
}
#if LANG_CXX11
inline void ResultInfo::add_words(::std::string&& value) {
  words_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speechService.ResultInfo.words)
}
#endif
inline void ResultInfo::add_words(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  words_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speechService.ResultInfo.words)
}
inline void ResultInfo::add_words(const char* value, size_t size) {
  words_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speechService.ResultInfo.words)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
ResultInfo::words() const {
  // @@protoc_insertion_point(field_list:speechService.ResultInfo.words)
  return words_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
ResultInfo::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:speechService.ResultInfo.words)
  return &words_;
}

// bool sentence_complete = 2;
inline void ResultInfo::clear_sentence_complete() {
  sentence_complete_ = false;
}
inline bool ResultInfo::sentence_complete() const {
  // @@protoc_insertion_point(field_get:speechService.ResultInfo.sentence_complete)
  return sentence_complete_;
}
inline void ResultInfo::set_sentence_complete(bool value) {
  
  sentence_complete_ = value;
  // @@protoc_insertion_point(field_set:speechService.ResultInfo.sentence_complete)
}

// -------------------------------------------------------------------

// ListenSpeechEventRequest

// bool with_vad_vol = 1;
inline void ListenSpeechEventRequest::clear_with_vad_vol() {
  with_vad_vol_ = false;
}
inline bool ListenSpeechEventRequest::with_vad_vol() const {
  // @@protoc_insertion_point(field_get:speechService.ListenSpeechEventRequest.with_vad_vol)
  return with_vad_vol_;
}
inline void ListenSpeechEventRequest::set_with_vad_vol(bool value) {
  
  with_vad_vol_ = value;
  // @@protoc_insertion_point(field_set:speechService.ListenSpeechEventRequest.with_vad_vol)
}

// -------------------------------------------------------------------

// ListenSpeechEventResponse

// .speechService.SpeechEvent event_type = 1;
inline void ListenSpeechEventResponse::clear_event_type() {
  event_type_ = 0;
}
inline ::speechService::SpeechEvent ListenSpeechEventResponse::event_type() const {
  // @@protoc_insertion_point(field_get:speechService.ListenSpeechEventResponse.event_type)
  return static_cast< ::speechService::SpeechEvent >(event_type_);
}
inline void ListenSpeechEventResponse::set_event_type(::speechService::SpeechEvent value) {
  
  event_type_ = value;
  // @@protoc_insertion_point(field_set:speechService.ListenSpeechEventResponse.event_type)
}

// .speechService.WakeUpInfo wake_up_info = 2;
inline bool ListenSpeechEventResponse::has_wake_up_info() const {
  return speech_event_oneof_case() == kWakeUpInfo;
}
inline void ListenSpeechEventResponse::set_has_wake_up_info() {
  _oneof_case_[0] = kWakeUpInfo;
}
inline void ListenSpeechEventResponse::clear_wake_up_info() {
  if (has_wake_up_info()) {
    delete speech_event_oneof_.wake_up_info_;
    clear_has_speech_event_oneof();
  }
}
inline ::speechService::WakeUpInfo* ListenSpeechEventResponse::release_wake_up_info() {
  // @@protoc_insertion_point(field_release:speechService.ListenSpeechEventResponse.wake_up_info)
  if (has_wake_up_info()) {
    clear_has_speech_event_oneof();
      ::speechService::WakeUpInfo* temp = speech_event_oneof_.wake_up_info_;
    speech_event_oneof_.wake_up_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechService::WakeUpInfo& ListenSpeechEventResponse::wake_up_info() const {
  // @@protoc_insertion_point(field_get:speechService.ListenSpeechEventResponse.wake_up_info)
  return has_wake_up_info()
      ? *speech_event_oneof_.wake_up_info_
      : *reinterpret_cast< ::speechService::WakeUpInfo*>(&::speechService::_WakeUpInfo_default_instance_);
}
inline ::speechService::WakeUpInfo* ListenSpeechEventResponse::mutable_wake_up_info() {
  if (!has_wake_up_info()) {
    clear_speech_event_oneof();
    set_has_wake_up_info();
    speech_event_oneof_.wake_up_info_ = CreateMaybeMessage< ::speechService::WakeUpInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechService.ListenSpeechEventResponse.wake_up_info)
  return speech_event_oneof_.wake_up_info_;
}

// .speechService.VadInfo vad_info = 3;
inline bool ListenSpeechEventResponse::has_vad_info() const {
  return speech_event_oneof_case() == kVadInfo;
}
inline void ListenSpeechEventResponse::set_has_vad_info() {
  _oneof_case_[0] = kVadInfo;
}
inline void ListenSpeechEventResponse::clear_vad_info() {
  if (has_vad_info()) {
    delete speech_event_oneof_.vad_info_;
    clear_has_speech_event_oneof();
  }
}
inline ::speechService::VadInfo* ListenSpeechEventResponse::release_vad_info() {
  // @@protoc_insertion_point(field_release:speechService.ListenSpeechEventResponse.vad_info)
  if (has_vad_info()) {
    clear_has_speech_event_oneof();
      ::speechService::VadInfo* temp = speech_event_oneof_.vad_info_;
    speech_event_oneof_.vad_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechService::VadInfo& ListenSpeechEventResponse::vad_info() const {
  // @@protoc_insertion_point(field_get:speechService.ListenSpeechEventResponse.vad_info)
  return has_vad_info()
      ? *speech_event_oneof_.vad_info_
      : *reinterpret_cast< ::speechService::VadInfo*>(&::speechService::_VadInfo_default_instance_);
}
inline ::speechService::VadInfo* ListenSpeechEventResponse::mutable_vad_info() {
  if (!has_vad_info()) {
    clear_speech_event_oneof();
    set_has_vad_info();
    speech_event_oneof_.vad_info_ = CreateMaybeMessage< ::speechService::VadInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechService.ListenSpeechEventResponse.vad_info)
  return speech_event_oneof_.vad_info_;
}

// .speechService.ResultInfo result_info = 4;
inline bool ListenSpeechEventResponse::has_result_info() const {
  return speech_event_oneof_case() == kResultInfo;
}
inline void ListenSpeechEventResponse::set_has_result_info() {
  _oneof_case_[0] = kResultInfo;
}
inline void ListenSpeechEventResponse::clear_result_info() {
  if (has_result_info()) {
    delete speech_event_oneof_.result_info_;
    clear_has_speech_event_oneof();
  }
}
inline ::speechService::ResultInfo* ListenSpeechEventResponse::release_result_info() {
  // @@protoc_insertion_point(field_release:speechService.ListenSpeechEventResponse.result_info)
  if (has_result_info()) {
    clear_has_speech_event_oneof();
      ::speechService::ResultInfo* temp = speech_event_oneof_.result_info_;
    speech_event_oneof_.result_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechService::ResultInfo& ListenSpeechEventResponse::result_info() const {
  // @@protoc_insertion_point(field_get:speechService.ListenSpeechEventResponse.result_info)
  return has_result_info()
      ? *speech_event_oneof_.result_info_
      : *reinterpret_cast< ::speechService::ResultInfo*>(&::speechService::_ResultInfo_default_instance_);
}
inline ::speechService::ResultInfo* ListenSpeechEventResponse::mutable_result_info() {
  if (!has_result_info()) {
    clear_speech_event_oneof();
    set_has_result_info();
    speech_event_oneof_.result_info_ = CreateMaybeMessage< ::speechService::ResultInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechService.ListenSpeechEventResponse.result_info)
  return speech_event_oneof_.result_info_;
}

// .speechService.ErrorInfo error_info = 5;
inline bool ListenSpeechEventResponse::has_error_info() const {
  return speech_event_oneof_case() == kErrorInfo;
}
inline void ListenSpeechEventResponse::set_has_error_info() {
  _oneof_case_[0] = kErrorInfo;
}
inline void ListenSpeechEventResponse::clear_error_info() {
  if (has_error_info()) {
    delete speech_event_oneof_.error_info_;
    clear_has_speech_event_oneof();
  }
}
inline ::speechService::ErrorInfo* ListenSpeechEventResponse::release_error_info() {
  // @@protoc_insertion_point(field_release:speechService.ListenSpeechEventResponse.error_info)
  if (has_error_info()) {
    clear_has_speech_event_oneof();
      ::speechService::ErrorInfo* temp = speech_event_oneof_.error_info_;
    speech_event_oneof_.error_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::speechService::ErrorInfo& ListenSpeechEventResponse::error_info() const {
  // @@protoc_insertion_point(field_get:speechService.ListenSpeechEventResponse.error_info)
  return has_error_info()
      ? *speech_event_oneof_.error_info_
      : *reinterpret_cast< ::speechService::ErrorInfo*>(&::speechService::_ErrorInfo_default_instance_);
}
inline ::speechService::ErrorInfo* ListenSpeechEventResponse::mutable_error_info() {
  if (!has_error_info()) {
    clear_speech_event_oneof();
    set_has_error_info();
    speech_event_oneof_.error_info_ = CreateMaybeMessage< ::speechService::ErrorInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:speechService.ListenSpeechEventResponse.error_info)
  return speech_event_oneof_.error_info_;
}

inline bool ListenSpeechEventResponse::has_speech_event_oneof() const {
  return speech_event_oneof_case() != SPEECH_EVENT_ONEOF_NOT_SET;
}
inline void ListenSpeechEventResponse::clear_has_speech_event_oneof() {
  _oneof_case_[0] = SPEECH_EVENT_ONEOF_NOT_SET;
}
inline ListenSpeechEventResponse::SpeechEventOneofCase ListenSpeechEventResponse::speech_event_oneof_case() const {
  return ListenSpeechEventResponse::SpeechEventOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextToSpeechRequest

// string text = 1;
inline void TextToSpeechRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextToSpeechRequest::text() const {
  // @@protoc_insertion_point(field_get:speechService.TextToSpeechRequest.text)
  return text_.GetNoArena();
}
inline void TextToSpeechRequest::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechService.TextToSpeechRequest.text)
}
#if LANG_CXX11
inline void TextToSpeechRequest::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechService.TextToSpeechRequest.text)
}
#endif
inline void TextToSpeechRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechService.TextToSpeechRequest.text)
}
inline void TextToSpeechRequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechService.TextToSpeechRequest.text)
}
inline ::std::string* TextToSpeechRequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:speechService.TextToSpeechRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextToSpeechRequest::release_text() {
  // @@protoc_insertion_point(field_release:speechService.TextToSpeechRequest.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextToSpeechRequest::set_allocated_text(::std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:speechService.TextToSpeechRequest.text)
}

// -------------------------------------------------------------------

// TextToSpeechResponse

// -------------------------------------------------------------------

// SpeechStopRequest

// -------------------------------------------------------------------

// SpeechStopResponse

// -------------------------------------------------------------------

// WakeUpRequest

// string after_wake_up_speech_text = 1;
inline void WakeUpRequest::clear_after_wake_up_speech_text() {
  after_wake_up_speech_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WakeUpRequest::after_wake_up_speech_text() const {
  // @@protoc_insertion_point(field_get:speechService.WakeUpRequest.after_wake_up_speech_text)
  return after_wake_up_speech_text_.GetNoArena();
}
inline void WakeUpRequest::set_after_wake_up_speech_text(const ::std::string& value) {
  
  after_wake_up_speech_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechService.WakeUpRequest.after_wake_up_speech_text)
}
#if LANG_CXX11
inline void WakeUpRequest::set_after_wake_up_speech_text(::std::string&& value) {
  
  after_wake_up_speech_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechService.WakeUpRequest.after_wake_up_speech_text)
}
#endif
inline void WakeUpRequest::set_after_wake_up_speech_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  after_wake_up_speech_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechService.WakeUpRequest.after_wake_up_speech_text)
}
inline void WakeUpRequest::set_after_wake_up_speech_text(const char* value, size_t size) {
  
  after_wake_up_speech_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechService.WakeUpRequest.after_wake_up_speech_text)
}
inline ::std::string* WakeUpRequest::mutable_after_wake_up_speech_text() {
  
  // @@protoc_insertion_point(field_mutable:speechService.WakeUpRequest.after_wake_up_speech_text)
  return after_wake_up_speech_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WakeUpRequest::release_after_wake_up_speech_text() {
  // @@protoc_insertion_point(field_release:speechService.WakeUpRequest.after_wake_up_speech_text)
  
  return after_wake_up_speech_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WakeUpRequest::set_allocated_after_wake_up_speech_text(::std::string* after_wake_up_speech_text) {
  if (after_wake_up_speech_text != nullptr) {
    
  } else {
    
  }
  after_wake_up_speech_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), after_wake_up_speech_text);
  // @@protoc_insertion_point(field_set_allocated:speechService.WakeUpRequest.after_wake_up_speech_text)
}

// -------------------------------------------------------------------

// WakeUpResponse

// -------------------------------------------------------------------

// HibernateRequest

// -------------------------------------------------------------------

// HibernateResponse

// -------------------------------------------------------------------

// VoiceVolumeInfo

// uint32 vol = 1;
inline void VoiceVolumeInfo::clear_vol() {
  vol_ = 0u;
}
inline ::google::protobuf::uint32 VoiceVolumeInfo::vol() const {
  // @@protoc_insertion_point(field_get:speechService.VoiceVolumeInfo.vol)
  return vol_;
}
inline void VoiceVolumeInfo::set_vol(::google::protobuf::uint32 value) {
  
  vol_ = value;
  // @@protoc_insertion_point(field_set:speechService.VoiceVolumeInfo.vol)
}

// -------------------------------------------------------------------

// SetVoiceVolumeRequest

// .speechService.VoiceVolumeInfo voice_volume_info = 1;
inline bool SetVoiceVolumeRequest::has_voice_volume_info() const {
  return this != internal_default_instance() && voice_volume_info_ != nullptr;
}
inline void SetVoiceVolumeRequest::clear_voice_volume_info() {
  if (GetArenaNoVirtual() == nullptr && voice_volume_info_ != nullptr) {
    delete voice_volume_info_;
  }
  voice_volume_info_ = nullptr;
}
inline const ::speechService::VoiceVolumeInfo& SetVoiceVolumeRequest::voice_volume_info() const {
  const ::speechService::VoiceVolumeInfo* p = voice_volume_info_;
  // @@protoc_insertion_point(field_get:speechService.SetVoiceVolumeRequest.voice_volume_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::speechService::VoiceVolumeInfo*>(
      &::speechService::_VoiceVolumeInfo_default_instance_);
}
inline ::speechService::VoiceVolumeInfo* SetVoiceVolumeRequest::release_voice_volume_info() {
  // @@protoc_insertion_point(field_release:speechService.SetVoiceVolumeRequest.voice_volume_info)
  
  ::speechService::VoiceVolumeInfo* temp = voice_volume_info_;
  voice_volume_info_ = nullptr;
  return temp;
}
inline ::speechService::VoiceVolumeInfo* SetVoiceVolumeRequest::mutable_voice_volume_info() {
  
  if (voice_volume_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechService::VoiceVolumeInfo>(GetArenaNoVirtual());
    voice_volume_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:speechService.SetVoiceVolumeRequest.voice_volume_info)
  return voice_volume_info_;
}
inline void SetVoiceVolumeRequest::set_allocated_voice_volume_info(::speechService::VoiceVolumeInfo* voice_volume_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voice_volume_info_;
  }
  if (voice_volume_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voice_volume_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voice_volume_info, submessage_arena);
    }
    
  } else {
    
  }
  voice_volume_info_ = voice_volume_info;
  // @@protoc_insertion_point(field_set_allocated:speechService.SetVoiceVolumeRequest.voice_volume_info)
}

// -------------------------------------------------------------------

// SetVoiceVolumeResponse

// .speechService.VoiceVolumeInfo voice_volume_info = 1;
inline bool SetVoiceVolumeResponse::has_voice_volume_info() const {
  return this != internal_default_instance() && voice_volume_info_ != nullptr;
}
inline void SetVoiceVolumeResponse::clear_voice_volume_info() {
  if (GetArenaNoVirtual() == nullptr && voice_volume_info_ != nullptr) {
    delete voice_volume_info_;
  }
  voice_volume_info_ = nullptr;
}
inline const ::speechService::VoiceVolumeInfo& SetVoiceVolumeResponse::voice_volume_info() const {
  const ::speechService::VoiceVolumeInfo* p = voice_volume_info_;
  // @@protoc_insertion_point(field_get:speechService.SetVoiceVolumeResponse.voice_volume_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::speechService::VoiceVolumeInfo*>(
      &::speechService::_VoiceVolumeInfo_default_instance_);
}
inline ::speechService::VoiceVolumeInfo* SetVoiceVolumeResponse::release_voice_volume_info() {
  // @@protoc_insertion_point(field_release:speechService.SetVoiceVolumeResponse.voice_volume_info)
  
  ::speechService::VoiceVolumeInfo* temp = voice_volume_info_;
  voice_volume_info_ = nullptr;
  return temp;
}
inline ::speechService::VoiceVolumeInfo* SetVoiceVolumeResponse::mutable_voice_volume_info() {
  
  if (voice_volume_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechService::VoiceVolumeInfo>(GetArenaNoVirtual());
    voice_volume_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:speechService.SetVoiceVolumeResponse.voice_volume_info)
  return voice_volume_info_;
}
inline void SetVoiceVolumeResponse::set_allocated_voice_volume_info(::speechService::VoiceVolumeInfo* voice_volume_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voice_volume_info_;
  }
  if (voice_volume_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voice_volume_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voice_volume_info, submessage_arena);
    }
    
  } else {
    
  }
  voice_volume_info_ = voice_volume_info;
  // @@protoc_insertion_point(field_set_allocated:speechService.SetVoiceVolumeResponse.voice_volume_info)
}

// -------------------------------------------------------------------

// GetVoiceVolumeRequest

// -------------------------------------------------------------------

// GetVoiceVolumeResponse

// .speechService.VoiceVolumeInfo voice_volume_info = 1;
inline bool GetVoiceVolumeResponse::has_voice_volume_info() const {
  return this != internal_default_instance() && voice_volume_info_ != nullptr;
}
inline void GetVoiceVolumeResponse::clear_voice_volume_info() {
  if (GetArenaNoVirtual() == nullptr && voice_volume_info_ != nullptr) {
    delete voice_volume_info_;
  }
  voice_volume_info_ = nullptr;
}
inline const ::speechService::VoiceVolumeInfo& GetVoiceVolumeResponse::voice_volume_info() const {
  const ::speechService::VoiceVolumeInfo* p = voice_volume_info_;
  // @@protoc_insertion_point(field_get:speechService.GetVoiceVolumeResponse.voice_volume_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::speechService::VoiceVolumeInfo*>(
      &::speechService::_VoiceVolumeInfo_default_instance_);
}
inline ::speechService::VoiceVolumeInfo* GetVoiceVolumeResponse::release_voice_volume_info() {
  // @@protoc_insertion_point(field_release:speechService.GetVoiceVolumeResponse.voice_volume_info)
  
  ::speechService::VoiceVolumeInfo* temp = voice_volume_info_;
  voice_volume_info_ = nullptr;
  return temp;
}
inline ::speechService::VoiceVolumeInfo* GetVoiceVolumeResponse::mutable_voice_volume_info() {
  
  if (voice_volume_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::speechService::VoiceVolumeInfo>(GetArenaNoVirtual());
    voice_volume_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:speechService.GetVoiceVolumeResponse.voice_volume_info)
  return voice_volume_info_;
}
inline void GetVoiceVolumeResponse::set_allocated_voice_volume_info(::speechService::VoiceVolumeInfo* voice_volume_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete voice_volume_info_;
  }
  if (voice_volume_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      voice_volume_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, voice_volume_info, submessage_arena);
    }
    
  } else {
    
  }
  voice_volume_info_ = voice_volume_info;
  // @@protoc_insertion_point(field_set_allocated:speechService.GetVoiceVolumeResponse.voice_volume_info)
}

// -------------------------------------------------------------------

// SetParamsRequest

// bytes params = 1;
inline void SetParamsRequest::clear_params() {
  params_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetParamsRequest::params() const {
  // @@protoc_insertion_point(field_get:speechService.SetParamsRequest.params)
  return params_.GetNoArena();
}
inline void SetParamsRequest::set_params(const ::std::string& value) {
  
  params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:speechService.SetParamsRequest.params)
}
#if LANG_CXX11
inline void SetParamsRequest::set_params(::std::string&& value) {
  
  params_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speechService.SetParamsRequest.params)
}
#endif
inline void SetParamsRequest::set_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speechService.SetParamsRequest.params)
}
inline void SetParamsRequest::set_params(const void* value, size_t size) {
  
  params_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speechService.SetParamsRequest.params)
}
inline ::std::string* SetParamsRequest::mutable_params() {
  
  // @@protoc_insertion_point(field_mutable:speechService.SetParamsRequest.params)
  return params_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetParamsRequest::release_params() {
  // @@protoc_insertion_point(field_release:speechService.SetParamsRequest.params)
  
  return params_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetParamsRequest::set_allocated_params(::std::string* params) {
  if (params != nullptr) {
    
  } else {
    
  }
  params_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), params);
  // @@protoc_insertion_point(field_set_allocated:speechService.SetParamsRequest.params)
}

// -------------------------------------------------------------------

// SetParamsResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace speechService

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::speechService::SpeechEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechService::SpeechEvent>() {
  return ::speechService::SpeechEvent_descriptor();
}
template <> struct is_proto_enum< ::speechService::ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechService::ErrorType>() {
  return ::speechService::ErrorType_descriptor();
}
template <> struct is_proto_enum< ::speechService::VadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speechService::VadType>() {
  return ::speechService::VadType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_speech_2eproto
