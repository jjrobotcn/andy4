// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: speech.proto

package speechService

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SpeechEvent int32

const (
	SpeechEvent_UNKNOWN_EVENT SpeechEvent = 0
	SpeechEvent_WAKE_UP       SpeechEvent = 1
	SpeechEvent_HIBERNATE     SpeechEvent = 2
	SpeechEvent_ERROR         SpeechEvent = 3
	SpeechEvent_VAD           SpeechEvent = 4
	SpeechEvent_RESULT        SpeechEvent = 5
	SpeechEvent_TTS_START     SpeechEvent = 6
	SpeechEvent_TTS_END       SpeechEvent = 7
)

var SpeechEvent_name = map[int32]string{
	0: "UNKNOWN_EVENT",
	1: "WAKE_UP",
	2: "HIBERNATE",
	3: "ERROR",
	4: "VAD",
	5: "RESULT",
	6: "TTS_START",
	7: "TTS_END",
}

var SpeechEvent_value = map[string]int32{
	"UNKNOWN_EVENT": 0,
	"WAKE_UP":       1,
	"HIBERNATE":     2,
	"ERROR":         3,
	"VAD":           4,
	"RESULT":        5,
	"TTS_START":     6,
	"TTS_END":       7,
}

func (x SpeechEvent) String() string {
	return proto.EnumName(SpeechEvent_name, int32(x))
}

func (SpeechEvent) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{0}
}

// 错误类型
type ErrorType int32

const (
	ErrorType_UNKNOWN_ERROR_TYPE ErrorType = 0
	ErrorType_ERR_TIMEOUT        ErrorType = 1
	ErrorType_ERR_PARAMS         ErrorType = 2
	ErrorType_ERR_AUTH           ErrorType = 3
	ErrorType_ERR_NETWORK        ErrorType = 4
	ErrorType_ERR_NOT_READY      ErrorType = 5
	ErrorType_ERR_CONFIG         ErrorType = 6
)

var ErrorType_name = map[int32]string{
	0: "UNKNOWN_ERROR_TYPE",
	1: "ERR_TIMEOUT",
	2: "ERR_PARAMS",
	3: "ERR_AUTH",
	4: "ERR_NETWORK",
	5: "ERR_NOT_READY",
	6: "ERR_CONFIG",
}

var ErrorType_value = map[string]int32{
	"UNKNOWN_ERROR_TYPE": 0,
	"ERR_TIMEOUT":        1,
	"ERR_PARAMS":         2,
	"ERR_AUTH":           3,
	"ERR_NETWORK":        4,
	"ERR_NOT_READY":      5,
	"ERR_CONFIG":         6,
}

func (x ErrorType) String() string {
	return proto.EnumName(ErrorType_name, int32(x))
}

func (ErrorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{1}
}

// 语音检测
type VadType int32

const (
	VadType_UNKNOWM_VAD_TYPE VadType = 0
	VadType_START            VadType = 1
	VadType_END              VadType = 2
	VadType_TIMEOUT          VadType = 3
	VadType_VOLUME_CHANGE    VadType = 4
)

var VadType_name = map[int32]string{
	0: "UNKNOWM_VAD_TYPE",
	1: "START",
	2: "END",
	3: "TIMEOUT",
	4: "VOLUME_CHANGE",
}

var VadType_value = map[string]int32{
	"UNKNOWM_VAD_TYPE": 0,
	"START":            1,
	"END":              2,
	"TIMEOUT":          3,
	"VOLUME_CHANGE":    4,
}

func (x VadType) String() string {
	return proto.EnumName(VadType_name, int32(x))
}

func (VadType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{2}
}

type ErrorInfo struct {
	ErrorType            ErrorType `protobuf:"varint,1,opt,name=error_type,json=errorType,proto3,enum=speechService.ErrorType" json:"error_type,omitempty"`
	Info                 string    `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	Code                 string    `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ErrorInfo) Reset()         { *m = ErrorInfo{} }
func (m *ErrorInfo) String() string { return proto.CompactTextString(m) }
func (*ErrorInfo) ProtoMessage()    {}
func (*ErrorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{0}
}
func (m *ErrorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorInfo.Merge(m, src)
}
func (m *ErrorInfo) XXX_Size() int {
	return m.Size()
}
func (m *ErrorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorInfo proto.InternalMessageInfo

func (m *ErrorInfo) GetErrorType() ErrorType {
	if m != nil {
		return m.ErrorType
	}
	return ErrorType_UNKNOWN_ERROR_TYPE
}

func (m *ErrorInfo) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *ErrorInfo) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type VadInfo struct {
	VadType              VadType  `protobuf:"varint,1,opt,name=vad_type,json=vadType,proto3,enum=speechService.VadType" json:"vad_type,omitempty"`
	Vol                  uint32   `protobuf:"varint,2,opt,name=vol,proto3" json:"vol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VadInfo) Reset()         { *m = VadInfo{} }
func (m *VadInfo) String() string { return proto.CompactTextString(m) }
func (*VadInfo) ProtoMessage()    {}
func (*VadInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{1}
}
func (m *VadInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VadInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VadInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VadInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VadInfo.Merge(m, src)
}
func (m *VadInfo) XXX_Size() int {
	return m.Size()
}
func (m *VadInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VadInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VadInfo proto.InternalMessageInfo

func (m *VadInfo) GetVadType() VadType {
	if m != nil {
		return m.VadType
	}
	return VadType_UNKNOWM_VAD_TYPE
}

func (m *VadInfo) GetVol() uint32 {
	if m != nil {
		return m.Vol
	}
	return 0
}

// 唤醒相关数据
type WakeUpInfo struct {
	Angle                int32    `protobuf:"varint,1,opt,name=angle,proto3" json:"angle,omitempty"`
	Beam                 int32    `protobuf:"varint,2,opt,name=beam,proto3" json:"beam,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WakeUpInfo) Reset()         { *m = WakeUpInfo{} }
func (m *WakeUpInfo) String() string { return proto.CompactTextString(m) }
func (*WakeUpInfo) ProtoMessage()    {}
func (*WakeUpInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{2}
}
func (m *WakeUpInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WakeUpInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WakeUpInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WakeUpInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WakeUpInfo.Merge(m, src)
}
func (m *WakeUpInfo) XXX_Size() int {
	return m.Size()
}
func (m *WakeUpInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WakeUpInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WakeUpInfo proto.InternalMessageInfo

func (m *WakeUpInfo) GetAngle() int32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

func (m *WakeUpInfo) GetBeam() int32 {
	if m != nil {
		return m.Beam
	}
	return 0
}

// 识别结果
type ResultInfo struct {
	Words                []string `protobuf:"bytes,1,rep,name=words,proto3" json:"words,omitempty"`
	SentenceComplete     bool     `protobuf:"varint,2,opt,name=sentence_complete,json=sentenceComplete,proto3" json:"sentence_complete,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResultInfo) Reset()         { *m = ResultInfo{} }
func (m *ResultInfo) String() string { return proto.CompactTextString(m) }
func (*ResultInfo) ProtoMessage()    {}
func (*ResultInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{3}
}
func (m *ResultInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResultInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResultInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResultInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultInfo.Merge(m, src)
}
func (m *ResultInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResultInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResultInfo proto.InternalMessageInfo

func (m *ResultInfo) GetWords() []string {
	if m != nil {
		return m.Words
	}
	return nil
}

func (m *ResultInfo) GetSentenceComplete() bool {
	if m != nil {
		return m.SentenceComplete
	}
	return false
}

type ListenSpeechEventRequest struct {
	// 是否获取vad状态传入语音音量动态变化
	// 启用与否不影响获取Vad_START, Vad_END
	// 仅影响Vad_VOLUME_CHANGE
	WithVadVol           bool     `protobuf:"varint,1,opt,name=with_vad_vol,json=withVadVol,proto3" json:"with_vad_vol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListenSpeechEventRequest) Reset()         { *m = ListenSpeechEventRequest{} }
func (m *ListenSpeechEventRequest) String() string { return proto.CompactTextString(m) }
func (*ListenSpeechEventRequest) ProtoMessage()    {}
func (*ListenSpeechEventRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{4}
}
func (m *ListenSpeechEventRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListenSpeechEventRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListenSpeechEventRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListenSpeechEventRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenSpeechEventRequest.Merge(m, src)
}
func (m *ListenSpeechEventRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListenSpeechEventRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenSpeechEventRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListenSpeechEventRequest proto.InternalMessageInfo

func (m *ListenSpeechEventRequest) GetWithVadVol() bool {
	if m != nil {
		return m.WithVadVol
	}
	return false
}

type ListenSpeechEventResponse struct {
	EventType SpeechEvent `protobuf:"varint,1,opt,name=event_type,json=eventType,proto3,enum=speechService.SpeechEvent" json:"event_type,omitempty"`
	// Types that are valid to be assigned to SpeechEventOneof:
	//	*ListenSpeechEventResponse_WakeUpInfo
	//	*ListenSpeechEventResponse_VadInfo
	//	*ListenSpeechEventResponse_ResultInfo
	//	*ListenSpeechEventResponse_ErrorInfo
	SpeechEventOneof     isListenSpeechEventResponse_SpeechEventOneof `protobuf_oneof:"speech_event_oneof"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *ListenSpeechEventResponse) Reset()         { *m = ListenSpeechEventResponse{} }
func (m *ListenSpeechEventResponse) String() string { return proto.CompactTextString(m) }
func (*ListenSpeechEventResponse) ProtoMessage()    {}
func (*ListenSpeechEventResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{5}
}
func (m *ListenSpeechEventResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListenSpeechEventResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListenSpeechEventResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListenSpeechEventResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListenSpeechEventResponse.Merge(m, src)
}
func (m *ListenSpeechEventResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListenSpeechEventResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListenSpeechEventResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListenSpeechEventResponse proto.InternalMessageInfo

type isListenSpeechEventResponse_SpeechEventOneof interface {
	isListenSpeechEventResponse_SpeechEventOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListenSpeechEventResponse_WakeUpInfo struct {
	WakeUpInfo *WakeUpInfo `protobuf:"bytes,2,opt,name=wake_up_info,json=wakeUpInfo,proto3,oneof"`
}
type ListenSpeechEventResponse_VadInfo struct {
	VadInfo *VadInfo `protobuf:"bytes,3,opt,name=vad_info,json=vadInfo,proto3,oneof"`
}
type ListenSpeechEventResponse_ResultInfo struct {
	ResultInfo *ResultInfo `protobuf:"bytes,4,opt,name=result_info,json=resultInfo,proto3,oneof"`
}
type ListenSpeechEventResponse_ErrorInfo struct {
	ErrorInfo *ErrorInfo `protobuf:"bytes,5,opt,name=error_info,json=errorInfo,proto3,oneof"`
}

func (*ListenSpeechEventResponse_WakeUpInfo) isListenSpeechEventResponse_SpeechEventOneof() {}
func (*ListenSpeechEventResponse_VadInfo) isListenSpeechEventResponse_SpeechEventOneof()    {}
func (*ListenSpeechEventResponse_ResultInfo) isListenSpeechEventResponse_SpeechEventOneof() {}
func (*ListenSpeechEventResponse_ErrorInfo) isListenSpeechEventResponse_SpeechEventOneof()  {}

func (m *ListenSpeechEventResponse) GetSpeechEventOneof() isListenSpeechEventResponse_SpeechEventOneof {
	if m != nil {
		return m.SpeechEventOneof
	}
	return nil
}

func (m *ListenSpeechEventResponse) GetEventType() SpeechEvent {
	if m != nil {
		return m.EventType
	}
	return SpeechEvent_UNKNOWN_EVENT
}

func (m *ListenSpeechEventResponse) GetWakeUpInfo() *WakeUpInfo {
	if x, ok := m.GetSpeechEventOneof().(*ListenSpeechEventResponse_WakeUpInfo); ok {
		return x.WakeUpInfo
	}
	return nil
}

func (m *ListenSpeechEventResponse) GetVadInfo() *VadInfo {
	if x, ok := m.GetSpeechEventOneof().(*ListenSpeechEventResponse_VadInfo); ok {
		return x.VadInfo
	}
	return nil
}

func (m *ListenSpeechEventResponse) GetResultInfo() *ResultInfo {
	if x, ok := m.GetSpeechEventOneof().(*ListenSpeechEventResponse_ResultInfo); ok {
		return x.ResultInfo
	}
	return nil
}

func (m *ListenSpeechEventResponse) GetErrorInfo() *ErrorInfo {
	if x, ok := m.GetSpeechEventOneof().(*ListenSpeechEventResponse_ErrorInfo); ok {
		return x.ErrorInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListenSpeechEventResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListenSpeechEventResponse_OneofMarshaler, _ListenSpeechEventResponse_OneofUnmarshaler, _ListenSpeechEventResponse_OneofSizer, []interface{}{
		(*ListenSpeechEventResponse_WakeUpInfo)(nil),
		(*ListenSpeechEventResponse_VadInfo)(nil),
		(*ListenSpeechEventResponse_ResultInfo)(nil),
		(*ListenSpeechEventResponse_ErrorInfo)(nil),
	}
}

func _ListenSpeechEventResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListenSpeechEventResponse)
	// speech_event_oneof
	switch x := m.SpeechEventOneof.(type) {
	case *ListenSpeechEventResponse_WakeUpInfo:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WakeUpInfo); err != nil {
			return err
		}
	case *ListenSpeechEventResponse_VadInfo:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VadInfo); err != nil {
			return err
		}
	case *ListenSpeechEventResponse_ResultInfo:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResultInfo); err != nil {
			return err
		}
	case *ListenSpeechEventResponse_ErrorInfo:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErrorInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ListenSpeechEventResponse.SpeechEventOneof has unexpected type %T", x)
	}
	return nil
}

func _ListenSpeechEventResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListenSpeechEventResponse)
	switch tag {
	case 2: // speech_event_oneof.wake_up_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WakeUpInfo)
		err := b.DecodeMessage(msg)
		m.SpeechEventOneof = &ListenSpeechEventResponse_WakeUpInfo{msg}
		return true, err
	case 3: // speech_event_oneof.vad_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(VadInfo)
		err := b.DecodeMessage(msg)
		m.SpeechEventOneof = &ListenSpeechEventResponse_VadInfo{msg}
		return true, err
	case 4: // speech_event_oneof.result_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResultInfo)
		err := b.DecodeMessage(msg)
		m.SpeechEventOneof = &ListenSpeechEventResponse_ResultInfo{msg}
		return true, err
	case 5: // speech_event_oneof.error_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ErrorInfo)
		err := b.DecodeMessage(msg)
		m.SpeechEventOneof = &ListenSpeechEventResponse_ErrorInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ListenSpeechEventResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListenSpeechEventResponse)
	// speech_event_oneof
	switch x := m.SpeechEventOneof.(type) {
	case *ListenSpeechEventResponse_WakeUpInfo:
		s := proto.Size(x.WakeUpInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ListenSpeechEventResponse_VadInfo:
		s := proto.Size(x.VadInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ListenSpeechEventResponse_ResultInfo:
		s := proto.Size(x.ResultInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ListenSpeechEventResponse_ErrorInfo:
		s := proto.Size(x.ErrorInfo)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TextToSpeechRequest struct {
	Text                 string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TextToSpeechRequest) Reset()         { *m = TextToSpeechRequest{} }
func (m *TextToSpeechRequest) String() string { return proto.CompactTextString(m) }
func (*TextToSpeechRequest) ProtoMessage()    {}
func (*TextToSpeechRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{6}
}
func (m *TextToSpeechRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextToSpeechRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextToSpeechRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextToSpeechRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextToSpeechRequest.Merge(m, src)
}
func (m *TextToSpeechRequest) XXX_Size() int {
	return m.Size()
}
func (m *TextToSpeechRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TextToSpeechRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TextToSpeechRequest proto.InternalMessageInfo

func (m *TextToSpeechRequest) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type TextToSpeechResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TextToSpeechResponse) Reset()         { *m = TextToSpeechResponse{} }
func (m *TextToSpeechResponse) String() string { return proto.CompactTextString(m) }
func (*TextToSpeechResponse) ProtoMessage()    {}
func (*TextToSpeechResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{7}
}
func (m *TextToSpeechResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextToSpeechResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextToSpeechResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextToSpeechResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextToSpeechResponse.Merge(m, src)
}
func (m *TextToSpeechResponse) XXX_Size() int {
	return m.Size()
}
func (m *TextToSpeechResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TextToSpeechResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TextToSpeechResponse proto.InternalMessageInfo

type SpeechStopRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpeechStopRequest) Reset()         { *m = SpeechStopRequest{} }
func (m *SpeechStopRequest) String() string { return proto.CompactTextString(m) }
func (*SpeechStopRequest) ProtoMessage()    {}
func (*SpeechStopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{8}
}
func (m *SpeechStopRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpeechStopRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpeechStopRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpeechStopRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpeechStopRequest.Merge(m, src)
}
func (m *SpeechStopRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpeechStopRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpeechStopRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpeechStopRequest proto.InternalMessageInfo

type SpeechStopResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SpeechStopResponse) Reset()         { *m = SpeechStopResponse{} }
func (m *SpeechStopResponse) String() string { return proto.CompactTextString(m) }
func (*SpeechStopResponse) ProtoMessage()    {}
func (*SpeechStopResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{9}
}
func (m *SpeechStopResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpeechStopResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpeechStopResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpeechStopResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpeechStopResponse.Merge(m, src)
}
func (m *SpeechStopResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpeechStopResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpeechStopResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpeechStopResponse proto.InternalMessageInfo

type WakeUpRequest struct {
	AfterWakeUpSpeechText string   `protobuf:"bytes,1,opt,name=after_wake_up_speech_text,json=afterWakeUpSpeechText,proto3" json:"after_wake_up_speech_text,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *WakeUpRequest) Reset()         { *m = WakeUpRequest{} }
func (m *WakeUpRequest) String() string { return proto.CompactTextString(m) }
func (*WakeUpRequest) ProtoMessage()    {}
func (*WakeUpRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{10}
}
func (m *WakeUpRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WakeUpRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WakeUpRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WakeUpRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WakeUpRequest.Merge(m, src)
}
func (m *WakeUpRequest) XXX_Size() int {
	return m.Size()
}
func (m *WakeUpRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WakeUpRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WakeUpRequest proto.InternalMessageInfo

func (m *WakeUpRequest) GetAfterWakeUpSpeechText() string {
	if m != nil {
		return m.AfterWakeUpSpeechText
	}
	return ""
}

type WakeUpResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WakeUpResponse) Reset()         { *m = WakeUpResponse{} }
func (m *WakeUpResponse) String() string { return proto.CompactTextString(m) }
func (*WakeUpResponse) ProtoMessage()    {}
func (*WakeUpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{11}
}
func (m *WakeUpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WakeUpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WakeUpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WakeUpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WakeUpResponse.Merge(m, src)
}
func (m *WakeUpResponse) XXX_Size() int {
	return m.Size()
}
func (m *WakeUpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WakeUpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WakeUpResponse proto.InternalMessageInfo

type HibernateRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HibernateRequest) Reset()         { *m = HibernateRequest{} }
func (m *HibernateRequest) String() string { return proto.CompactTextString(m) }
func (*HibernateRequest) ProtoMessage()    {}
func (*HibernateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{12}
}
func (m *HibernateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HibernateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HibernateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HibernateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HibernateRequest.Merge(m, src)
}
func (m *HibernateRequest) XXX_Size() int {
	return m.Size()
}
func (m *HibernateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HibernateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HibernateRequest proto.InternalMessageInfo

type HibernateResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HibernateResponse) Reset()         { *m = HibernateResponse{} }
func (m *HibernateResponse) String() string { return proto.CompactTextString(m) }
func (*HibernateResponse) ProtoMessage()    {}
func (*HibernateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{13}
}
func (m *HibernateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HibernateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HibernateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HibernateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HibernateResponse.Merge(m, src)
}
func (m *HibernateResponse) XXX_Size() int {
	return m.Size()
}
func (m *HibernateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HibernateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HibernateResponse proto.InternalMessageInfo

// 音量信息
type VoiceVolumeInfo struct {
	// 音量值 0-10
	// aiui模块硬件限制值: 2-10
	Vol                  uint32   `protobuf:"varint,1,opt,name=vol,proto3" json:"vol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VoiceVolumeInfo) Reset()         { *m = VoiceVolumeInfo{} }
func (m *VoiceVolumeInfo) String() string { return proto.CompactTextString(m) }
func (*VoiceVolumeInfo) ProtoMessage()    {}
func (*VoiceVolumeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{14}
}
func (m *VoiceVolumeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoiceVolumeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoiceVolumeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoiceVolumeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoiceVolumeInfo.Merge(m, src)
}
func (m *VoiceVolumeInfo) XXX_Size() int {
	return m.Size()
}
func (m *VoiceVolumeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_VoiceVolumeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_VoiceVolumeInfo proto.InternalMessageInfo

func (m *VoiceVolumeInfo) GetVol() uint32 {
	if m != nil {
		return m.Vol
	}
	return 0
}

type SetVoiceVolumeRequest struct {
	VoiceVolumeInfo      *VoiceVolumeInfo `protobuf:"bytes,1,opt,name=voice_volume_info,json=voiceVolumeInfo,proto3" json:"voice_volume_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SetVoiceVolumeRequest) Reset()         { *m = SetVoiceVolumeRequest{} }
func (m *SetVoiceVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*SetVoiceVolumeRequest) ProtoMessage()    {}
func (*SetVoiceVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{15}
}
func (m *SetVoiceVolumeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVoiceVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVoiceVolumeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVoiceVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVoiceVolumeRequest.Merge(m, src)
}
func (m *SetVoiceVolumeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetVoiceVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVoiceVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetVoiceVolumeRequest proto.InternalMessageInfo

func (m *SetVoiceVolumeRequest) GetVoiceVolumeInfo() *VoiceVolumeInfo {
	if m != nil {
		return m.VoiceVolumeInfo
	}
	return nil
}

type SetVoiceVolumeResponse struct {
	VoiceVolumeInfo      *VoiceVolumeInfo `protobuf:"bytes,1,opt,name=voice_volume_info,json=voiceVolumeInfo,proto3" json:"voice_volume_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SetVoiceVolumeResponse) Reset()         { *m = SetVoiceVolumeResponse{} }
func (m *SetVoiceVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*SetVoiceVolumeResponse) ProtoMessage()    {}
func (*SetVoiceVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{16}
}
func (m *SetVoiceVolumeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVoiceVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVoiceVolumeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVoiceVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVoiceVolumeResponse.Merge(m, src)
}
func (m *SetVoiceVolumeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetVoiceVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVoiceVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetVoiceVolumeResponse proto.InternalMessageInfo

func (m *SetVoiceVolumeResponse) GetVoiceVolumeInfo() *VoiceVolumeInfo {
	if m != nil {
		return m.VoiceVolumeInfo
	}
	return nil
}

type GetVoiceVolumeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVoiceVolumeRequest) Reset()         { *m = GetVoiceVolumeRequest{} }
func (m *GetVoiceVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*GetVoiceVolumeRequest) ProtoMessage()    {}
func (*GetVoiceVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{17}
}
func (m *GetVoiceVolumeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVoiceVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVoiceVolumeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVoiceVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVoiceVolumeRequest.Merge(m, src)
}
func (m *GetVoiceVolumeRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetVoiceVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVoiceVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetVoiceVolumeRequest proto.InternalMessageInfo

type GetVoiceVolumeResponse struct {
	VoiceVolumeInfo      *VoiceVolumeInfo `protobuf:"bytes,1,opt,name=voice_volume_info,json=voiceVolumeInfo,proto3" json:"voice_volume_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetVoiceVolumeResponse) Reset()         { *m = GetVoiceVolumeResponse{} }
func (m *GetVoiceVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*GetVoiceVolumeResponse) ProtoMessage()    {}
func (*GetVoiceVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{18}
}
func (m *GetVoiceVolumeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVoiceVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVoiceVolumeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVoiceVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVoiceVolumeResponse.Merge(m, src)
}
func (m *GetVoiceVolumeResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetVoiceVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVoiceVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetVoiceVolumeResponse proto.InternalMessageInfo

func (m *GetVoiceVolumeResponse) GetVoiceVolumeInfo() *VoiceVolumeInfo {
	if m != nil {
		return m.VoiceVolumeInfo
	}
	return nil
}

type SetParamsRequest struct {
	Params               []byte   `protobuf:"bytes,1,opt,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetParamsRequest) Reset()         { *m = SetParamsRequest{} }
func (m *SetParamsRequest) String() string { return proto.CompactTextString(m) }
func (*SetParamsRequest) ProtoMessage()    {}
func (*SetParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{19}
}
func (m *SetParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetParamsRequest.Merge(m, src)
}
func (m *SetParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetParamsRequest proto.InternalMessageInfo

func (m *SetParamsRequest) GetParams() []byte {
	if m != nil {
		return m.Params
	}
	return nil
}

type SetParamsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetParamsResponse) Reset()         { *m = SetParamsResponse{} }
func (m *SetParamsResponse) String() string { return proto.CompactTextString(m) }
func (*SetParamsResponse) ProtoMessage()    {}
func (*SetParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_93c8715332746f2c, []int{20}
}
func (m *SetParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetParamsResponse.Merge(m, src)
}
func (m *SetParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetParamsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("speechService.SpeechEvent", SpeechEvent_name, SpeechEvent_value)
	proto.RegisterEnum("speechService.ErrorType", ErrorType_name, ErrorType_value)
	proto.RegisterEnum("speechService.VadType", VadType_name, VadType_value)
	proto.RegisterType((*ErrorInfo)(nil), "speechService.ErrorInfo")
	proto.RegisterType((*VadInfo)(nil), "speechService.VadInfo")
	proto.RegisterType((*WakeUpInfo)(nil), "speechService.WakeUpInfo")
	proto.RegisterType((*ResultInfo)(nil), "speechService.ResultInfo")
	proto.RegisterType((*ListenSpeechEventRequest)(nil), "speechService.ListenSpeechEventRequest")
	proto.RegisterType((*ListenSpeechEventResponse)(nil), "speechService.ListenSpeechEventResponse")
	proto.RegisterType((*TextToSpeechRequest)(nil), "speechService.TextToSpeechRequest")
	proto.RegisterType((*TextToSpeechResponse)(nil), "speechService.TextToSpeechResponse")
	proto.RegisterType((*SpeechStopRequest)(nil), "speechService.SpeechStopRequest")
	proto.RegisterType((*SpeechStopResponse)(nil), "speechService.SpeechStopResponse")
	proto.RegisterType((*WakeUpRequest)(nil), "speechService.WakeUpRequest")
	proto.RegisterType((*WakeUpResponse)(nil), "speechService.WakeUpResponse")
	proto.RegisterType((*HibernateRequest)(nil), "speechService.HibernateRequest")
	proto.RegisterType((*HibernateResponse)(nil), "speechService.HibernateResponse")
	proto.RegisterType((*VoiceVolumeInfo)(nil), "speechService.VoiceVolumeInfo")
	proto.RegisterType((*SetVoiceVolumeRequest)(nil), "speechService.SetVoiceVolumeRequest")
	proto.RegisterType((*SetVoiceVolumeResponse)(nil), "speechService.SetVoiceVolumeResponse")
	proto.RegisterType((*GetVoiceVolumeRequest)(nil), "speechService.GetVoiceVolumeRequest")
	proto.RegisterType((*GetVoiceVolumeResponse)(nil), "speechService.GetVoiceVolumeResponse")
	proto.RegisterType((*SetParamsRequest)(nil), "speechService.SetParamsRequest")
	proto.RegisterType((*SetParamsResponse)(nil), "speechService.SetParamsResponse")
}

func init() { proto.RegisterFile("speech.proto", fileDescriptor_93c8715332746f2c) }

var fileDescriptor_93c8715332746f2c = []byte{
	// 1139 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x4f, 0xe3, 0x46,
	0x14, 0xc6, 0xf9, 0x49, 0x1e, 0x09, 0x38, 0x03, 0xa4, 0x21, 0x65, 0xd9, 0x30, 0x4b, 0xb5, 0x34,
	0x95, 0xa0, 0x65, 0xa5, 0xb6, 0xbb, 0xda, 0x1e, 0x02, 0xb8, 0x81, 0x02, 0x09, 0x9a, 0x38, 0x41,
	0x7b, 0xb2, 0x4c, 0x32, 0x40, 0xba, 0xc1, 0x76, 0x93, 0x49, 0x60, 0x8f, 0xed, 0x61, 0xa5, 0x9e,
	0xfb, 0x4f, 0xf5, 0x58, 0xa9, 0xa7, 0x1e, 0x2a, 0x55, 0xa8, 0x7f, 0x48, 0x35, 0x3f, 0x4c, 0x8c,
	0x31, 0x6c, 0x0f, 0xed, 0x6d, 0xe6, 0xe5, 0x7b, 0xef, 0xfb, 0xe6, 0xbd, 0xf1, 0x37, 0x81, 0xec,
	0xd0, 0xa3, 0xb4, 0x73, 0xb1, 0xe1, 0x0d, 0x5c, 0xe6, 0xa2, 0x9c, 0xdc, 0x35, 0xe9, 0x60, 0xdc,
	0xeb, 0xd0, 0xd2, 0xf2, 0xb9, 0xeb, 0x9e, 0xf7, 0xe9, 0xa6, 0xed, 0xf5, 0x36, 0x6d, 0xc7, 0x71,
	0x99, 0xcd, 0x7a, 0xae, 0x33, 0x94, 0x60, 0xdc, 0x87, 0x8c, 0x31, 0x18, 0xb8, 0x83, 0x7d, 0xe7,
	0xcc, 0x45, 0x5f, 0x01, 0x50, 0xbe, 0xb1, 0xd8, 0x3b, 0x8f, 0x16, 0xb5, 0xb2, 0xb6, 0x3e, 0xbb,
	0x55, 0xdc, 0xb8, 0x53, 0x6e, 0x43, 0xa0, 0xcd, 0x77, 0x1e, 0x25, 0x19, 0xea, 0x2f, 0x11, 0x82,
	0x44, 0xcf, 0x39, 0x73, 0x8b, 0xb1, 0xb2, 0xb6, 0x9e, 0x21, 0x62, 0xcd, 0x63, 0x1d, 0xb7, 0x4b,
	0x8b, 0x71, 0x19, 0xe3, 0x6b, 0x5c, 0x87, 0x74, 0xdb, 0xee, 0x0a, 0xae, 0x2f, 0x60, 0x7a, 0x6c,
	0x77, 0x83, 0x4c, 0x85, 0x10, 0x53, 0xdb, 0xee, 0x0a, 0x9e, 0xf4, 0x58, 0x2e, 0x90, 0x0e, 0xf1,
	0xb1, 0xdb, 0x17, 0x24, 0x39, 0xc2, 0x97, 0xf8, 0x4b, 0x80, 0x13, 0xfb, 0x2d, 0x6d, 0x79, 0xa2,
	0xe4, 0x02, 0x24, 0x6d, 0xe7, 0xbc, 0x2f, 0xeb, 0x25, 0x89, 0xdc, 0x70, 0x1d, 0xa7, 0xd4, 0xbe,
	0x14, 0x69, 0x49, 0x22, 0xd6, 0xb8, 0x01, 0x40, 0xe8, 0x70, 0xd4, 0x67, 0x7e, 0xde, 0x95, 0x3b,
	0xe8, 0x0e, 0x8b, 0x5a, 0x39, 0xbe, 0x9e, 0x21, 0x72, 0x83, 0x3e, 0x83, 0xfc, 0x90, 0x3a, 0x8c,
	0x3a, 0x1d, 0x6a, 0x75, 0xdc, 0x4b, 0xaf, 0x4f, 0x19, 0x15, 0x45, 0xa6, 0x89, 0xee, 0xff, 0xb0,
	0xa3, 0xe2, 0xf8, 0x35, 0x14, 0x0f, 0x7b, 0x43, 0x46, 0x9d, 0xa6, 0x38, 0x82, 0x31, 0xa6, 0x0e,
	0x23, 0xf4, 0x87, 0x11, 0x1d, 0x32, 0x54, 0x86, 0xec, 0x55, 0x8f, 0x5d, 0x58, 0xfc, 0xb8, 0x5c,
	0xbf, 0x26, 0x6a, 0x00, 0x8f, 0xb5, 0xed, 0x6e, 0xdb, 0xed, 0xe3, 0x3f, 0x62, 0xb0, 0x14, 0x91,
	0x3e, 0xf4, 0x5c, 0x67, 0x48, 0xd1, 0x4b, 0x00, 0xca, 0x03, 0xc1, 0x5e, 0x95, 0x42, 0xbd, 0x0a,
	0xe6, 0x65, 0x04, 0x5a, 0x74, 0xec, 0x1b, 0xc8, 0x5e, 0xd9, 0x6f, 0xa9, 0x35, 0xf2, 0xac, 0xdb,
	0xf9, 0xcc, 0x6c, 0x2d, 0x85, 0x92, 0x27, 0x2d, 0xdc, 0x9b, 0x22, 0x70, 0x35, 0x69, 0xe8, 0x0b,
	0x39, 0x23, 0x91, 0x1a, 0x17, 0xa9, 0x11, 0x33, 0x52, 0x79, 0x7c, 0x4a, 0x22, 0xe9, 0x35, 0xcc,
	0x0c, 0x44, 0x6f, 0x65, 0x5e, 0x22, 0x92, 0x72, 0xd2, 0x7d, 0x4e, 0x39, 0x98, 0xcc, 0xe2, 0xa5,
	0x7f, 0x05, 0x45, 0x72, 0x52, 0x24, 0x47, 0x5e, 0x41, 0x95, 0x2b, 0x2f, 0x21, 0xdf, 0x6c, 0x2f,
	0x00, 0x92, 0x38, 0x4b, 0xb6, 0xcb, 0x75, 0xa8, 0x7b, 0x86, 0x3f, 0x85, 0x79, 0x93, 0x5e, 0x33,
	0xd3, 0x95, 0x2d, 0xf2, 0x87, 0x82, 0x20, 0xc1, 0xe8, 0x35, 0x13, 0xed, 0xcc, 0x10, 0xb1, 0xc6,
	0x05, 0x58, 0xb8, 0x0b, 0x95, 0x03, 0xc0, 0xf3, 0x90, 0x97, 0x91, 0x26, 0x73, 0x3d, 0x55, 0x00,
	0x2f, 0x00, 0x0a, 0x06, 0x15, 0x74, 0x1f, 0x72, 0xb2, 0x9b, 0x3e, 0xcf, 0xd7, 0xb0, 0x64, 0x9f,
	0x31, 0x3a, 0xb0, 0xfc, 0x39, 0x28, 0x89, 0x01, 0xf2, 0x45, 0x01, 0x90, 0x69, 0xb2, 0x24, 0x57,
	0x81, 0x75, 0x98, 0xf5, 0x4b, 0xa9, 0xe2, 0x08, 0xf4, 0xbd, 0xde, 0x29, 0x1d, 0x38, 0x36, 0xa3,
	0xbe, 0x8c, 0x79, 0xc8, 0x07, 0x62, 0x0a, 0xf8, 0x0c, 0xe6, 0xda, 0x6e, 0xaf, 0x43, 0xdb, 0x6e,
	0x7f, 0x74, 0x49, 0x45, 0x5f, 0xd5, 0xb7, 0xa3, 0x4d, 0xbe, 0x9d, 0x0e, 0x2c, 0x36, 0x29, 0x0b,
	0xe0, 0x7c, 0xc9, 0xdf, 0x41, 0x7e, 0xcc, 0xa3, 0xfc, 0xb2, 0x8e, 0x2e, 0xa9, 0x9c, 0x84, 0x26,
	0x26, 0xb1, 0x12, 0x1e, 0xff, 0x5d, 0x16, 0x32, 0x37, 0xbe, 0x1b, 0xc0, 0x5d, 0x28, 0x84, 0x49,
	0xd4, 0xad, 0xfe, 0x2f, 0x59, 0x3e, 0x82, 0xc5, 0x5a, 0xd4, 0x51, 0x38, 0x7d, 0xed, 0xff, 0xa7,
	0xaf, 0x80, 0xde, 0xa4, 0xec, 0xd8, 0x1e, 0xd8, 0x97, 0x43, 0xbf, 0x89, 0x05, 0x48, 0x79, 0x22,
	0x20, 0x8a, 0x66, 0x89, 0xda, 0x89, 0xbb, 0x34, 0xc1, 0x4a, 0x31, 0x95, 0x6b, 0x98, 0x09, 0x7c,
	0xc0, 0x28, 0x0f, 0xb9, 0x56, 0xfd, 0xa0, 0xde, 0x38, 0xa9, 0x5b, 0x46, 0xdb, 0xa8, 0x9b, 0xfa,
	0x14, 0x9a, 0x81, 0xf4, 0x49, 0xf5, 0xc0, 0xb0, 0x5a, 0xc7, 0xba, 0x86, 0x72, 0x90, 0xd9, 0xdb,
	0xdf, 0x36, 0x48, 0xbd, 0x6a, 0x1a, 0x7a, 0x0c, 0x65, 0x20, 0x69, 0x10, 0xd2, 0x20, 0x7a, 0x1c,
	0xa5, 0x21, 0xde, 0xae, 0xee, 0xea, 0x09, 0x04, 0x90, 0x22, 0x46, 0xb3, 0x75, 0x68, 0xea, 0x49,
	0x0e, 0x37, 0xcd, 0xa6, 0xd5, 0x34, 0xab, 0xc4, 0xd4, 0x53, 0xbc, 0x14, 0xdf, 0x1a, 0xf5, 0x5d,
	0x3d, 0x5d, 0x79, 0xaf, 0x29, 0xff, 0x17, 0x76, 0x51, 0x00, 0x74, 0x4b, 0xcc, 0x2b, 0x5a, 0xe6,
	0x9b, 0x63, 0x43, 0x9f, 0x42, 0x73, 0x30, 0x63, 0x10, 0x62, 0x99, 0xfb, 0x47, 0x46, 0xa3, 0x65,
	0xea, 0x1a, 0x9a, 0x05, 0xe0, 0x81, 0xe3, 0x2a, 0xa9, 0x1e, 0x35, 0xf5, 0x18, 0xca, 0xc2, 0x34,
	0xdf, 0x57, 0x5b, 0xe6, 0x9e, 0x1e, 0xf7, 0xe1, 0x75, 0xc3, 0x3c, 0x69, 0x90, 0x03, 0x3d, 0xc1,
	0x0f, 0x24, 0x02, 0x0d, 0xd3, 0x22, 0x46, 0x75, 0xf7, 0x8d, 0x9e, 0xf4, 0x2b, 0xec, 0x34, 0xea,
	0xdf, 0xee, 0xd7, 0xf4, 0x54, 0xa5, 0x29, 0x5e, 0x06, 0xa1, 0x62, 0x01, 0x74, 0xa9, 0xe2, 0xc8,
	0x6a, 0x57, 0x77, 0x7d, 0x0d, 0x19, 0x48, 0xca, 0x13, 0x68, 0xfc, 0x94, 0x5c, 0x7d, 0x4c, 0x1c,
	0x45, 0x69, 0x8a, 0x73, 0x92, 0x76, 0xe3, 0xb0, 0x75, 0x64, 0x58, 0x3b, 0x7b, 0xd5, 0x7a, 0xcd,
	0xd0, 0x13, 0x5b, 0x7f, 0xa6, 0x21, 0xd7, 0x0c, 0xce, 0x12, 0x7d, 0x0f, 0xf9, 0x7b, 0x46, 0x8b,
	0x9e, 0x87, 0x06, 0xfe, 0x90, 0x93, 0x97, 0xd6, 0x3f, 0x0c, 0x54, 0x5f, 0xe0, 0xd4, 0xe7, 0x1a,
	0xfa, 0x51, 0x83, 0x6c, 0xd0, 0x4f, 0x10, 0x0e, 0xa5, 0x47, 0xf8, 0x52, 0xe9, 0xd9, 0xa3, 0x18,
	0x55, 0x7d, 0xfd, 0xa7, 0xdf, 0xff, 0xfe, 0x25, 0x86, 0xf1, 0x13, 0xf1, 0xa8, 0x8f, 0xb7, 0x36,
	0x65, 0xce, 0x26, 0x37, 0x15, 0x8b, 0xb9, 0xca, 0x63, 0x5e, 0x69, 0x15, 0x34, 0x02, 0x98, 0xb8,
	0x14, 0x2a, 0x47, 0xbe, 0x1a, 0x01, 0x57, 0x2b, 0xad, 0x3e, 0x82, 0x50, 0xe4, 0x58, 0x90, 0x2f,
	0xe3, 0x52, 0x88, 0x5c, 0x19, 0xdb, 0x90, 0x13, 0x5d, 0x40, 0x4a, 0x7a, 0x17, 0x5a, 0x8e, 0x7c,
	0x6b, 0x7c, 0xba, 0x27, 0x0f, 0xfc, 0xaa, 0xa8, 0x56, 0x05, 0xd5, 0xc7, 0xb8, 0x10, 0xa2, 0x52,
	0x5e, 0xca, 0x0f, 0xe8, 0x41, 0xe6, 0xd6, 0xff, 0xd0, 0xd3, 0x50, 0xb9, 0xb0, 0x5b, 0x96, 0xca,
	0x0f, 0x03, 0x14, 0x65, 0x59, 0x50, 0x96, 0x70, 0x31, 0x44, 0x79, 0x71, 0x4b, 0xf2, 0xb3, 0x06,
	0xb3, 0x77, 0x3d, 0x0d, 0xad, 0x85, 0xbb, 0x16, 0x65, 0x46, 0xa5, 0x4f, 0x3e, 0x80, 0x52, 0x0a,
	0x2a, 0x42, 0xc1, 0x1a, 0x7e, 0x1a, 0xee, 0x2f, 0x65, 0x56, 0xd0, 0xb2, 0xf8, 0xe9, 0xdf, 0x6b,
	0x30, 0x5b, 0x7b, 0x5c, 0x4b, 0xed, 0x5f, 0x69, 0x89, 0x76, 0x49, 0xfc, 0x5c, 0x68, 0x59, 0xbd,
	0xa7, 0xe5, 0x3c, 0xa4, 0x05, 0x31, 0xc8, 0xdc, 0xda, 0xda, 0xbd, 0x31, 0x84, 0xcd, 0xf1, 0xde,
	0x18, 0xee, 0x39, 0x22, 0x5e, 0x13, 0xc4, 0x2b, 0x78, 0x29, 0xa2, 0x09, 0xd2, 0x49, 0x5f, 0x69,
	0x95, 0xed, 0xec, 0xaf, 0x37, 0x2b, 0xda, 0x6f, 0x37, 0x2b, 0xda, 0x5f, 0x37, 0x2b, 0xda, 0x69,
	0x4a, 0xfc, 0xa3, 0x7d, 0xf1, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x87, 0xf9, 0x08, 0x68, 0x0e,
	0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SpeechServiceClient is the client API for SpeechService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SpeechServiceClient interface {
	// ListenSpeechEvent方法为监听语音事件变更状态流, 具体类型参考: SpeechEvent
	// ListenSpeechEventRequest中可配置相关状态消息过滤,
	ListenSpeechEvent(ctx context.Context, in *ListenSpeechEventRequest, opts ...grpc.CallOption) (SpeechService_ListenSpeechEventClient, error)
	// TextToSpeech(TTS)方法实现文本输入语音合成自动音频输出
	TextToSpeech(ctx context.Context, in *TextToSpeechRequest, opts ...grpc.CallOption) (*TextToSpeechResponse, error)
	// SpeechStop方法实现打断语音功能
	SpeechStop(ctx context.Context, in *SpeechStopRequest, opts ...grpc.CallOption) (*SpeechStopResponse, error)
	// 唤醒
	WakeUp(ctx context.Context, in *WakeUpRequest, opts ...grpc.CallOption) (*WakeUpResponse, error)
	// 休眠
	Hibernate(ctx context.Context, in *HibernateRequest, opts ...grpc.CallOption) (*HibernateResponse, error)
	// 设置语音音量
	// v2.1.0
	SetVoiceVolume(ctx context.Context, in *SetVoiceVolumeRequest, opts ...grpc.CallOption) (*SetVoiceVolumeResponse, error)
	// 查询语音音量
	// v2.1.0
	GetVoiceVolume(ctx context.Context, in *GetVoiceVolumeRequest, opts ...grpc.CallOption) (*GetVoiceVolumeResponse, error)
	// 配置参数(当前仅支持AIUI模块)
	// v2.1.0
	// AIUI模块参数配置参考: https://aiui.xfyun.cn/docs/access_docs (开发-评估板/量产板 => AIUI SDK => 参数配置)
	SetParams(ctx context.Context, in *SetParamsRequest, opts ...grpc.CallOption) (*SetParamsResponse, error)
}

type speechServiceClient struct {
	cc *grpc.ClientConn
}

func NewSpeechServiceClient(cc *grpc.ClientConn) SpeechServiceClient {
	return &speechServiceClient{cc}
}

func (c *speechServiceClient) ListenSpeechEvent(ctx context.Context, in *ListenSpeechEventRequest, opts ...grpc.CallOption) (SpeechService_ListenSpeechEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SpeechService_serviceDesc.Streams[0], "/speechService.SpeechService/ListenSpeechEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &speechServiceListenSpeechEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SpeechService_ListenSpeechEventClient interface {
	Recv() (*ListenSpeechEventResponse, error)
	grpc.ClientStream
}

type speechServiceListenSpeechEventClient struct {
	grpc.ClientStream
}

func (x *speechServiceListenSpeechEventClient) Recv() (*ListenSpeechEventResponse, error) {
	m := new(ListenSpeechEventResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *speechServiceClient) TextToSpeech(ctx context.Context, in *TextToSpeechRequest, opts ...grpc.CallOption) (*TextToSpeechResponse, error) {
	out := new(TextToSpeechResponse)
	err := c.cc.Invoke(ctx, "/speechService.SpeechService/TextToSpeech", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechServiceClient) SpeechStop(ctx context.Context, in *SpeechStopRequest, opts ...grpc.CallOption) (*SpeechStopResponse, error) {
	out := new(SpeechStopResponse)
	err := c.cc.Invoke(ctx, "/speechService.SpeechService/SpeechStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechServiceClient) WakeUp(ctx context.Context, in *WakeUpRequest, opts ...grpc.CallOption) (*WakeUpResponse, error) {
	out := new(WakeUpResponse)
	err := c.cc.Invoke(ctx, "/speechService.SpeechService/WakeUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechServiceClient) Hibernate(ctx context.Context, in *HibernateRequest, opts ...grpc.CallOption) (*HibernateResponse, error) {
	out := new(HibernateResponse)
	err := c.cc.Invoke(ctx, "/speechService.SpeechService/Hibernate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechServiceClient) SetVoiceVolume(ctx context.Context, in *SetVoiceVolumeRequest, opts ...grpc.CallOption) (*SetVoiceVolumeResponse, error) {
	out := new(SetVoiceVolumeResponse)
	err := c.cc.Invoke(ctx, "/speechService.SpeechService/SetVoiceVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechServiceClient) GetVoiceVolume(ctx context.Context, in *GetVoiceVolumeRequest, opts ...grpc.CallOption) (*GetVoiceVolumeResponse, error) {
	out := new(GetVoiceVolumeResponse)
	err := c.cc.Invoke(ctx, "/speechService.SpeechService/GetVoiceVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *speechServiceClient) SetParams(ctx context.Context, in *SetParamsRequest, opts ...grpc.CallOption) (*SetParamsResponse, error) {
	out := new(SetParamsResponse)
	err := c.cc.Invoke(ctx, "/speechService.SpeechService/SetParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SpeechServiceServer is the server API for SpeechService service.
type SpeechServiceServer interface {
	// ListenSpeechEvent方法为监听语音事件变更状态流, 具体类型参考: SpeechEvent
	// ListenSpeechEventRequest中可配置相关状态消息过滤,
	ListenSpeechEvent(*ListenSpeechEventRequest, SpeechService_ListenSpeechEventServer) error
	// TextToSpeech(TTS)方法实现文本输入语音合成自动音频输出
	TextToSpeech(context.Context, *TextToSpeechRequest) (*TextToSpeechResponse, error)
	// SpeechStop方法实现打断语音功能
	SpeechStop(context.Context, *SpeechStopRequest) (*SpeechStopResponse, error)
	// 唤醒
	WakeUp(context.Context, *WakeUpRequest) (*WakeUpResponse, error)
	// 休眠
	Hibernate(context.Context, *HibernateRequest) (*HibernateResponse, error)
	// 设置语音音量
	// v2.1.0
	SetVoiceVolume(context.Context, *SetVoiceVolumeRequest) (*SetVoiceVolumeResponse, error)
	// 查询语音音量
	// v2.1.0
	GetVoiceVolume(context.Context, *GetVoiceVolumeRequest) (*GetVoiceVolumeResponse, error)
	// 配置参数(当前仅支持AIUI模块)
	// v2.1.0
	// AIUI模块参数配置参考: https://aiui.xfyun.cn/docs/access_docs (开发-评估板/量产板 => AIUI SDK => 参数配置)
	SetParams(context.Context, *SetParamsRequest) (*SetParamsResponse, error)
}

// UnimplementedSpeechServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSpeechServiceServer struct {
}

func (*UnimplementedSpeechServiceServer) ListenSpeechEvent(req *ListenSpeechEventRequest, srv SpeechService_ListenSpeechEventServer) error {
	return status.Errorf(codes.Unimplemented, "method ListenSpeechEvent not implemented")
}
func (*UnimplementedSpeechServiceServer) TextToSpeech(ctx context.Context, req *TextToSpeechRequest) (*TextToSpeechResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TextToSpeech not implemented")
}
func (*UnimplementedSpeechServiceServer) SpeechStop(ctx context.Context, req *SpeechStopRequest) (*SpeechStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SpeechStop not implemented")
}
func (*UnimplementedSpeechServiceServer) WakeUp(ctx context.Context, req *WakeUpRequest) (*WakeUpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WakeUp not implemented")
}
func (*UnimplementedSpeechServiceServer) Hibernate(ctx context.Context, req *HibernateRequest) (*HibernateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hibernate not implemented")
}
func (*UnimplementedSpeechServiceServer) SetVoiceVolume(ctx context.Context, req *SetVoiceVolumeRequest) (*SetVoiceVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVoiceVolume not implemented")
}
func (*UnimplementedSpeechServiceServer) GetVoiceVolume(ctx context.Context, req *GetVoiceVolumeRequest) (*GetVoiceVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVoiceVolume not implemented")
}
func (*UnimplementedSpeechServiceServer) SetParams(ctx context.Context, req *SetParamsRequest) (*SetParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetParams not implemented")
}

func RegisterSpeechServiceServer(s *grpc.Server, srv SpeechServiceServer) {
	s.RegisterService(&_SpeechService_serviceDesc, srv)
}

func _SpeechService_ListenSpeechEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenSpeechEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SpeechServiceServer).ListenSpeechEvent(m, &speechServiceListenSpeechEventServer{stream})
}

type SpeechService_ListenSpeechEventServer interface {
	Send(*ListenSpeechEventResponse) error
	grpc.ServerStream
}

type speechServiceListenSpeechEventServer struct {
	grpc.ServerStream
}

func (x *speechServiceListenSpeechEventServer) Send(m *ListenSpeechEventResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SpeechService_TextToSpeech_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextToSpeechRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServiceServer).TextToSpeech(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/speechService.SpeechService/TextToSpeech",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServiceServer).TextToSpeech(ctx, req.(*TextToSpeechRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpeechService_SpeechStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpeechStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServiceServer).SpeechStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/speechService.SpeechService/SpeechStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServiceServer).SpeechStop(ctx, req.(*SpeechStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpeechService_WakeUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WakeUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServiceServer).WakeUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/speechService.SpeechService/WakeUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServiceServer).WakeUp(ctx, req.(*WakeUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpeechService_Hibernate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HibernateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServiceServer).Hibernate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/speechService.SpeechService/Hibernate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServiceServer).Hibernate(ctx, req.(*HibernateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpeechService_SetVoiceVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVoiceVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServiceServer).SetVoiceVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/speechService.SpeechService/SetVoiceVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServiceServer).SetVoiceVolume(ctx, req.(*SetVoiceVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpeechService_GetVoiceVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVoiceVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServiceServer).GetVoiceVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/speechService.SpeechService/GetVoiceVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServiceServer).GetVoiceVolume(ctx, req.(*GetVoiceVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SpeechService_SetParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpeechServiceServer).SetParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/speechService.SpeechService/SetParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpeechServiceServer).SetParams(ctx, req.(*SetParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SpeechService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "speechService.SpeechService",
	HandlerType: (*SpeechServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TextToSpeech",
			Handler:    _SpeechService_TextToSpeech_Handler,
		},
		{
			MethodName: "SpeechStop",
			Handler:    _SpeechService_SpeechStop_Handler,
		},
		{
			MethodName: "WakeUp",
			Handler:    _SpeechService_WakeUp_Handler,
		},
		{
			MethodName: "Hibernate",
			Handler:    _SpeechService_Hibernate_Handler,
		},
		{
			MethodName: "SetVoiceVolume",
			Handler:    _SpeechService_SetVoiceVolume_Handler,
		},
		{
			MethodName: "GetVoiceVolume",
			Handler:    _SpeechService_GetVoiceVolume_Handler,
		},
		{
			MethodName: "SetParams",
			Handler:    _SpeechService_SetParams_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenSpeechEvent",
			Handler:       _SpeechService_ListenSpeechEvent_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "speech.proto",
}

func (m *ErrorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.ErrorType))
	}
	if len(m.Info) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Info)))
		i += copy(dAtA[i:], m.Info)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VadInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VadInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VadType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.VadType))
	}
	if m.Vol != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.Vol))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WakeUpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WakeUpInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Angle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.Angle))
	}
	if m.Beam != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.Beam))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResultInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResultInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Words) > 0 {
		for _, s := range m.Words {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.SentenceComplete {
		dAtA[i] = 0x10
		i++
		if m.SentenceComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListenSpeechEventRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListenSpeechEventRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WithVadVol {
		dAtA[i] = 0x8
		i++
		if m.WithVadVol {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListenSpeechEventResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListenSpeechEventResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.EventType))
	}
	if m.SpeechEventOneof != nil {
		nn1, err1 := m.SpeechEventOneof.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += nn1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListenSpeechEventResponse_WakeUpInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WakeUpInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.WakeUpInfo.Size()))
		n2, err2 := m.WakeUpInfo.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}
func (m *ListenSpeechEventResponse_VadInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VadInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.VadInfo.Size()))
		n3, err3 := m.VadInfo.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}
func (m *ListenSpeechEventResponse_ResultInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ResultInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.ResultInfo.Size()))
		n4, err4 := m.ResultInfo.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}
func (m *ListenSpeechEventResponse_ErrorInfo) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ErrorInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.ErrorInfo.Size()))
		n5, err5 := m.ErrorInfo.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}
func (m *TextToSpeechRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextToSpeechRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TextToSpeechResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextToSpeechResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SpeechStopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpeechStopRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SpeechStopResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpeechStopResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WakeUpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WakeUpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AfterWakeUpSpeechText) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.AfterWakeUpSpeechText)))
		i += copy(dAtA[i:], m.AfterWakeUpSpeechText)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WakeUpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WakeUpResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HibernateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HibernateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HibernateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HibernateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VoiceVolumeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoiceVolumeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Vol != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.Vol))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetVoiceVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVoiceVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VoiceVolumeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.VoiceVolumeInfo.Size()))
		n6, err6 := m.VoiceVolumeInfo.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetVoiceVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVoiceVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VoiceVolumeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.VoiceVolumeInfo.Size()))
		n7, err7 := m.VoiceVolumeInfo.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetVoiceVolumeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVoiceVolumeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetVoiceVolumeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVoiceVolumeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VoiceVolumeInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(m.VoiceVolumeInfo.Size()))
		n8, err8 := m.VoiceVolumeInfo.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSpeech(dAtA, i, uint64(len(m.Params)))
		i += copy(dAtA[i:], m.Params)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSpeech(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ErrorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorType != 0 {
		n += 1 + sovSpeech(uint64(m.ErrorType))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VadInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VadType != 0 {
		n += 1 + sovSpeech(uint64(m.VadType))
	}
	if m.Vol != 0 {
		n += 1 + sovSpeech(uint64(m.Vol))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WakeUpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Angle != 0 {
		n += 1 + sovSpeech(uint64(m.Angle))
	}
	if m.Beam != 0 {
		n += 1 + sovSpeech(uint64(m.Beam))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResultInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Words) > 0 {
		for _, s := range m.Words {
			l = len(s)
			n += 1 + l + sovSpeech(uint64(l))
		}
	}
	if m.SentenceComplete {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListenSpeechEventRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WithVadVol {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListenSpeechEventResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovSpeech(uint64(m.EventType))
	}
	if m.SpeechEventOneof != nil {
		n += m.SpeechEventOneof.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListenSpeechEventResponse_WakeUpInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WakeUpInfo != nil {
		l = m.WakeUpInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	return n
}
func (m *ListenSpeechEventResponse_VadInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VadInfo != nil {
		l = m.VadInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	return n
}
func (m *ListenSpeechEventResponse_ResultInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResultInfo != nil {
		l = m.ResultInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	return n
}
func (m *ListenSpeechEventResponse_ErrorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorInfo != nil {
		l = m.ErrorInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	return n
}
func (m *TextToSpeechRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TextToSpeechResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpeechStopRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpeechStopResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WakeUpRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AfterWakeUpSpeechText)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WakeUpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HibernateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HibernateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoiceVolumeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vol != 0 {
		n += 1 + sovSpeech(uint64(m.Vol))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVoiceVolumeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoiceVolumeInfo != nil {
		l = m.VoiceVolumeInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetVoiceVolumeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoiceVolumeInfo != nil {
		l = m.VoiceVolumeInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVoiceVolumeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVoiceVolumeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoiceVolumeInfo != nil {
		l = m.VoiceVolumeInfo.Size()
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovSpeech(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSpeech(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpeech(x uint64) (n int) {
	return sovSpeech(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ErrorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorType", wireType)
			}
			m.ErrorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorType |= ErrorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VadInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VadInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VadInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VadType", wireType)
			}
			m.VadType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VadType |= VadType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vol", wireType)
			}
			m.Vol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WakeUpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WakeUpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WakeUpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			m.Angle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Angle |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beam", wireType)
			}
			m.Beam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Beam |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResultInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResultInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResultInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Words", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Words = append(m.Words, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentenceComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SentenceComplete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListenSpeechEventRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListenSpeechEventRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListenSpeechEventRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithVadVol", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithVadVol = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListenSpeechEventResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListenSpeechEventResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListenSpeechEventResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= SpeechEvent(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WakeUpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WakeUpInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpeechEventOneof = &ListenSpeechEventResponse_WakeUpInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VadInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VadInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpeechEventOneof = &ListenSpeechEventResponse_VadInfo{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResultInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpeechEventOneof = &ListenSpeechEventResponse_ResultInfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ErrorInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SpeechEventOneof = &ListenSpeechEventResponse_ErrorInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextToSpeechRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextToSpeechRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextToSpeechRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextToSpeechResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextToSpeechResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextToSpeechResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpeechStopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpeechStopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpeechStopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpeechStopResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpeechStopResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpeechStopResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WakeUpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WakeUpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WakeUpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterWakeUpSpeechText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterWakeUpSpeechText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WakeUpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WakeUpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WakeUpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HibernateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HibernateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HibernateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HibernateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HibernateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HibernateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoiceVolumeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoiceVolumeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoiceVolumeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vol", wireType)
			}
			m.Vol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vol |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVoiceVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVoiceVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVoiceVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoiceVolumeInfo == nil {
				m.VoiceVolumeInfo = &VoiceVolumeInfo{}
			}
			if err := m.VoiceVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVoiceVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVoiceVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVoiceVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoiceVolumeInfo == nil {
				m.VoiceVolumeInfo = &VoiceVolumeInfo{}
			}
			if err := m.VoiceVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVoiceVolumeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVoiceVolumeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVoiceVolumeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVoiceVolumeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVoiceVolumeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVoiceVolumeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoiceVolumeInfo == nil {
				m.VoiceVolumeInfo = &VoiceVolumeInfo{}
			}
			if err := m.VoiceVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpeech
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpeech
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params[:0], dAtA[iNdEx:postIndex]...)
			if m.Params == nil {
				m.Params = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSpeech(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSpeech
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpeech(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpeech
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpeech
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpeech
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSpeech
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSpeech
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSpeech(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSpeech
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSpeech = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpeech   = fmt.Errorf("proto: integer overflow")
)
