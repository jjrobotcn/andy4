// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speech.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Speech.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - SpeechRoot

@implementation SpeechRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - SpeechRoot_FileDescriptor

static GPBFileDescriptor *SpeechRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"speechService"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SpeechEvent

GPBEnumDescriptor *SpeechEvent_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownEvent\000WakeUp\000Hibernate\000Error\000Vad\000"
        "Result\000TtsStart\000TtsEnd\000";
    static const int32_t values[] = {
        SpeechEvent_UnknownEvent,
        SpeechEvent_WakeUp,
        SpeechEvent_Hibernate,
        SpeechEvent_Error,
        SpeechEvent_Vad,
        SpeechEvent_Result,
        SpeechEvent_TtsStart,
        SpeechEvent_TtsEnd,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SpeechEvent)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SpeechEvent_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SpeechEvent_IsValidValue(int32_t value__) {
  switch (value__) {
    case SpeechEvent_UnknownEvent:
    case SpeechEvent_WakeUp:
    case SpeechEvent_Hibernate:
    case SpeechEvent_Error:
    case SpeechEvent_Vad:
    case SpeechEvent_Result:
    case SpeechEvent_TtsStart:
    case SpeechEvent_TtsEnd:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ErrorType

GPBEnumDescriptor *ErrorType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownErrorType\000ErrTimeout\000ErrParams\000Er"
        "rAuth\000ErrNetwork\000ErrNotReady\000ErrConfig\000";
    static const int32_t values[] = {
        ErrorType_UnknownErrorType,
        ErrorType_ErrTimeout,
        ErrorType_ErrParams,
        ErrorType_ErrAuth,
        ErrorType_ErrNetwork,
        ErrorType_ErrNotReady,
        ErrorType_ErrConfig,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ErrorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ErrorType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ErrorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ErrorType_UnknownErrorType:
    case ErrorType_ErrTimeout:
    case ErrorType_ErrParams:
    case ErrorType_ErrAuth:
    case ErrorType_ErrNetwork:
    case ErrorType_ErrNotReady:
    case ErrorType_ErrConfig:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum VadType

GPBEnumDescriptor *VadType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknowmVadType\000Start\000End\000Timeout\000VolumeC"
        "hange\000";
    static const int32_t values[] = {
        VadType_UnknowmVadType,
        VadType_Start,
        VadType_End,
        VadType_Timeout,
        VadType_VolumeChange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VadType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VadType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VadType_IsValidValue(int32_t value__) {
  switch (value__) {
    case VadType_UnknowmVadType:
    case VadType_Start:
    case VadType_End:
    case VadType_Timeout:
    case VadType_VolumeChange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ErrorInfo

@implementation ErrorInfo

@dynamic errorType;
@dynamic info;
@dynamic code;

typedef struct ErrorInfo__storage_ {
  uint32_t _has_storage_[1];
  ErrorType errorType;
  NSString *info;
  NSString *code;
} ErrorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorType",
        .dataTypeSpecific.enumDescFunc = ErrorType_EnumDescriptor,
        .number = ErrorInfo_FieldNumber_ErrorType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ErrorInfo__storage_, errorType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = NULL,
        .number = ErrorInfo_FieldNumber_Info,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ErrorInfo__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = ErrorInfo_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ErrorInfo__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ErrorInfo class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ErrorInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ErrorInfo_ErrorType_RawValue(ErrorInfo *message) {
  GPBDescriptor *descriptor = [ErrorInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ErrorInfo_FieldNumber_ErrorType];
  return GPBGetMessageInt32Field(message, field);
}

void SetErrorInfo_ErrorType_RawValue(ErrorInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [ErrorInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ErrorInfo_FieldNumber_ErrorType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - VadInfo

@implementation VadInfo

@dynamic vadType;
@dynamic vol;

typedef struct VadInfo__storage_ {
  uint32_t _has_storage_[1];
  VadType vadType;
  uint32_t vol;
} VadInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vadType",
        .dataTypeSpecific.enumDescFunc = VadType_EnumDescriptor,
        .number = VadInfo_FieldNumber_VadType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VadInfo__storage_, vadType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "vol",
        .dataTypeSpecific.className = NULL,
        .number = VadInfo_FieldNumber_Vol,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VadInfo__storage_, vol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VadInfo class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VadInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t VadInfo_VadType_RawValue(VadInfo *message) {
  GPBDescriptor *descriptor = [VadInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VadInfo_FieldNumber_VadType];
  return GPBGetMessageInt32Field(message, field);
}

void SetVadInfo_VadType_RawValue(VadInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [VadInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VadInfo_FieldNumber_VadType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - WakeUpInfo

@implementation WakeUpInfo

@dynamic angle;
@dynamic beam;

typedef struct WakeUpInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t angle;
  int32_t beam;
} WakeUpInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "angle",
        .dataTypeSpecific.className = NULL,
        .number = WakeUpInfo_FieldNumber_Angle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WakeUpInfo__storage_, angle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "beam",
        .dataTypeSpecific.className = NULL,
        .number = WakeUpInfo_FieldNumber_Beam,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WakeUpInfo__storage_, beam),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WakeUpInfo class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WakeUpInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResultInfo

@implementation ResultInfo

@dynamic wordsArray, wordsArray_Count;
@dynamic sentenceComplete;

typedef struct ResultInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *wordsArray;
} ResultInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wordsArray",
        .dataTypeSpecific.className = NULL,
        .number = ResultInfo_FieldNumber_WordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResultInfo__storage_, wordsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sentenceComplete",
        .dataTypeSpecific.className = NULL,
        .number = ResultInfo_FieldNumber_SentenceComplete,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResultInfo class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResultInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListenSpeechEventRequest

@implementation ListenSpeechEventRequest

@dynamic withVadVol;

typedef struct ListenSpeechEventRequest__storage_ {
  uint32_t _has_storage_[1];
} ListenSpeechEventRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "withVadVol",
        .dataTypeSpecific.className = NULL,
        .number = ListenSpeechEventRequest_FieldNumber_WithVadVol,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListenSpeechEventRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListenSpeechEventRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListenSpeechEventResponse

@implementation ListenSpeechEventResponse

@dynamic speechEventOneofOneOfCase;
@dynamic eventType;
@dynamic wakeUpInfo;
@dynamic vadInfo;
@dynamic resultInfo;
@dynamic errorInfo;

typedef struct ListenSpeechEventResponse__storage_ {
  uint32_t _has_storage_[2];
  SpeechEvent eventType;
  WakeUpInfo *wakeUpInfo;
  VadInfo *vadInfo;
  ResultInfo *resultInfo;
  ErrorInfo *errorInfo;
} ListenSpeechEventResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventType",
        .dataTypeSpecific.enumDescFunc = SpeechEvent_EnumDescriptor,
        .number = ListenSpeechEventResponse_FieldNumber_EventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListenSpeechEventResponse__storage_, eventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "wakeUpInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(WakeUpInfo),
        .number = ListenSpeechEventResponse_FieldNumber_WakeUpInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ListenSpeechEventResponse__storage_, wakeUpInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vadInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(VadInfo),
        .number = ListenSpeechEventResponse_FieldNumber_VadInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ListenSpeechEventResponse__storage_, vadInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resultInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ResultInfo),
        .number = ListenSpeechEventResponse_FieldNumber_ResultInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ListenSpeechEventResponse__storage_, resultInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ErrorInfo),
        .number = ListenSpeechEventResponse_FieldNumber_ErrorInfo,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ListenSpeechEventResponse__storage_, errorInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListenSpeechEventResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListenSpeechEventResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "speechEventOneof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ListenSpeechEventResponse_EventType_RawValue(ListenSpeechEventResponse *message) {
  GPBDescriptor *descriptor = [ListenSpeechEventResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ListenSpeechEventResponse_FieldNumber_EventType];
  return GPBGetMessageInt32Field(message, field);
}

void SetListenSpeechEventResponse_EventType_RawValue(ListenSpeechEventResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [ListenSpeechEventResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ListenSpeechEventResponse_FieldNumber_EventType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void ListenSpeechEventResponse_ClearSpeechEventOneofOneOfCase(ListenSpeechEventResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - TextToSpeechRequest

@implementation TextToSpeechRequest

@dynamic text;

typedef struct TextToSpeechRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *text;
} TextToSpeechRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = TextToSpeechRequest_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextToSpeechRequest__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextToSpeechRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextToSpeechRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextToSpeechResponse

@implementation TextToSpeechResponse


typedef struct TextToSpeechResponse__storage_ {
  uint32_t _has_storage_[1];
} TextToSpeechResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextToSpeechResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TextToSpeechResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpeechStopRequest

@implementation SpeechStopRequest


typedef struct SpeechStopRequest__storage_ {
  uint32_t _has_storage_[1];
} SpeechStopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpeechStopRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(SpeechStopRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpeechStopResponse

@implementation SpeechStopResponse


typedef struct SpeechStopResponse__storage_ {
  uint32_t _has_storage_[1];
} SpeechStopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpeechStopResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(SpeechStopResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WakeUpRequest

@implementation WakeUpRequest

@dynamic afterWakeUpSpeechText;

typedef struct WakeUpRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *afterWakeUpSpeechText;
} WakeUpRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "afterWakeUpSpeechText",
        .dataTypeSpecific.className = NULL,
        .number = WakeUpRequest_FieldNumber_AfterWakeUpSpeechText,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WakeUpRequest__storage_, afterWakeUpSpeechText),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WakeUpRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WakeUpRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WakeUpResponse

@implementation WakeUpResponse


typedef struct WakeUpResponse__storage_ {
  uint32_t _has_storage_[1];
} WakeUpResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WakeUpResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(WakeUpResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HibernateRequest

@implementation HibernateRequest


typedef struct HibernateRequest__storage_ {
  uint32_t _has_storage_[1];
} HibernateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HibernateRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(HibernateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HibernateResponse

@implementation HibernateResponse


typedef struct HibernateResponse__storage_ {
  uint32_t _has_storage_[1];
} HibernateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HibernateResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(HibernateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceVolumeInfo

@implementation VoiceVolumeInfo

@dynamic vol;

typedef struct VoiceVolumeInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t vol;
} VoiceVolumeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "vol",
        .dataTypeSpecific.className = NULL,
        .number = VoiceVolumeInfo_FieldNumber_Vol,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceVolumeInfo__storage_, vol),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceVolumeInfo class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceVolumeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetVoiceVolumeRequest

@implementation SetVoiceVolumeRequest

@dynamic hasVoiceVolumeInfo, voiceVolumeInfo;

typedef struct SetVoiceVolumeRequest__storage_ {
  uint32_t _has_storage_[1];
  VoiceVolumeInfo *voiceVolumeInfo;
} SetVoiceVolumeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceVolumeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(VoiceVolumeInfo),
        .number = SetVoiceVolumeRequest_FieldNumber_VoiceVolumeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetVoiceVolumeRequest__storage_, voiceVolumeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetVoiceVolumeRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetVoiceVolumeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetVoiceVolumeResponse

@implementation SetVoiceVolumeResponse

@dynamic hasVoiceVolumeInfo, voiceVolumeInfo;

typedef struct SetVoiceVolumeResponse__storage_ {
  uint32_t _has_storage_[1];
  VoiceVolumeInfo *voiceVolumeInfo;
} SetVoiceVolumeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceVolumeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(VoiceVolumeInfo),
        .number = SetVoiceVolumeResponse_FieldNumber_VoiceVolumeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetVoiceVolumeResponse__storage_, voiceVolumeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetVoiceVolumeResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetVoiceVolumeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVoiceVolumeRequest

@implementation GetVoiceVolumeRequest


typedef struct GetVoiceVolumeRequest__storage_ {
  uint32_t _has_storage_[1];
} GetVoiceVolumeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVoiceVolumeRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetVoiceVolumeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetVoiceVolumeResponse

@implementation GetVoiceVolumeResponse

@dynamic hasVoiceVolumeInfo, voiceVolumeInfo;

typedef struct GetVoiceVolumeResponse__storage_ {
  uint32_t _has_storage_[1];
  VoiceVolumeInfo *voiceVolumeInfo;
} GetVoiceVolumeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voiceVolumeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(VoiceVolumeInfo),
        .number = GetVoiceVolumeResponse_FieldNumber_VoiceVolumeInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetVoiceVolumeResponse__storage_, voiceVolumeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetVoiceVolumeResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetVoiceVolumeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetParamsRequest

@implementation SetParamsRequest

@dynamic params;

typedef struct SetParamsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *params;
} SetParamsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "params",
        .dataTypeSpecific.className = NULL,
        .number = SetParamsRequest_FieldNumber_Params,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetParamsRequest__storage_, params),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetParamsRequest class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetParamsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetParamsResponse

@implementation SetParamsResponse


typedef struct SetParamsResponse__storage_ {
  uint32_t _has_storage_[1];
} SetParamsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetParamsResponse class]
                                     rootClass:[SpeechRoot class]
                                          file:SpeechRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(SetParamsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
