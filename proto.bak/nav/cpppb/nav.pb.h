// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nav.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_nav_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_nav_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
#include "map.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_nav_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_nav_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[30]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_nav_2eproto;
namespace navService {
class AutoChargeEvent;
class AutoChargeEventDefaultTypeInternal;
extern AutoChargeEventDefaultTypeInternal _AutoChargeEvent_default_instance_;
class AutoChargeRequest;
class AutoChargeRequestDefaultTypeInternal;
extern AutoChargeRequestDefaultTypeInternal _AutoChargeRequest_default_instance_;
class AutoChargeResponse;
class AutoChargeResponseDefaultTypeInternal;
extern AutoChargeResponseDefaultTypeInternal _AutoChargeResponse_default_instance_;
class DeleteRoutesRequest;
class DeleteRoutesRequestDefaultTypeInternal;
extern DeleteRoutesRequestDefaultTypeInternal _DeleteRoutesRequest_default_instance_;
class DeleteRoutesResponse;
class DeleteRoutesResponseDefaultTypeInternal;
extern DeleteRoutesResponseDefaultTypeInternal _DeleteRoutesResponse_default_instance_;
class GetRouteRequest;
class GetRouteRequestDefaultTypeInternal;
extern GetRouteRequestDefaultTypeInternal _GetRouteRequest_default_instance_;
class GetRouteResponse;
class GetRouteResponseDefaultTypeInternal;
extern GetRouteResponseDefaultTypeInternal _GetRouteResponse_default_instance_;
class ListRoutesRequest;
class ListRoutesRequestDefaultTypeInternal;
extern ListRoutesRequestDefaultTypeInternal _ListRoutesRequest_default_instance_;
class ListRoutesResponse;
class ListRoutesResponseDefaultTypeInternal;
extern ListRoutesResponseDefaultTypeInternal _ListRoutesResponse_default_instance_;
class MoveEvent;
class MoveEventDefaultTypeInternal;
extern MoveEventDefaultTypeInternal _MoveEvent_default_instance_;
class MoveRequest;
class MoveRequestDefaultTypeInternal;
extern MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
class MoveResponse;
class MoveResponseDefaultTypeInternal;
extern MoveResponseDefaultTypeInternal _MoveResponse_default_instance_;
class NavEvent;
class NavEventDefaultTypeInternal;
extern NavEventDefaultTypeInternal _NavEvent_default_instance_;
class NavRoaming;
class NavRoamingDefaultTypeInternal;
extern NavRoamingDefaultTypeInternal _NavRoaming_default_instance_;
class NavStopRequest;
class NavStopRequestDefaultTypeInternal;
extern NavStopRequestDefaultTypeInternal _NavStopRequest_default_instance_;
class NavStopResponse;
class NavStopResponseDefaultTypeInternal;
extern NavStopResponseDefaultTypeInternal _NavStopResponse_default_instance_;
class NavTarget;
class NavTargetDefaultTypeInternal;
extern NavTargetDefaultTypeInternal _NavTarget_default_instance_;
class NavToRequest;
class NavToRequestDefaultTypeInternal;
extern NavToRequestDefaultTypeInternal _NavToRequest_default_instance_;
class NavToResponse;
class NavToResponseDefaultTypeInternal;
extern NavToResponseDefaultTypeInternal _NavToResponse_default_instance_;
class NewRouteRequest;
class NewRouteRequestDefaultTypeInternal;
extern NewRouteRequestDefaultTypeInternal _NewRouteRequest_default_instance_;
class NewRouteResponse;
class NewRouteResponseDefaultTypeInternal;
extern NewRouteResponseDefaultTypeInternal _NewRouteResponse_default_instance_;
class OnNavEventChangeRequest;
class OnNavEventChangeRequestDefaultTypeInternal;
extern OnNavEventChangeRequestDefaultTypeInternal _OnNavEventChangeRequest_default_instance_;
class OnNavEventChangeResponse;
class OnNavEventChangeResponseDefaultTypeInternal;
extern OnNavEventChangeResponseDefaultTypeInternal _OnNavEventChangeResponse_default_instance_;
class RotateEvent;
class RotateEventDefaultTypeInternal;
extern RotateEventDefaultTypeInternal _RotateEvent_default_instance_;
class RotateRequest;
class RotateRequestDefaultTypeInternal;
extern RotateRequestDefaultTypeInternal _RotateRequest_default_instance_;
class RotateResponse;
class RotateResponseDefaultTypeInternal;
extern RotateResponseDefaultTypeInternal _RotateResponse_default_instance_;
class Route;
class RouteDefaultTypeInternal;
extern RouteDefaultTypeInternal _Route_default_instance_;
class RoutePoint;
class RoutePointDefaultTypeInternal;
extern RoutePointDefaultTypeInternal _RoutePoint_default_instance_;
class UpdateRouteRequest;
class UpdateRouteRequestDefaultTypeInternal;
extern UpdateRouteRequestDefaultTypeInternal _UpdateRouteRequest_default_instance_;
class UpdateRouteResponse;
class UpdateRouteResponseDefaultTypeInternal;
extern UpdateRouteResponseDefaultTypeInternal _UpdateRouteResponse_default_instance_;
}  // namespace navService
PROTOBUF_NAMESPACE_OPEN
template<> ::navService::AutoChargeEvent* Arena::CreateMaybeMessage<::navService::AutoChargeEvent>(Arena*);
template<> ::navService::AutoChargeRequest* Arena::CreateMaybeMessage<::navService::AutoChargeRequest>(Arena*);
template<> ::navService::AutoChargeResponse* Arena::CreateMaybeMessage<::navService::AutoChargeResponse>(Arena*);
template<> ::navService::DeleteRoutesRequest* Arena::CreateMaybeMessage<::navService::DeleteRoutesRequest>(Arena*);
template<> ::navService::DeleteRoutesResponse* Arena::CreateMaybeMessage<::navService::DeleteRoutesResponse>(Arena*);
template<> ::navService::GetRouteRequest* Arena::CreateMaybeMessage<::navService::GetRouteRequest>(Arena*);
template<> ::navService::GetRouteResponse* Arena::CreateMaybeMessage<::navService::GetRouteResponse>(Arena*);
template<> ::navService::ListRoutesRequest* Arena::CreateMaybeMessage<::navService::ListRoutesRequest>(Arena*);
template<> ::navService::ListRoutesResponse* Arena::CreateMaybeMessage<::navService::ListRoutesResponse>(Arena*);
template<> ::navService::MoveEvent* Arena::CreateMaybeMessage<::navService::MoveEvent>(Arena*);
template<> ::navService::MoveRequest* Arena::CreateMaybeMessage<::navService::MoveRequest>(Arena*);
template<> ::navService::MoveResponse* Arena::CreateMaybeMessage<::navService::MoveResponse>(Arena*);
template<> ::navService::NavEvent* Arena::CreateMaybeMessage<::navService::NavEvent>(Arena*);
template<> ::navService::NavRoaming* Arena::CreateMaybeMessage<::navService::NavRoaming>(Arena*);
template<> ::navService::NavStopRequest* Arena::CreateMaybeMessage<::navService::NavStopRequest>(Arena*);
template<> ::navService::NavStopResponse* Arena::CreateMaybeMessage<::navService::NavStopResponse>(Arena*);
template<> ::navService::NavTarget* Arena::CreateMaybeMessage<::navService::NavTarget>(Arena*);
template<> ::navService::NavToRequest* Arena::CreateMaybeMessage<::navService::NavToRequest>(Arena*);
template<> ::navService::NavToResponse* Arena::CreateMaybeMessage<::navService::NavToResponse>(Arena*);
template<> ::navService::NewRouteRequest* Arena::CreateMaybeMessage<::navService::NewRouteRequest>(Arena*);
template<> ::navService::NewRouteResponse* Arena::CreateMaybeMessage<::navService::NewRouteResponse>(Arena*);
template<> ::navService::OnNavEventChangeRequest* Arena::CreateMaybeMessage<::navService::OnNavEventChangeRequest>(Arena*);
template<> ::navService::OnNavEventChangeResponse* Arena::CreateMaybeMessage<::navService::OnNavEventChangeResponse>(Arena*);
template<> ::navService::RotateEvent* Arena::CreateMaybeMessage<::navService::RotateEvent>(Arena*);
template<> ::navService::RotateRequest* Arena::CreateMaybeMessage<::navService::RotateRequest>(Arena*);
template<> ::navService::RotateResponse* Arena::CreateMaybeMessage<::navService::RotateResponse>(Arena*);
template<> ::navService::Route* Arena::CreateMaybeMessage<::navService::Route>(Arena*);
template<> ::navService::RoutePoint* Arena::CreateMaybeMessage<::navService::RoutePoint>(Arena*);
template<> ::navService::UpdateRouteRequest* Arena::CreateMaybeMessage<::navService::UpdateRouteRequest>(Arena*);
template<> ::navService::UpdateRouteResponse* Arena::CreateMaybeMessage<::navService::UpdateRouteResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace navService {

enum StatusCode : int {
  UNKNOWN = 0,
  STOPPED = 1,
  MOVING = 2,
  PREPARING = 3,
  CANCEL = 4,
  RELEASED = 5,
  ERR_OBSTACLE = 10,
  ERR_NOT_READY = 11,
  ERR_MOTOR_FAIL = 12,
  ERR_WRONG_TARGET = 13,
  REJ_MOVING = 20,
  REJ_NAVING = 21,
  REJ_CHARGING = 22,
  REJ_ROTATING = 23,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StatusCode_IsValid(int value);
constexpr StatusCode StatusCode_MIN = UNKNOWN;
constexpr StatusCode StatusCode_MAX = REJ_ROTATING;
constexpr int StatusCode_ARRAYSIZE = StatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusCode_descriptor();
template<typename T>
inline const std::string& StatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusCode_descriptor(), enum_t_value);
}
inline bool StatusCode_Parse(
    const std::string& name, StatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusCode>(
    StatusCode_descriptor(), name, value);
}
enum MoveDirection : int {
  RELEASE = 0,
  FORWARD = 1,
  BACKWARD = 2,
  LEFT = 3,
  RIGHT = 4,
  LEFT_FORWARD = 5,
  RIGHT_FORWARD = 6,
  LEFT_BACKWARD = 7,
  RIGHT_BACKWARD = 8,
  MoveDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MoveDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MoveDirection_IsValid(int value);
constexpr MoveDirection MoveDirection_MIN = RELEASE;
constexpr MoveDirection MoveDirection_MAX = RIGHT_BACKWARD;
constexpr int MoveDirection_ARRAYSIZE = MoveDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveDirection_descriptor();
template<typename T>
inline const std::string& MoveDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveDirection_descriptor(), enum_t_value);
}
inline bool MoveDirection_Parse(
    const std::string& name, MoveDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveDirection>(
    MoveDirection_descriptor(), name, value);
}
enum RoamingType : int {
  ROAMING_TYPE_CONTINUE = 0,
  ROAMING_TYPE_ORDER = 1,
  ROAMING_TYPE_RANDOM = 2,
  RoamingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoamingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoamingType_IsValid(int value);
constexpr RoamingType RoamingType_MIN = ROAMING_TYPE_CONTINUE;
constexpr RoamingType RoamingType_MAX = ROAMING_TYPE_RANDOM;
constexpr int RoamingType_ARRAYSIZE = RoamingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoamingType_descriptor();
template<typename T>
inline const std::string& RoamingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoamingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoamingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoamingType_descriptor(), enum_t_value);
}
inline bool RoamingType_Parse(
    const std::string& name, RoamingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoamingType>(
    RoamingType_descriptor(), name, value);
}
enum ChargeStatusCode : int {
  CHARGE_STATUS_UNKNOWN = 0,
  CHARGE_STATUS_PREPARING = 1,
  CHARGE_STATUS_RELEASED = 2,
  CHARGE_STATUS_CONNECTING = 3,
  CHARGE_STATUS_CHARGING = 4,
  CHARGE_STATUS_DISCONNECTING = 5,
  CHARGE_CONNECT_FAIL = 6,
  CHARGE_STATUS_NAV_OBSTACLE = 7,
  ChargeStatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChargeStatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChargeStatusCode_IsValid(int value);
constexpr ChargeStatusCode ChargeStatusCode_MIN = CHARGE_STATUS_UNKNOWN;
constexpr ChargeStatusCode ChargeStatusCode_MAX = CHARGE_STATUS_NAV_OBSTACLE;
constexpr int ChargeStatusCode_ARRAYSIZE = ChargeStatusCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChargeStatusCode_descriptor();
template<typename T>
inline const std::string& ChargeStatusCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChargeStatusCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChargeStatusCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChargeStatusCode_descriptor(), enum_t_value);
}
inline bool ChargeStatusCode_Parse(
    const std::string& name, ChargeStatusCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChargeStatusCode>(
    ChargeStatusCode_descriptor(), name, value);
}
enum NavEventType : int {
  NAV_EVENT_REVERSED = 0,
  MOVE_EVENT = 1,
  NAV_EVENT = 2,
  AUTO_CHARGE_EVENT = 3,
  ROTATE_EVENT = 4,
  NavEventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NavEventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NavEventType_IsValid(int value);
constexpr NavEventType NavEventType_MIN = NAV_EVENT_REVERSED;
constexpr NavEventType NavEventType_MAX = ROTATE_EVENT;
constexpr int NavEventType_ARRAYSIZE = NavEventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NavEventType_descriptor();
template<typename T>
inline const std::string& NavEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NavEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NavEventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NavEventType_descriptor(), enum_t_value);
}
inline bool NavEventType_Parse(
    const std::string& name, NavEventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NavEventType>(
    NavEventType_descriptor(), name, value);
}
// ===================================================================

class MoveRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.MoveRequest) */ {
 public:
  MoveRequest();
  virtual ~MoveRequest();

  MoveRequest(const MoveRequest& from);
  MoveRequest(MoveRequest&& from) noexcept
    : MoveRequest() {
    *this = ::std::move(from);
  }

  inline MoveRequest& operator=(const MoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveRequest& operator=(MoveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveRequest* internal_default_instance() {
    return reinterpret_cast<const MoveRequest*>(
               &_MoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MoveRequest* other);
  friend void swap(MoveRequest& a, MoveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveRequest* New() const final {
    return CreateMaybeMessage<MoveRequest>(nullptr);
  }

  MoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveRequest& from);
  void MergeFrom(const MoveRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.MoveRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mode = 4;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  const std::string& mode() const;
  void set_mode(const std::string& value);
  void set_mode(std::string&& value);
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  std::string* mutable_mode();
  std::string* release_mode();
  void set_allocated_mode(std::string* mode);

  // uint32 speed = 1;
  void clear_speed();
  static const int kSpeedFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::uint32 speed() const;
  void set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 rspeed = 2;
  void clear_rspeed();
  static const int kRspeedFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 rspeed() const;
  void set_rspeed(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .navService.MoveDirection direction = 3;
  void clear_direction();
  static const int kDirectionFieldNumber = 3;
  ::navService::MoveDirection direction() const;
  void set_direction(::navService::MoveDirection value);

  // @@protoc_insertion_point(class_scope:navService.MoveRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 speed_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rspeed_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class MoveResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.MoveResponse) */ {
 public:
  MoveResponse();
  virtual ~MoveResponse();

  MoveResponse(const MoveResponse& from);
  MoveResponse(MoveResponse&& from) noexcept
    : MoveResponse() {
    *this = ::std::move(from);
  }

  inline MoveResponse& operator=(const MoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveResponse& operator=(MoveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveResponse* internal_default_instance() {
    return reinterpret_cast<const MoveResponse*>(
               &_MoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MoveResponse* other);
  friend void swap(MoveResponse& a, MoveResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveResponse* New() const final {
    return CreateMaybeMessage<MoveResponse>(nullptr);
  }

  MoveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveResponse& from);
  void MergeFrom(const MoveResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.MoveResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.StatusCode status_code = 1;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::navService::StatusCode status_code() const;
  void set_status_code(::navService::StatusCode value);

  // @@protoc_insertion_point(class_scope:navService.MoveResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NavTarget :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NavTarget) */ {
 public:
  NavTarget();
  virtual ~NavTarget();

  NavTarget(const NavTarget& from);
  NavTarget(NavTarget&& from) noexcept
    : NavTarget() {
    *this = ::std::move(from);
  }

  inline NavTarget& operator=(const NavTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavTarget& operator=(NavTarget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavTarget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavTarget* internal_default_instance() {
    return reinterpret_cast<const NavTarget*>(
               &_NavTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NavTarget* other);
  friend void swap(NavTarget& a, NavTarget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavTarget* New() const final {
    return CreateMaybeMessage<NavTarget>(nullptr);
  }

  NavTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavTarget>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavTarget& from);
  void MergeFrom(const NavTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavTarget* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NavTarget";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  const std::string& index() const;
  void set_index(const std::string& value);
  void set_index(std::string&& value);
  void set_index(const char* value);
  void set_index(const char* value, size_t size);
  std::string* mutable_index();
  std::string* release_index();
  void set_allocated_index(std::string* index);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:navService.NavTarget)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NavRoaming :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NavRoaming) */ {
 public:
  NavRoaming();
  virtual ~NavRoaming();

  NavRoaming(const NavRoaming& from);
  NavRoaming(NavRoaming&& from) noexcept
    : NavRoaming() {
    *this = ::std::move(from);
  }

  inline NavRoaming& operator=(const NavRoaming& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavRoaming& operator=(NavRoaming&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavRoaming& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavRoaming* internal_default_instance() {
    return reinterpret_cast<const NavRoaming*>(
               &_NavRoaming_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NavRoaming* other);
  friend void swap(NavRoaming& a, NavRoaming& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavRoaming* New() const final {
    return CreateMaybeMessage<NavRoaming>(nullptr);
  }

  NavRoaming* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavRoaming>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavRoaming& from);
  void MergeFrom(const NavRoaming& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavRoaming* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NavRoaming";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string roaming_target_indexes = 3;
  int roaming_target_indexes_size() const;
  void clear_roaming_target_indexes();
  static const int kRoamingTargetIndexesFieldNumber = 3;
  const std::string& roaming_target_indexes(int index) const;
  std::string* mutable_roaming_target_indexes(int index);
  void set_roaming_target_indexes(int index, const std::string& value);
  void set_roaming_target_indexes(int index, std::string&& value);
  void set_roaming_target_indexes(int index, const char* value);
  void set_roaming_target_indexes(int index, const char* value, size_t size);
  std::string* add_roaming_target_indexes();
  void add_roaming_target_indexes(const std::string& value);
  void add_roaming_target_indexes(std::string&& value);
  void add_roaming_target_indexes(const char* value);
  void add_roaming_target_indexes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& roaming_target_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_roaming_target_indexes();

  // .navService.RoamingType nav_roaming_type = 1;
  void clear_nav_roaming_type();
  static const int kNavRoamingTypeFieldNumber = 1;
  ::navService::RoamingType nav_roaming_type() const;
  void set_nav_roaming_type(::navService::RoamingType value);

  // int32 wait_sec = 2;
  void clear_wait_sec();
  static const int kWaitSecFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 wait_sec() const;
  void set_wait_sec(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool order_loop = 4;
  void clear_order_loop();
  static const int kOrderLoopFieldNumber = 4;
  bool order_loop() const;
  void set_order_loop(bool value);

  // @@protoc_insertion_point(class_scope:navService.NavRoaming)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> roaming_target_indexes_;
  int nav_roaming_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 wait_sec_;
  bool order_loop_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NavToRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NavToRequest) */ {
 public:
  NavToRequest();
  virtual ~NavToRequest();

  NavToRequest(const NavToRequest& from);
  NavToRequest(NavToRequest&& from) noexcept
    : NavToRequest() {
    *this = ::std::move(from);
  }

  inline NavToRequest& operator=(const NavToRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavToRequest& operator=(NavToRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavToRequest& default_instance();

  enum TargetOneofCase {
    kTarget = 1,
    kRoaming = 3,
    kMapPosition = 5,
    TARGET_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavToRequest* internal_default_instance() {
    return reinterpret_cast<const NavToRequest*>(
               &_NavToRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(NavToRequest* other);
  friend void swap(NavToRequest& a, NavToRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavToRequest* New() const final {
    return CreateMaybeMessage<NavToRequest>(nullptr);
  }

  NavToRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavToRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavToRequest& from);
  void MergeFrom(const NavToRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavToRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NavToRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 speed = 2;
  void clear_speed();
  static const int kSpeedFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 speed() const;
  void set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool sync_mode = 4;
  void clear_sync_mode();
  static const int kSyncModeFieldNumber = 4;
  bool sync_mode() const;
  void set_sync_mode(bool value);

  // .navService.NavTarget target = 1;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::navService::NavTarget& target() const;
  ::navService::NavTarget* release_target();
  ::navService::NavTarget* mutable_target();
  void set_allocated_target(::navService::NavTarget* target);

  // .navService.NavRoaming roaming = 3;
  bool has_roaming() const;
  void clear_roaming();
  static const int kRoamingFieldNumber = 3;
  const ::navService::NavRoaming& roaming() const;
  ::navService::NavRoaming* release_roaming();
  ::navService::NavRoaming* mutable_roaming();
  void set_allocated_roaming(::navService::NavRoaming* roaming);

  // .navService.MapPosition map_position = 5;
  bool has_map_position() const;
  void clear_map_position();
  static const int kMapPositionFieldNumber = 5;
  const ::navService::MapPosition& map_position() const;
  ::navService::MapPosition* release_map_position();
  ::navService::MapPosition* mutable_map_position();
  void set_allocated_map_position(::navService::MapPosition* map_position);

  void clear_target_oneof();
  TargetOneofCase target_oneof_case() const;
  // @@protoc_insertion_point(class_scope:navService.NavToRequest)
 private:
  class HasBitSetters;
  void set_has_target();
  void set_has_roaming();
  void set_has_map_position();

  inline bool has_target_oneof() const;
  inline void clear_has_target_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 speed_;
  bool sync_mode_;
  union TargetOneofUnion {
    TargetOneofUnion() {}
    ::navService::NavTarget* target_;
    ::navService::NavRoaming* roaming_;
    ::navService::MapPosition* map_position_;
  } target_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NavToResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NavToResponse) */ {
 public:
  NavToResponse();
  virtual ~NavToResponse();

  NavToResponse(const NavToResponse& from);
  NavToResponse(NavToResponse&& from) noexcept
    : NavToResponse() {
    *this = ::std::move(from);
  }

  inline NavToResponse& operator=(const NavToResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavToResponse& operator=(NavToResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavToResponse& default_instance();

  enum TargetOneofCase {
    kTarget = 2,
    kIsRoaming = 3,
    kMapPosition = 4,
    TARGET_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavToResponse* internal_default_instance() {
    return reinterpret_cast<const NavToResponse*>(
               &_NavToResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NavToResponse* other);
  friend void swap(NavToResponse& a, NavToResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavToResponse* New() const final {
    return CreateMaybeMessage<NavToResponse>(nullptr);
  }

  NavToResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavToResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavToResponse& from);
  void MergeFrom(const NavToResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavToResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NavToResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.StatusCode status_code = 1;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::navService::StatusCode status_code() const;
  void set_status_code(::navService::StatusCode value);

  // .navService.NavTarget target = 2;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  const ::navService::NavTarget& target() const;
  ::navService::NavTarget* release_target();
  ::navService::NavTarget* mutable_target();
  void set_allocated_target(::navService::NavTarget* target);

  // bool is_roaming = 3;
  private:
  bool has_is_roaming() const;
  public:
  void clear_is_roaming();
  static const int kIsRoamingFieldNumber = 3;
  bool is_roaming() const;
  void set_is_roaming(bool value);

  // .navService.MapPosition map_position = 4;
  bool has_map_position() const;
  void clear_map_position();
  static const int kMapPositionFieldNumber = 4;
  const ::navService::MapPosition& map_position() const;
  ::navService::MapPosition* release_map_position();
  ::navService::MapPosition* mutable_map_position();
  void set_allocated_map_position(::navService::MapPosition* map_position);

  void clear_target_oneof();
  TargetOneofCase target_oneof_case() const;
  // @@protoc_insertion_point(class_scope:navService.NavToResponse)
 private:
  class HasBitSetters;
  void set_has_target();
  void set_has_is_roaming();
  void set_has_map_position();

  inline bool has_target_oneof() const;
  inline void clear_has_target_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int status_code_;
  union TargetOneofUnion {
    TargetOneofUnion() {}
    ::navService::NavTarget* target_;
    bool is_roaming_;
    ::navService::MapPosition* map_position_;
  } target_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NavStopRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NavStopRequest) */ {
 public:
  NavStopRequest();
  virtual ~NavStopRequest();

  NavStopRequest(const NavStopRequest& from);
  NavStopRequest(NavStopRequest&& from) noexcept
    : NavStopRequest() {
    *this = ::std::move(from);
  }

  inline NavStopRequest& operator=(const NavStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavStopRequest& operator=(NavStopRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavStopRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavStopRequest* internal_default_instance() {
    return reinterpret_cast<const NavStopRequest*>(
               &_NavStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NavStopRequest* other);
  friend void swap(NavStopRequest& a, NavStopRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavStopRequest* New() const final {
    return CreateMaybeMessage<NavStopRequest>(nullptr);
  }

  NavStopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavStopRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavStopRequest& from);
  void MergeFrom(const NavStopRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavStopRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NavStopRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:navService.NavStopRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NavStopResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NavStopResponse) */ {
 public:
  NavStopResponse();
  virtual ~NavStopResponse();

  NavStopResponse(const NavStopResponse& from);
  NavStopResponse(NavStopResponse&& from) noexcept
    : NavStopResponse() {
    *this = ::std::move(from);
  }

  inline NavStopResponse& operator=(const NavStopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavStopResponse& operator=(NavStopResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavStopResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavStopResponse* internal_default_instance() {
    return reinterpret_cast<const NavStopResponse*>(
               &_NavStopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NavStopResponse* other);
  friend void swap(NavStopResponse& a, NavStopResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavStopResponse* New() const final {
    return CreateMaybeMessage<NavStopResponse>(nullptr);
  }

  NavStopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavStopResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavStopResponse& from);
  void MergeFrom(const NavStopResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavStopResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NavStopResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.StatusCode status_code = 1;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::navService::StatusCode status_code() const;
  void set_status_code(::navService::StatusCode value);

  // @@protoc_insertion_point(class_scope:navService.NavStopResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class AutoChargeRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.AutoChargeRequest) */ {
 public:
  AutoChargeRequest();
  virtual ~AutoChargeRequest();

  AutoChargeRequest(const AutoChargeRequest& from);
  AutoChargeRequest(AutoChargeRequest&& from) noexcept
    : AutoChargeRequest() {
    *this = ::std::move(from);
  }

  inline AutoChargeRequest& operator=(const AutoChargeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoChargeRequest& operator=(AutoChargeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AutoChargeRequest& default_instance();

  enum ChargeOptionOneofCase {
    kCharge = 1,
    kCancel = 2,
    kChargePreset = 3,
    CHARGE_OPTION_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutoChargeRequest* internal_default_instance() {
    return reinterpret_cast<const AutoChargeRequest*>(
               &_AutoChargeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(AutoChargeRequest* other);
  friend void swap(AutoChargeRequest& a, AutoChargeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutoChargeRequest* New() const final {
    return CreateMaybeMessage<AutoChargeRequest>(nullptr);
  }

  AutoChargeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutoChargeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AutoChargeRequest& from);
  void MergeFrom(const AutoChargeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoChargeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.AutoChargeRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 timeout_sec = 4;
  void clear_timeout_sec();
  static const int kTimeoutSecFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::uint32 timeout_sec() const;
  void set_timeout_sec(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // bool charge = 1;
  private:
  bool has_charge() const;
  public:
  void clear_charge();
  static const int kChargeFieldNumber = 1;
  bool charge() const;
  void set_charge(bool value);

  // bool cancel = 2;
  private:
  bool has_cancel() const;
  public:
  void clear_cancel();
  static const int kCancelFieldNumber = 2;
  bool cancel() const;
  void set_cancel(bool value);

  // bool charge_preset = 3;
  private:
  bool has_charge_preset() const;
  public:
  void clear_charge_preset();
  static const int kChargePresetFieldNumber = 3;
  bool charge_preset() const;
  void set_charge_preset(bool value);

  void clear_charge_option_oneof();
  ChargeOptionOneofCase charge_option_oneof_case() const;
  // @@protoc_insertion_point(class_scope:navService.AutoChargeRequest)
 private:
  class HasBitSetters;
  void set_has_charge();
  void set_has_cancel();
  void set_has_charge_preset();

  inline bool has_charge_option_oneof() const;
  inline void clear_has_charge_option_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timeout_sec_;
  union ChargeOptionOneofUnion {
    ChargeOptionOneofUnion() {}
    bool charge_;
    bool cancel_;
    bool charge_preset_;
  } charge_option_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class AutoChargeResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.AutoChargeResponse) */ {
 public:
  AutoChargeResponse();
  virtual ~AutoChargeResponse();

  AutoChargeResponse(const AutoChargeResponse& from);
  AutoChargeResponse(AutoChargeResponse&& from) noexcept
    : AutoChargeResponse() {
    *this = ::std::move(from);
  }

  inline AutoChargeResponse& operator=(const AutoChargeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoChargeResponse& operator=(AutoChargeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AutoChargeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutoChargeResponse* internal_default_instance() {
    return reinterpret_cast<const AutoChargeResponse*>(
               &_AutoChargeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AutoChargeResponse* other);
  friend void swap(AutoChargeResponse& a, AutoChargeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutoChargeResponse* New() const final {
    return CreateMaybeMessage<AutoChargeResponse>(nullptr);
  }

  AutoChargeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutoChargeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AutoChargeResponse& from);
  void MergeFrom(const AutoChargeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoChargeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.AutoChargeResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.ChargeStatusCode charge_status_code = 1;
  void clear_charge_status_code();
  static const int kChargeStatusCodeFieldNumber = 1;
  ::navService::ChargeStatusCode charge_status_code() const;
  void set_charge_status_code(::navService::ChargeStatusCode value);

  // @@protoc_insertion_point(class_scope:navService.AutoChargeResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int charge_status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class RotateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.RotateRequest) */ {
 public:
  RotateRequest();
  virtual ~RotateRequest();

  RotateRequest(const RotateRequest& from);
  RotateRequest(RotateRequest&& from) noexcept
    : RotateRequest() {
    *this = ::std::move(from);
  }

  inline RotateRequest& operator=(const RotateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateRequest& operator=(RotateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RotateRequest& default_instance();

  enum RotateOneofCase {
    kAngle = 1,
    kRollback = 2,
    ROTATE_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotateRequest* internal_default_instance() {
    return reinterpret_cast<const RotateRequest*>(
               &_RotateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RotateRequest* other);
  friend void swap(RotateRequest& a, RotateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotateRequest* New() const final {
    return CreateMaybeMessage<RotateRequest>(nullptr);
  }

  RotateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RotateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RotateRequest& from);
  void MergeFrom(const RotateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.RotateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 angle = 1;
  private:
  bool has_angle() const;
  public:
  void clear_angle();
  static const int kAngleFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 angle() const;
  void set_angle(::PROTOBUF_NAMESPACE_ID::int32 value);

  // bool rollback = 2;
  private:
  bool has_rollback() const;
  public:
  void clear_rollback();
  static const int kRollbackFieldNumber = 2;
  bool rollback() const;
  void set_rollback(bool value);

  void clear_rotate_oneof();
  RotateOneofCase rotate_oneof_case() const;
  // @@protoc_insertion_point(class_scope:navService.RotateRequest)
 private:
  class HasBitSetters;
  void set_has_angle();
  void set_has_rollback();

  inline bool has_rotate_oneof() const;
  inline void clear_has_rotate_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union RotateOneofUnion {
    RotateOneofUnion() {}
    ::PROTOBUF_NAMESPACE_ID::int32 angle_;
    bool rollback_;
  } rotate_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class RotateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.RotateResponse) */ {
 public:
  RotateResponse();
  virtual ~RotateResponse();

  RotateResponse(const RotateResponse& from);
  RotateResponse(RotateResponse&& from) noexcept
    : RotateResponse() {
    *this = ::std::move(from);
  }

  inline RotateResponse& operator=(const RotateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateResponse& operator=(RotateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RotateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotateResponse* internal_default_instance() {
    return reinterpret_cast<const RotateResponse*>(
               &_RotateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RotateResponse* other);
  friend void swap(RotateResponse& a, RotateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotateResponse* New() const final {
    return CreateMaybeMessage<RotateResponse>(nullptr);
  }

  RotateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RotateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RotateResponse& from);
  void MergeFrom(const RotateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.RotateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.StatusCode status_code = 1;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::navService::StatusCode status_code() const;
  void set_status_code(::navService::StatusCode value);

  // @@protoc_insertion_point(class_scope:navService.RotateResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class OnNavEventChangeRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.OnNavEventChangeRequest) */ {
 public:
  OnNavEventChangeRequest();
  virtual ~OnNavEventChangeRequest();

  OnNavEventChangeRequest(const OnNavEventChangeRequest& from);
  OnNavEventChangeRequest(OnNavEventChangeRequest&& from) noexcept
    : OnNavEventChangeRequest() {
    *this = ::std::move(from);
  }

  inline OnNavEventChangeRequest& operator=(const OnNavEventChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnNavEventChangeRequest& operator=(OnNavEventChangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OnNavEventChangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnNavEventChangeRequest* internal_default_instance() {
    return reinterpret_cast<const OnNavEventChangeRequest*>(
               &_OnNavEventChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(OnNavEventChangeRequest* other);
  friend void swap(OnNavEventChangeRequest& a, OnNavEventChangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnNavEventChangeRequest* New() const final {
    return CreateMaybeMessage<OnNavEventChangeRequest>(nullptr);
  }

  OnNavEventChangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OnNavEventChangeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OnNavEventChangeRequest& from);
  void MergeFrom(const OnNavEventChangeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnNavEventChangeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.OnNavEventChangeRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:navService.OnNavEventChangeRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class MoveEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.MoveEvent) */ {
 public:
  MoveEvent();
  virtual ~MoveEvent();

  MoveEvent(const MoveEvent& from);
  MoveEvent(MoveEvent&& from) noexcept
    : MoveEvent() {
    *this = ::std::move(from);
  }

  inline MoveEvent& operator=(const MoveEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveEvent& operator=(MoveEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MoveEvent* internal_default_instance() {
    return reinterpret_cast<const MoveEvent*>(
               &_MoveEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MoveEvent* other);
  friend void swap(MoveEvent& a, MoveEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MoveEvent* New() const final {
    return CreateMaybeMessage<MoveEvent>(nullptr);
  }

  MoveEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveEvent& from);
  void MergeFrom(const MoveEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.MoveEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.StatusCode status_code = 1;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::navService::StatusCode status_code() const;
  void set_status_code(::navService::StatusCode value);

  // @@protoc_insertion_point(class_scope:navService.MoveEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NavEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NavEvent) */ {
 public:
  NavEvent();
  virtual ~NavEvent();

  NavEvent(const NavEvent& from);
  NavEvent(NavEvent&& from) noexcept
    : NavEvent() {
    *this = ::std::move(from);
  }

  inline NavEvent& operator=(const NavEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavEvent& operator=(NavEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavEvent* internal_default_instance() {
    return reinterpret_cast<const NavEvent*>(
               &_NavEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(NavEvent* other);
  friend void swap(NavEvent& a, NavEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavEvent* New() const final {
    return CreateMaybeMessage<NavEvent>(nullptr);
  }

  NavEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavEvent& from);
  void MergeFrom(const NavEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NavEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.NavTarget nav_target = 2;
  bool has_nav_target() const;
  void clear_nav_target();
  static const int kNavTargetFieldNumber = 2;
  const ::navService::NavTarget& nav_target() const;
  ::navService::NavTarget* release_nav_target();
  ::navService::NavTarget* mutable_nav_target();
  void set_allocated_nav_target(::navService::NavTarget* nav_target);

  // .navService.StatusCode status_code = 1;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::navService::StatusCode status_code() const;
  void set_status_code(::navService::StatusCode value);

  // @@protoc_insertion_point(class_scope:navService.NavEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::navService::NavTarget* nav_target_;
  int status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class AutoChargeEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.AutoChargeEvent) */ {
 public:
  AutoChargeEvent();
  virtual ~AutoChargeEvent();

  AutoChargeEvent(const AutoChargeEvent& from);
  AutoChargeEvent(AutoChargeEvent&& from) noexcept
    : AutoChargeEvent() {
    *this = ::std::move(from);
  }

  inline AutoChargeEvent& operator=(const AutoChargeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoChargeEvent& operator=(AutoChargeEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AutoChargeEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutoChargeEvent* internal_default_instance() {
    return reinterpret_cast<const AutoChargeEvent*>(
               &_AutoChargeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(AutoChargeEvent* other);
  friend void swap(AutoChargeEvent& a, AutoChargeEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutoChargeEvent* New() const final {
    return CreateMaybeMessage<AutoChargeEvent>(nullptr);
  }

  AutoChargeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutoChargeEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AutoChargeEvent& from);
  void MergeFrom(const AutoChargeEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoChargeEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.AutoChargeEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.ChargeStatusCode charge_status_code = 1;
  void clear_charge_status_code();
  static const int kChargeStatusCodeFieldNumber = 1;
  ::navService::ChargeStatusCode charge_status_code() const;
  void set_charge_status_code(::navService::ChargeStatusCode value);

  // @@protoc_insertion_point(class_scope:navService.AutoChargeEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int charge_status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class RotateEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.RotateEvent) */ {
 public:
  RotateEvent();
  virtual ~RotateEvent();

  RotateEvent(const RotateEvent& from);
  RotateEvent(RotateEvent&& from) noexcept
    : RotateEvent() {
    *this = ::std::move(from);
  }

  inline RotateEvent& operator=(const RotateEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RotateEvent& operator=(RotateEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RotateEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotateEvent* internal_default_instance() {
    return reinterpret_cast<const RotateEvent*>(
               &_RotateEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RotateEvent* other);
  friend void swap(RotateEvent& a, RotateEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotateEvent* New() const final {
    return CreateMaybeMessage<RotateEvent>(nullptr);
  }

  RotateEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RotateEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RotateEvent& from);
  void MergeFrom(const RotateEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotateEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.RotateEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.StatusCode status_code = 1;
  void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  ::navService::StatusCode status_code() const;
  void set_status_code(::navService::StatusCode value);

  // @@protoc_insertion_point(class_scope:navService.RotateEvent)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class OnNavEventChangeResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.OnNavEventChangeResponse) */ {
 public:
  OnNavEventChangeResponse();
  virtual ~OnNavEventChangeResponse();

  OnNavEventChangeResponse(const OnNavEventChangeResponse& from);
  OnNavEventChangeResponse(OnNavEventChangeResponse&& from) noexcept
    : OnNavEventChangeResponse() {
    *this = ::std::move(from);
  }

  inline OnNavEventChangeResponse& operator=(const OnNavEventChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnNavEventChangeResponse& operator=(OnNavEventChangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OnNavEventChangeResponse& default_instance();

  enum ChangeOneofCase {
    kMoveEvent = 2,
    kNavEvent = 3,
    kRotateEvent = 4,
    kAutoChargeEvent = 5,
    CHANGE_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OnNavEventChangeResponse* internal_default_instance() {
    return reinterpret_cast<const OnNavEventChangeResponse*>(
               &_OnNavEventChangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(OnNavEventChangeResponse* other);
  friend void swap(OnNavEventChangeResponse& a, OnNavEventChangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OnNavEventChangeResponse* New() const final {
    return CreateMaybeMessage<OnNavEventChangeResponse>(nullptr);
  }

  OnNavEventChangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OnNavEventChangeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OnNavEventChangeResponse& from);
  void MergeFrom(const OnNavEventChangeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnNavEventChangeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.OnNavEventChangeResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.NavEventType nav_event_type = 1;
  void clear_nav_event_type();
  static const int kNavEventTypeFieldNumber = 1;
  ::navService::NavEventType nav_event_type() const;
  void set_nav_event_type(::navService::NavEventType value);

  // .navService.MoveEvent move_event = 2;
  bool has_move_event() const;
  void clear_move_event();
  static const int kMoveEventFieldNumber = 2;
  const ::navService::MoveEvent& move_event() const;
  ::navService::MoveEvent* release_move_event();
  ::navService::MoveEvent* mutable_move_event();
  void set_allocated_move_event(::navService::MoveEvent* move_event);

  // .navService.NavEvent nav_event = 3;
  bool has_nav_event() const;
  void clear_nav_event();
  static const int kNavEventFieldNumber = 3;
  const ::navService::NavEvent& nav_event() const;
  ::navService::NavEvent* release_nav_event();
  ::navService::NavEvent* mutable_nav_event();
  void set_allocated_nav_event(::navService::NavEvent* nav_event);

  // .navService.RotateEvent rotate_event = 4;
  bool has_rotate_event() const;
  void clear_rotate_event();
  static const int kRotateEventFieldNumber = 4;
  const ::navService::RotateEvent& rotate_event() const;
  ::navService::RotateEvent* release_rotate_event();
  ::navService::RotateEvent* mutable_rotate_event();
  void set_allocated_rotate_event(::navService::RotateEvent* rotate_event);

  // .navService.AutoChargeEvent auto_charge_event = 5;
  bool has_auto_charge_event() const;
  void clear_auto_charge_event();
  static const int kAutoChargeEventFieldNumber = 5;
  const ::navService::AutoChargeEvent& auto_charge_event() const;
  ::navService::AutoChargeEvent* release_auto_charge_event();
  ::navService::AutoChargeEvent* mutable_auto_charge_event();
  void set_allocated_auto_charge_event(::navService::AutoChargeEvent* auto_charge_event);

  void clear_change_oneof();
  ChangeOneofCase change_oneof_case() const;
  // @@protoc_insertion_point(class_scope:navService.OnNavEventChangeResponse)
 private:
  class HasBitSetters;
  void set_has_move_event();
  void set_has_nav_event();
  void set_has_rotate_event();
  void set_has_auto_charge_event();

  inline bool has_change_oneof() const;
  inline void clear_has_change_oneof();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int nav_event_type_;
  union ChangeOneofUnion {
    ChangeOneofUnion() {}
    ::navService::MoveEvent* move_event_;
    ::navService::NavEvent* nav_event_;
    ::navService::RotateEvent* rotate_event_;
    ::navService::AutoChargeEvent* auto_charge_event_;
  } change_oneof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class Route :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.Route) */ {
 public:
  Route();
  virtual ~Route();

  Route(const Route& from);
  Route(Route&& from) noexcept
    : Route() {
    *this = ::std::move(from);
  }

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline Route& operator=(Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Route& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Route* internal_default_instance() {
    return reinterpret_cast<const Route*>(
               &_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Route* other);
  friend void swap(Route& a, Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Route* New() const final {
    return CreateMaybeMessage<Route>(nullptr);
  }

  Route* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Route>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Route& from);
  void MergeFrom(const Route& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Route* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.Route";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navService.RoutePoint route_points = 4;
  int route_points_size() const;
  void clear_route_points();
  static const int kRoutePointsFieldNumber = 4;
  ::navService::RoutePoint* mutable_route_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::RoutePoint >*
      mutable_route_points();
  const ::navService::RoutePoint& route_points(int index) const;
  ::navService::RoutePoint* add_route_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::RoutePoint >&
      route_points() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // bool is_active = 3;
  void clear_is_active();
  static const int kIsActiveFieldNumber = 3;
  bool is_active() const;
  void set_is_active(bool value);

  // @@protoc_insertion_point(class_scope:navService.Route)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::RoutePoint > route_points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool is_active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class RoutePoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.RoutePoint) */ {
 public:
  RoutePoint();
  virtual ~RoutePoint();

  RoutePoint(const RoutePoint& from);
  RoutePoint(RoutePoint&& from) noexcept
    : RoutePoint() {
    *this = ::std::move(from);
  }

  inline RoutePoint& operator=(const RoutePoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutePoint& operator=(RoutePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoutePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutePoint* internal_default_instance() {
    return reinterpret_cast<const RoutePoint*>(
               &_RoutePoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(RoutePoint* other);
  friend void swap(RoutePoint& a, RoutePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutePoint* New() const final {
    return CreateMaybeMessage<RoutePoint>(nullptr);
  }

  RoutePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutePoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoutePoint& from);
  void MergeFrom(const RoutePoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutePoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.RoutePoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // uint32 rotate = 2;
  void clear_rotate();
  static const int kRotateFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::uint32 rotate() const;
  void set_rotate(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:navService.RoutePoint)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rotate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NewRouteRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NewRouteRequest) */ {
 public:
  NewRouteRequest();
  virtual ~NewRouteRequest();

  NewRouteRequest(const NewRouteRequest& from);
  NewRouteRequest(NewRouteRequest&& from) noexcept
    : NewRouteRequest() {
    *this = ::std::move(from);
  }

  inline NewRouteRequest& operator=(const NewRouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRouteRequest& operator=(NewRouteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewRouteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewRouteRequest* internal_default_instance() {
    return reinterpret_cast<const NewRouteRequest*>(
               &_NewRouteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(NewRouteRequest* other);
  friend void swap(NewRouteRequest& a, NewRouteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewRouteRequest* New() const final {
    return CreateMaybeMessage<NewRouteRequest>(nullptr);
  }

  NewRouteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewRouteRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewRouteRequest& from);
  void MergeFrom(const NewRouteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRouteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NewRouteRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.Route route = 1;
  bool has_route() const;
  void clear_route();
  static const int kRouteFieldNumber = 1;
  const ::navService::Route& route() const;
  ::navService::Route* release_route();
  ::navService::Route* mutable_route();
  void set_allocated_route(::navService::Route* route);

  // @@protoc_insertion_point(class_scope:navService.NewRouteRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::navService::Route* route_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class NewRouteResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.NewRouteResponse) */ {
 public:
  NewRouteResponse();
  virtual ~NewRouteResponse();

  NewRouteResponse(const NewRouteResponse& from);
  NewRouteResponse(NewRouteResponse&& from) noexcept
    : NewRouteResponse() {
    *this = ::std::move(from);
  }

  inline NewRouteResponse& operator=(const NewRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewRouteResponse& operator=(NewRouteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NewRouteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewRouteResponse* internal_default_instance() {
    return reinterpret_cast<const NewRouteResponse*>(
               &_NewRouteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(NewRouteResponse* other);
  friend void swap(NewRouteResponse& a, NewRouteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewRouteResponse* New() const final {
    return CreateMaybeMessage<NewRouteResponse>(nullptr);
  }

  NewRouteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewRouteResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NewRouteResponse& from);
  void MergeFrom(const NewRouteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewRouteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.NewRouteResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.Route route = 1;
  bool has_route() const;
  void clear_route();
  static const int kRouteFieldNumber = 1;
  const ::navService::Route& route() const;
  ::navService::Route* release_route();
  ::navService::Route* mutable_route();
  void set_allocated_route(::navService::Route* route);

  // @@protoc_insertion_point(class_scope:navService.NewRouteResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::navService::Route* route_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class ListRoutesRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.ListRoutesRequest) */ {
 public:
  ListRoutesRequest();
  virtual ~ListRoutesRequest();

  ListRoutesRequest(const ListRoutesRequest& from);
  ListRoutesRequest(ListRoutesRequest&& from) noexcept
    : ListRoutesRequest() {
    *this = ::std::move(from);
  }

  inline ListRoutesRequest& operator=(const ListRoutesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoutesRequest& operator=(ListRoutesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListRoutesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListRoutesRequest* internal_default_instance() {
    return reinterpret_cast<const ListRoutesRequest*>(
               &_ListRoutesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ListRoutesRequest* other);
  friend void swap(ListRoutesRequest& a, ListRoutesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListRoutesRequest* New() const final {
    return CreateMaybeMessage<ListRoutesRequest>(nullptr);
  }

  ListRoutesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRoutesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListRoutesRequest& from);
  void MergeFrom(const ListRoutesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRoutesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.ListRoutesRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:navService.ListRoutesRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class ListRoutesResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.ListRoutesResponse) */ {
 public:
  ListRoutesResponse();
  virtual ~ListRoutesResponse();

  ListRoutesResponse(const ListRoutesResponse& from);
  ListRoutesResponse(ListRoutesResponse&& from) noexcept
    : ListRoutesResponse() {
    *this = ::std::move(from);
  }

  inline ListRoutesResponse& operator=(const ListRoutesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoutesResponse& operator=(ListRoutesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListRoutesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListRoutesResponse* internal_default_instance() {
    return reinterpret_cast<const ListRoutesResponse*>(
               &_ListRoutesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ListRoutesResponse* other);
  friend void swap(ListRoutesResponse& a, ListRoutesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListRoutesResponse* New() const final {
    return CreateMaybeMessage<ListRoutesResponse>(nullptr);
  }

  ListRoutesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListRoutesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListRoutesResponse& from);
  void MergeFrom(const ListRoutesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRoutesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.ListRoutesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .navService.Route routes = 1;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 1;
  ::navService::Route* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::Route >*
      mutable_routes();
  const ::navService::Route& routes(int index) const;
  ::navService::Route* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::Route >&
      routes() const;

  // @@protoc_insertion_point(class_scope:navService.ListRoutesResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::Route > routes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class GetRouteRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.GetRouteRequest) */ {
 public:
  GetRouteRequest();
  virtual ~GetRouteRequest();

  GetRouteRequest(const GetRouteRequest& from);
  GetRouteRequest(GetRouteRequest&& from) noexcept
    : GetRouteRequest() {
    *this = ::std::move(from);
  }

  inline GetRouteRequest& operator=(const GetRouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRouteRequest& operator=(GetRouteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRouteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRouteRequest* internal_default_instance() {
    return reinterpret_cast<const GetRouteRequest*>(
               &_GetRouteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(GetRouteRequest* other);
  friend void swap(GetRouteRequest& a, GetRouteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRouteRequest* New() const final {
    return CreateMaybeMessage<GetRouteRequest>(nullptr);
  }

  GetRouteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRouteRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRouteRequest& from);
  void MergeFrom(const GetRouteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRouteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.GetRouteRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // @@protoc_insertion_point(class_scope:navService.GetRouteRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class GetRouteResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.GetRouteResponse) */ {
 public:
  GetRouteResponse();
  virtual ~GetRouteResponse();

  GetRouteResponse(const GetRouteResponse& from);
  GetRouteResponse(GetRouteResponse&& from) noexcept
    : GetRouteResponse() {
    *this = ::std::move(from);
  }

  inline GetRouteResponse& operator=(const GetRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRouteResponse& operator=(GetRouteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRouteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRouteResponse* internal_default_instance() {
    return reinterpret_cast<const GetRouteResponse*>(
               &_GetRouteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(GetRouteResponse* other);
  friend void swap(GetRouteResponse& a, GetRouteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRouteResponse* New() const final {
    return CreateMaybeMessage<GetRouteResponse>(nullptr);
  }

  GetRouteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRouteResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRouteResponse& from);
  void MergeFrom(const GetRouteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRouteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.GetRouteResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.Route route = 1;
  bool has_route() const;
  void clear_route();
  static const int kRouteFieldNumber = 1;
  const ::navService::Route& route() const;
  ::navService::Route* release_route();
  ::navService::Route* mutable_route();
  void set_allocated_route(::navService::Route* route);

  // @@protoc_insertion_point(class_scope:navService.GetRouteResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::navService::Route* route_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class UpdateRouteRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.UpdateRouteRequest) */ {
 public:
  UpdateRouteRequest();
  virtual ~UpdateRouteRequest();

  UpdateRouteRequest(const UpdateRouteRequest& from);
  UpdateRouteRequest(UpdateRouteRequest&& from) noexcept
    : UpdateRouteRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRouteRequest& operator=(const UpdateRouteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRouteRequest& operator=(UpdateRouteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateRouteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRouteRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRouteRequest*>(
               &_UpdateRouteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(UpdateRouteRequest* other);
  friend void swap(UpdateRouteRequest& a, UpdateRouteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRouteRequest* New() const final {
    return CreateMaybeMessage<UpdateRouteRequest>(nullptr);
  }

  UpdateRouteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRouteRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateRouteRequest& from);
  void MergeFrom(const UpdateRouteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRouteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.UpdateRouteRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.Route route = 1;
  bool has_route() const;
  void clear_route();
  static const int kRouteFieldNumber = 1;
  const ::navService::Route& route() const;
  ::navService::Route* release_route();
  ::navService::Route* mutable_route();
  void set_allocated_route(::navService::Route* route);

  // @@protoc_insertion_point(class_scope:navService.UpdateRouteRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::navService::Route* route_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class UpdateRouteResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.UpdateRouteResponse) */ {
 public:
  UpdateRouteResponse();
  virtual ~UpdateRouteResponse();

  UpdateRouteResponse(const UpdateRouteResponse& from);
  UpdateRouteResponse(UpdateRouteResponse&& from) noexcept
    : UpdateRouteResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRouteResponse& operator=(const UpdateRouteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRouteResponse& operator=(UpdateRouteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateRouteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRouteResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRouteResponse*>(
               &_UpdateRouteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(UpdateRouteResponse* other);
  friend void swap(UpdateRouteResponse& a, UpdateRouteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRouteResponse* New() const final {
    return CreateMaybeMessage<UpdateRouteResponse>(nullptr);
  }

  UpdateRouteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRouteResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateRouteResponse& from);
  void MergeFrom(const UpdateRouteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRouteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.UpdateRouteResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .navService.Route route = 1;
  bool has_route() const;
  void clear_route();
  static const int kRouteFieldNumber = 1;
  const ::navService::Route& route() const;
  ::navService::Route* release_route();
  ::navService::Route* mutable_route();
  void set_allocated_route(::navService::Route* route);

  // @@protoc_insertion_point(class_scope:navService.UpdateRouteResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::navService::Route* route_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class DeleteRoutesRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.DeleteRoutesRequest) */ {
 public:
  DeleteRoutesRequest();
  virtual ~DeleteRoutesRequest();

  DeleteRoutesRequest(const DeleteRoutesRequest& from);
  DeleteRoutesRequest(DeleteRoutesRequest&& from) noexcept
    : DeleteRoutesRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRoutesRequest& operator=(const DeleteRoutesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRoutesRequest& operator=(DeleteRoutesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteRoutesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRoutesRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRoutesRequest*>(
               &_DeleteRoutesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(DeleteRoutesRequest* other);
  friend void swap(DeleteRoutesRequest& a, DeleteRoutesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRoutesRequest* New() const final {
    return CreateMaybeMessage<DeleteRoutesRequest>(nullptr);
  }

  DeleteRoutesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRoutesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteRoutesRequest& from);
  void MergeFrom(const DeleteRoutesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRoutesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.DeleteRoutesRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string routes_id = 1;
  int routes_id_size() const;
  void clear_routes_id();
  static const int kRoutesIdFieldNumber = 1;
  const std::string& routes_id(int index) const;
  std::string* mutable_routes_id(int index);
  void set_routes_id(int index, const std::string& value);
  void set_routes_id(int index, std::string&& value);
  void set_routes_id(int index, const char* value);
  void set_routes_id(int index, const char* value, size_t size);
  std::string* add_routes_id();
  void add_routes_id(const std::string& value);
  void add_routes_id(std::string&& value);
  void add_routes_id(const char* value);
  void add_routes_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& routes_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_routes_id();

  // @@protoc_insertion_point(class_scope:navService.DeleteRoutesRequest)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> routes_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// -------------------------------------------------------------------

class DeleteRoutesResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:navService.DeleteRoutesResponse) */ {
 public:
  DeleteRoutesResponse();
  virtual ~DeleteRoutesResponse();

  DeleteRoutesResponse(const DeleteRoutesResponse& from);
  DeleteRoutesResponse(DeleteRoutesResponse&& from) noexcept
    : DeleteRoutesResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRoutesResponse& operator=(const DeleteRoutesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRoutesResponse& operator=(DeleteRoutesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteRoutesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRoutesResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRoutesResponse*>(
               &_DeleteRoutesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(DeleteRoutesResponse* other);
  friend void swap(DeleteRoutesResponse& a, DeleteRoutesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRoutesResponse* New() const final {
    return CreateMaybeMessage<DeleteRoutesResponse>(nullptr);
  }

  DeleteRoutesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRoutesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteRoutesResponse& from);
  void MergeFrom(const DeleteRoutesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRoutesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "navService.DeleteRoutesResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_nav_2eproto);
    return ::descriptor_table_nav_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:navService.DeleteRoutesResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_nav_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MoveRequest

// uint32 speed = 1;
inline void MoveRequest::clear_speed() {
  speed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MoveRequest::speed() const {
  // @@protoc_insertion_point(field_get:navService.MoveRequest.speed)
  return speed_;
}
inline void MoveRequest::set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:navService.MoveRequest.speed)
}

// uint32 rspeed = 2;
inline void MoveRequest::clear_rspeed() {
  rspeed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MoveRequest::rspeed() const {
  // @@protoc_insertion_point(field_get:navService.MoveRequest.rspeed)
  return rspeed_;
}
inline void MoveRequest::set_rspeed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  rspeed_ = value;
  // @@protoc_insertion_point(field_set:navService.MoveRequest.rspeed)
}

// .navService.MoveDirection direction = 3;
inline void MoveRequest::clear_direction() {
  direction_ = 0;
}
inline ::navService::MoveDirection MoveRequest::direction() const {
  // @@protoc_insertion_point(field_get:navService.MoveRequest.direction)
  return static_cast< ::navService::MoveDirection >(direction_);
}
inline void MoveRequest::set_direction(::navService::MoveDirection value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:navService.MoveRequest.direction)
}

// string mode = 4;
inline void MoveRequest::clear_mode() {
  mode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MoveRequest::mode() const {
  // @@protoc_insertion_point(field_get:navService.MoveRequest.mode)
  return mode_.GetNoArena();
}
inline void MoveRequest::set_mode(const std::string& value) {
  
  mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navService.MoveRequest.mode)
}
inline void MoveRequest::set_mode(std::string&& value) {
  
  mode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navService.MoveRequest.mode)
}
inline void MoveRequest::set_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navService.MoveRequest.mode)
}
inline void MoveRequest::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navService.MoveRequest.mode)
}
inline std::string* MoveRequest::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:navService.MoveRequest.mode)
  return mode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MoveRequest::release_mode() {
  // @@protoc_insertion_point(field_release:navService.MoveRequest.mode)
  
  return mode_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MoveRequest::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:navService.MoveRequest.mode)
}

// -------------------------------------------------------------------

// MoveResponse

// .navService.StatusCode status_code = 1;
inline void MoveResponse::clear_status_code() {
  status_code_ = 0;
}
inline ::navService::StatusCode MoveResponse::status_code() const {
  // @@protoc_insertion_point(field_get:navService.MoveResponse.status_code)
  return static_cast< ::navService::StatusCode >(status_code_);
}
inline void MoveResponse::set_status_code(::navService::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.MoveResponse.status_code)
}

// -------------------------------------------------------------------

// NavTarget

// string index = 1;
inline void NavTarget::clear_index() {
  index_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NavTarget::index() const {
  // @@protoc_insertion_point(field_get:navService.NavTarget.index)
  return index_.GetNoArena();
}
inline void NavTarget::set_index(const std::string& value) {
  
  index_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navService.NavTarget.index)
}
inline void NavTarget::set_index(std::string&& value) {
  
  index_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navService.NavTarget.index)
}
inline void NavTarget::set_index(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  index_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navService.NavTarget.index)
}
inline void NavTarget::set_index(const char* value, size_t size) {
  
  index_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navService.NavTarget.index)
}
inline std::string* NavTarget::mutable_index() {
  
  // @@protoc_insertion_point(field_mutable:navService.NavTarget.index)
  return index_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NavTarget::release_index() {
  // @@protoc_insertion_point(field_release:navService.NavTarget.index)
  
  return index_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NavTarget::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    
  } else {
    
  }
  index_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index);
  // @@protoc_insertion_point(field_set_allocated:navService.NavTarget.index)
}

// string name = 2;
inline void NavTarget::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& NavTarget::name() const {
  // @@protoc_insertion_point(field_get:navService.NavTarget.name)
  return name_.GetNoArena();
}
inline void NavTarget::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navService.NavTarget.name)
}
inline void NavTarget::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navService.NavTarget.name)
}
inline void NavTarget::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navService.NavTarget.name)
}
inline void NavTarget::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navService.NavTarget.name)
}
inline std::string* NavTarget::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:navService.NavTarget.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NavTarget::release_name() {
  // @@protoc_insertion_point(field_release:navService.NavTarget.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NavTarget::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:navService.NavTarget.name)
}

// -------------------------------------------------------------------

// NavRoaming

// .navService.RoamingType nav_roaming_type = 1;
inline void NavRoaming::clear_nav_roaming_type() {
  nav_roaming_type_ = 0;
}
inline ::navService::RoamingType NavRoaming::nav_roaming_type() const {
  // @@protoc_insertion_point(field_get:navService.NavRoaming.nav_roaming_type)
  return static_cast< ::navService::RoamingType >(nav_roaming_type_);
}
inline void NavRoaming::set_nav_roaming_type(::navService::RoamingType value) {
  
  nav_roaming_type_ = value;
  // @@protoc_insertion_point(field_set:navService.NavRoaming.nav_roaming_type)
}

// int32 wait_sec = 2;
inline void NavRoaming::clear_wait_sec() {
  wait_sec_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NavRoaming::wait_sec() const {
  // @@protoc_insertion_point(field_get:navService.NavRoaming.wait_sec)
  return wait_sec_;
}
inline void NavRoaming::set_wait_sec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  wait_sec_ = value;
  // @@protoc_insertion_point(field_set:navService.NavRoaming.wait_sec)
}

// repeated string roaming_target_indexes = 3;
inline int NavRoaming::roaming_target_indexes_size() const {
  return roaming_target_indexes_.size();
}
inline void NavRoaming::clear_roaming_target_indexes() {
  roaming_target_indexes_.Clear();
}
inline const std::string& NavRoaming::roaming_target_indexes(int index) const {
  // @@protoc_insertion_point(field_get:navService.NavRoaming.roaming_target_indexes)
  return roaming_target_indexes_.Get(index);
}
inline std::string* NavRoaming::mutable_roaming_target_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:navService.NavRoaming.roaming_target_indexes)
  return roaming_target_indexes_.Mutable(index);
}
inline void NavRoaming::set_roaming_target_indexes(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:navService.NavRoaming.roaming_target_indexes)
  roaming_target_indexes_.Mutable(index)->assign(value);
}
inline void NavRoaming::set_roaming_target_indexes(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:navService.NavRoaming.roaming_target_indexes)
  roaming_target_indexes_.Mutable(index)->assign(std::move(value));
}
inline void NavRoaming::set_roaming_target_indexes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  roaming_target_indexes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:navService.NavRoaming.roaming_target_indexes)
}
inline void NavRoaming::set_roaming_target_indexes(int index, const char* value, size_t size) {
  roaming_target_indexes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:navService.NavRoaming.roaming_target_indexes)
}
inline std::string* NavRoaming::add_roaming_target_indexes() {
  // @@protoc_insertion_point(field_add_mutable:navService.NavRoaming.roaming_target_indexes)
  return roaming_target_indexes_.Add();
}
inline void NavRoaming::add_roaming_target_indexes(const std::string& value) {
  roaming_target_indexes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:navService.NavRoaming.roaming_target_indexes)
}
inline void NavRoaming::add_roaming_target_indexes(std::string&& value) {
  roaming_target_indexes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:navService.NavRoaming.roaming_target_indexes)
}
inline void NavRoaming::add_roaming_target_indexes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  roaming_target_indexes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:navService.NavRoaming.roaming_target_indexes)
}
inline void NavRoaming::add_roaming_target_indexes(const char* value, size_t size) {
  roaming_target_indexes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:navService.NavRoaming.roaming_target_indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NavRoaming::roaming_target_indexes() const {
  // @@protoc_insertion_point(field_list:navService.NavRoaming.roaming_target_indexes)
  return roaming_target_indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NavRoaming::mutable_roaming_target_indexes() {
  // @@protoc_insertion_point(field_mutable_list:navService.NavRoaming.roaming_target_indexes)
  return &roaming_target_indexes_;
}

// bool order_loop = 4;
inline void NavRoaming::clear_order_loop() {
  order_loop_ = false;
}
inline bool NavRoaming::order_loop() const {
  // @@protoc_insertion_point(field_get:navService.NavRoaming.order_loop)
  return order_loop_;
}
inline void NavRoaming::set_order_loop(bool value) {
  
  order_loop_ = value;
  // @@protoc_insertion_point(field_set:navService.NavRoaming.order_loop)
}

// -------------------------------------------------------------------

// NavToRequest

// .navService.NavTarget target = 1;
inline bool NavToRequest::has_target() const {
  return target_oneof_case() == kTarget;
}
inline void NavToRequest::set_has_target() {
  _oneof_case_[0] = kTarget;
}
inline void NavToRequest::clear_target() {
  if (has_target()) {
    delete target_oneof_.target_;
    clear_has_target_oneof();
  }
}
inline ::navService::NavTarget* NavToRequest::release_target() {
  // @@protoc_insertion_point(field_release:navService.NavToRequest.target)
  if (has_target()) {
    clear_has_target_oneof();
      ::navService::NavTarget* temp = target_oneof_.target_;
    target_oneof_.target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::NavTarget& NavToRequest::target() const {
  // @@protoc_insertion_point(field_get:navService.NavToRequest.target)
  return has_target()
      ? *target_oneof_.target_
      : *reinterpret_cast< ::navService::NavTarget*>(&::navService::_NavTarget_default_instance_);
}
inline ::navService::NavTarget* NavToRequest::mutable_target() {
  if (!has_target()) {
    clear_target_oneof();
    set_has_target();
    target_oneof_.target_ = CreateMaybeMessage< ::navService::NavTarget >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.NavToRequest.target)
  return target_oneof_.target_;
}

// .navService.NavRoaming roaming = 3;
inline bool NavToRequest::has_roaming() const {
  return target_oneof_case() == kRoaming;
}
inline void NavToRequest::set_has_roaming() {
  _oneof_case_[0] = kRoaming;
}
inline void NavToRequest::clear_roaming() {
  if (has_roaming()) {
    delete target_oneof_.roaming_;
    clear_has_target_oneof();
  }
}
inline ::navService::NavRoaming* NavToRequest::release_roaming() {
  // @@protoc_insertion_point(field_release:navService.NavToRequest.roaming)
  if (has_roaming()) {
    clear_has_target_oneof();
      ::navService::NavRoaming* temp = target_oneof_.roaming_;
    target_oneof_.roaming_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::NavRoaming& NavToRequest::roaming() const {
  // @@protoc_insertion_point(field_get:navService.NavToRequest.roaming)
  return has_roaming()
      ? *target_oneof_.roaming_
      : *reinterpret_cast< ::navService::NavRoaming*>(&::navService::_NavRoaming_default_instance_);
}
inline ::navService::NavRoaming* NavToRequest::mutable_roaming() {
  if (!has_roaming()) {
    clear_target_oneof();
    set_has_roaming();
    target_oneof_.roaming_ = CreateMaybeMessage< ::navService::NavRoaming >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.NavToRequest.roaming)
  return target_oneof_.roaming_;
}

// .navService.MapPosition map_position = 5;
inline bool NavToRequest::has_map_position() const {
  return target_oneof_case() == kMapPosition;
}
inline void NavToRequest::set_has_map_position() {
  _oneof_case_[0] = kMapPosition;
}
inline ::navService::MapPosition* NavToRequest::release_map_position() {
  // @@protoc_insertion_point(field_release:navService.NavToRequest.map_position)
  if (has_map_position()) {
    clear_has_target_oneof();
      ::navService::MapPosition* temp = target_oneof_.map_position_;
    target_oneof_.map_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::MapPosition& NavToRequest::map_position() const {
  // @@protoc_insertion_point(field_get:navService.NavToRequest.map_position)
  return has_map_position()
      ? *target_oneof_.map_position_
      : *reinterpret_cast< ::navService::MapPosition*>(&::navService::_MapPosition_default_instance_);
}
inline ::navService::MapPosition* NavToRequest::mutable_map_position() {
  if (!has_map_position()) {
    clear_target_oneof();
    set_has_map_position();
    target_oneof_.map_position_ = CreateMaybeMessage< ::navService::MapPosition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.NavToRequest.map_position)
  return target_oneof_.map_position_;
}

// uint32 speed = 2;
inline void NavToRequest::clear_speed() {
  speed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavToRequest::speed() const {
  // @@protoc_insertion_point(field_get:navService.NavToRequest.speed)
  return speed_;
}
inline void NavToRequest::set_speed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:navService.NavToRequest.speed)
}

// bool sync_mode = 4;
inline void NavToRequest::clear_sync_mode() {
  sync_mode_ = false;
}
inline bool NavToRequest::sync_mode() const {
  // @@protoc_insertion_point(field_get:navService.NavToRequest.sync_mode)
  return sync_mode_;
}
inline void NavToRequest::set_sync_mode(bool value) {
  
  sync_mode_ = value;
  // @@protoc_insertion_point(field_set:navService.NavToRequest.sync_mode)
}

inline bool NavToRequest::has_target_oneof() const {
  return target_oneof_case() != TARGET_ONEOF_NOT_SET;
}
inline void NavToRequest::clear_has_target_oneof() {
  _oneof_case_[0] = TARGET_ONEOF_NOT_SET;
}
inline NavToRequest::TargetOneofCase NavToRequest::target_oneof_case() const {
  return NavToRequest::TargetOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NavToResponse

// .navService.StatusCode status_code = 1;
inline void NavToResponse::clear_status_code() {
  status_code_ = 0;
}
inline ::navService::StatusCode NavToResponse::status_code() const {
  // @@protoc_insertion_point(field_get:navService.NavToResponse.status_code)
  return static_cast< ::navService::StatusCode >(status_code_);
}
inline void NavToResponse::set_status_code(::navService::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.NavToResponse.status_code)
}

// .navService.NavTarget target = 2;
inline bool NavToResponse::has_target() const {
  return target_oneof_case() == kTarget;
}
inline void NavToResponse::set_has_target() {
  _oneof_case_[0] = kTarget;
}
inline void NavToResponse::clear_target() {
  if (has_target()) {
    delete target_oneof_.target_;
    clear_has_target_oneof();
  }
}
inline ::navService::NavTarget* NavToResponse::release_target() {
  // @@protoc_insertion_point(field_release:navService.NavToResponse.target)
  if (has_target()) {
    clear_has_target_oneof();
      ::navService::NavTarget* temp = target_oneof_.target_;
    target_oneof_.target_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::NavTarget& NavToResponse::target() const {
  // @@protoc_insertion_point(field_get:navService.NavToResponse.target)
  return has_target()
      ? *target_oneof_.target_
      : *reinterpret_cast< ::navService::NavTarget*>(&::navService::_NavTarget_default_instance_);
}
inline ::navService::NavTarget* NavToResponse::mutable_target() {
  if (!has_target()) {
    clear_target_oneof();
    set_has_target();
    target_oneof_.target_ = CreateMaybeMessage< ::navService::NavTarget >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.NavToResponse.target)
  return target_oneof_.target_;
}

// bool is_roaming = 3;
inline bool NavToResponse::has_is_roaming() const {
  return target_oneof_case() == kIsRoaming;
}
inline void NavToResponse::set_has_is_roaming() {
  _oneof_case_[0] = kIsRoaming;
}
inline void NavToResponse::clear_is_roaming() {
  if (has_is_roaming()) {
    target_oneof_.is_roaming_ = false;
    clear_has_target_oneof();
  }
}
inline bool NavToResponse::is_roaming() const {
  // @@protoc_insertion_point(field_get:navService.NavToResponse.is_roaming)
  if (has_is_roaming()) {
    return target_oneof_.is_roaming_;
  }
  return false;
}
inline void NavToResponse::set_is_roaming(bool value) {
  if (!has_is_roaming()) {
    clear_target_oneof();
    set_has_is_roaming();
  }
  target_oneof_.is_roaming_ = value;
  // @@protoc_insertion_point(field_set:navService.NavToResponse.is_roaming)
}

// .navService.MapPosition map_position = 4;
inline bool NavToResponse::has_map_position() const {
  return target_oneof_case() == kMapPosition;
}
inline void NavToResponse::set_has_map_position() {
  _oneof_case_[0] = kMapPosition;
}
inline ::navService::MapPosition* NavToResponse::release_map_position() {
  // @@protoc_insertion_point(field_release:navService.NavToResponse.map_position)
  if (has_map_position()) {
    clear_has_target_oneof();
      ::navService::MapPosition* temp = target_oneof_.map_position_;
    target_oneof_.map_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::MapPosition& NavToResponse::map_position() const {
  // @@protoc_insertion_point(field_get:navService.NavToResponse.map_position)
  return has_map_position()
      ? *target_oneof_.map_position_
      : *reinterpret_cast< ::navService::MapPosition*>(&::navService::_MapPosition_default_instance_);
}
inline ::navService::MapPosition* NavToResponse::mutable_map_position() {
  if (!has_map_position()) {
    clear_target_oneof();
    set_has_map_position();
    target_oneof_.map_position_ = CreateMaybeMessage< ::navService::MapPosition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.NavToResponse.map_position)
  return target_oneof_.map_position_;
}

inline bool NavToResponse::has_target_oneof() const {
  return target_oneof_case() != TARGET_ONEOF_NOT_SET;
}
inline void NavToResponse::clear_has_target_oneof() {
  _oneof_case_[0] = TARGET_ONEOF_NOT_SET;
}
inline NavToResponse::TargetOneofCase NavToResponse::target_oneof_case() const {
  return NavToResponse::TargetOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NavStopRequest

// -------------------------------------------------------------------

// NavStopResponse

// .navService.StatusCode status_code = 1;
inline void NavStopResponse::clear_status_code() {
  status_code_ = 0;
}
inline ::navService::StatusCode NavStopResponse::status_code() const {
  // @@protoc_insertion_point(field_get:navService.NavStopResponse.status_code)
  return static_cast< ::navService::StatusCode >(status_code_);
}
inline void NavStopResponse::set_status_code(::navService::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.NavStopResponse.status_code)
}

// -------------------------------------------------------------------

// AutoChargeRequest

// bool charge = 1;
inline bool AutoChargeRequest::has_charge() const {
  return charge_option_oneof_case() == kCharge;
}
inline void AutoChargeRequest::set_has_charge() {
  _oneof_case_[0] = kCharge;
}
inline void AutoChargeRequest::clear_charge() {
  if (has_charge()) {
    charge_option_oneof_.charge_ = false;
    clear_has_charge_option_oneof();
  }
}
inline bool AutoChargeRequest::charge() const {
  // @@protoc_insertion_point(field_get:navService.AutoChargeRequest.charge)
  if (has_charge()) {
    return charge_option_oneof_.charge_;
  }
  return false;
}
inline void AutoChargeRequest::set_charge(bool value) {
  if (!has_charge()) {
    clear_charge_option_oneof();
    set_has_charge();
  }
  charge_option_oneof_.charge_ = value;
  // @@protoc_insertion_point(field_set:navService.AutoChargeRequest.charge)
}

// bool cancel = 2;
inline bool AutoChargeRequest::has_cancel() const {
  return charge_option_oneof_case() == kCancel;
}
inline void AutoChargeRequest::set_has_cancel() {
  _oneof_case_[0] = kCancel;
}
inline void AutoChargeRequest::clear_cancel() {
  if (has_cancel()) {
    charge_option_oneof_.cancel_ = false;
    clear_has_charge_option_oneof();
  }
}
inline bool AutoChargeRequest::cancel() const {
  // @@protoc_insertion_point(field_get:navService.AutoChargeRequest.cancel)
  if (has_cancel()) {
    return charge_option_oneof_.cancel_;
  }
  return false;
}
inline void AutoChargeRequest::set_cancel(bool value) {
  if (!has_cancel()) {
    clear_charge_option_oneof();
    set_has_cancel();
  }
  charge_option_oneof_.cancel_ = value;
  // @@protoc_insertion_point(field_set:navService.AutoChargeRequest.cancel)
}

// bool charge_preset = 3;
inline bool AutoChargeRequest::has_charge_preset() const {
  return charge_option_oneof_case() == kChargePreset;
}
inline void AutoChargeRequest::set_has_charge_preset() {
  _oneof_case_[0] = kChargePreset;
}
inline void AutoChargeRequest::clear_charge_preset() {
  if (has_charge_preset()) {
    charge_option_oneof_.charge_preset_ = false;
    clear_has_charge_option_oneof();
  }
}
inline bool AutoChargeRequest::charge_preset() const {
  // @@protoc_insertion_point(field_get:navService.AutoChargeRequest.charge_preset)
  if (has_charge_preset()) {
    return charge_option_oneof_.charge_preset_;
  }
  return false;
}
inline void AutoChargeRequest::set_charge_preset(bool value) {
  if (!has_charge_preset()) {
    clear_charge_option_oneof();
    set_has_charge_preset();
  }
  charge_option_oneof_.charge_preset_ = value;
  // @@protoc_insertion_point(field_set:navService.AutoChargeRequest.charge_preset)
}

// uint32 timeout_sec = 4;
inline void AutoChargeRequest::clear_timeout_sec() {
  timeout_sec_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AutoChargeRequest::timeout_sec() const {
  // @@protoc_insertion_point(field_get:navService.AutoChargeRequest.timeout_sec)
  return timeout_sec_;
}
inline void AutoChargeRequest::set_timeout_sec(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  timeout_sec_ = value;
  // @@protoc_insertion_point(field_set:navService.AutoChargeRequest.timeout_sec)
}

inline bool AutoChargeRequest::has_charge_option_oneof() const {
  return charge_option_oneof_case() != CHARGE_OPTION_ONEOF_NOT_SET;
}
inline void AutoChargeRequest::clear_has_charge_option_oneof() {
  _oneof_case_[0] = CHARGE_OPTION_ONEOF_NOT_SET;
}
inline AutoChargeRequest::ChargeOptionOneofCase AutoChargeRequest::charge_option_oneof_case() const {
  return AutoChargeRequest::ChargeOptionOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AutoChargeResponse

// .navService.ChargeStatusCode charge_status_code = 1;
inline void AutoChargeResponse::clear_charge_status_code() {
  charge_status_code_ = 0;
}
inline ::navService::ChargeStatusCode AutoChargeResponse::charge_status_code() const {
  // @@protoc_insertion_point(field_get:navService.AutoChargeResponse.charge_status_code)
  return static_cast< ::navService::ChargeStatusCode >(charge_status_code_);
}
inline void AutoChargeResponse::set_charge_status_code(::navService::ChargeStatusCode value) {
  
  charge_status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.AutoChargeResponse.charge_status_code)
}

// -------------------------------------------------------------------

// RotateRequest

// int32 angle = 1;
inline bool RotateRequest::has_angle() const {
  return rotate_oneof_case() == kAngle;
}
inline void RotateRequest::set_has_angle() {
  _oneof_case_[0] = kAngle;
}
inline void RotateRequest::clear_angle() {
  if (has_angle()) {
    rotate_oneof_.angle_ = 0;
    clear_has_rotate_oneof();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RotateRequest::angle() const {
  // @@protoc_insertion_point(field_get:navService.RotateRequest.angle)
  if (has_angle()) {
    return rotate_oneof_.angle_;
  }
  return 0;
}
inline void RotateRequest::set_angle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!has_angle()) {
    clear_rotate_oneof();
    set_has_angle();
  }
  rotate_oneof_.angle_ = value;
  // @@protoc_insertion_point(field_set:navService.RotateRequest.angle)
}

// bool rollback = 2;
inline bool RotateRequest::has_rollback() const {
  return rotate_oneof_case() == kRollback;
}
inline void RotateRequest::set_has_rollback() {
  _oneof_case_[0] = kRollback;
}
inline void RotateRequest::clear_rollback() {
  if (has_rollback()) {
    rotate_oneof_.rollback_ = false;
    clear_has_rotate_oneof();
  }
}
inline bool RotateRequest::rollback() const {
  // @@protoc_insertion_point(field_get:navService.RotateRequest.rollback)
  if (has_rollback()) {
    return rotate_oneof_.rollback_;
  }
  return false;
}
inline void RotateRequest::set_rollback(bool value) {
  if (!has_rollback()) {
    clear_rotate_oneof();
    set_has_rollback();
  }
  rotate_oneof_.rollback_ = value;
  // @@protoc_insertion_point(field_set:navService.RotateRequest.rollback)
}

inline bool RotateRequest::has_rotate_oneof() const {
  return rotate_oneof_case() != ROTATE_ONEOF_NOT_SET;
}
inline void RotateRequest::clear_has_rotate_oneof() {
  _oneof_case_[0] = ROTATE_ONEOF_NOT_SET;
}
inline RotateRequest::RotateOneofCase RotateRequest::rotate_oneof_case() const {
  return RotateRequest::RotateOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RotateResponse

// .navService.StatusCode status_code = 1;
inline void RotateResponse::clear_status_code() {
  status_code_ = 0;
}
inline ::navService::StatusCode RotateResponse::status_code() const {
  // @@protoc_insertion_point(field_get:navService.RotateResponse.status_code)
  return static_cast< ::navService::StatusCode >(status_code_);
}
inline void RotateResponse::set_status_code(::navService::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.RotateResponse.status_code)
}

// -------------------------------------------------------------------

// OnNavEventChangeRequest

// -------------------------------------------------------------------

// MoveEvent

// .navService.StatusCode status_code = 1;
inline void MoveEvent::clear_status_code() {
  status_code_ = 0;
}
inline ::navService::StatusCode MoveEvent::status_code() const {
  // @@protoc_insertion_point(field_get:navService.MoveEvent.status_code)
  return static_cast< ::navService::StatusCode >(status_code_);
}
inline void MoveEvent::set_status_code(::navService::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.MoveEvent.status_code)
}

// -------------------------------------------------------------------

// NavEvent

// .navService.StatusCode status_code = 1;
inline void NavEvent::clear_status_code() {
  status_code_ = 0;
}
inline ::navService::StatusCode NavEvent::status_code() const {
  // @@protoc_insertion_point(field_get:navService.NavEvent.status_code)
  return static_cast< ::navService::StatusCode >(status_code_);
}
inline void NavEvent::set_status_code(::navService::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.NavEvent.status_code)
}

// .navService.NavTarget nav_target = 2;
inline bool NavEvent::has_nav_target() const {
  return this != internal_default_instance() && nav_target_ != nullptr;
}
inline void NavEvent::clear_nav_target() {
  if (GetArenaNoVirtual() == nullptr && nav_target_ != nullptr) {
    delete nav_target_;
  }
  nav_target_ = nullptr;
}
inline const ::navService::NavTarget& NavEvent::nav_target() const {
  const ::navService::NavTarget* p = nav_target_;
  // @@protoc_insertion_point(field_get:navService.NavEvent.nav_target)
  return p != nullptr ? *p : *reinterpret_cast<const ::navService::NavTarget*>(
      &::navService::_NavTarget_default_instance_);
}
inline ::navService::NavTarget* NavEvent::release_nav_target() {
  // @@protoc_insertion_point(field_release:navService.NavEvent.nav_target)
  
  ::navService::NavTarget* temp = nav_target_;
  nav_target_ = nullptr;
  return temp;
}
inline ::navService::NavTarget* NavEvent::mutable_nav_target() {
  
  if (nav_target_ == nullptr) {
    auto* p = CreateMaybeMessage<::navService::NavTarget>(GetArenaNoVirtual());
    nav_target_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navService.NavEvent.nav_target)
  return nav_target_;
}
inline void NavEvent::set_allocated_nav_target(::navService::NavTarget* nav_target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete nav_target_;
  }
  if (nav_target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nav_target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nav_target, submessage_arena);
    }
    
  } else {
    
  }
  nav_target_ = nav_target;
  // @@protoc_insertion_point(field_set_allocated:navService.NavEvent.nav_target)
}

// -------------------------------------------------------------------

// AutoChargeEvent

// .navService.ChargeStatusCode charge_status_code = 1;
inline void AutoChargeEvent::clear_charge_status_code() {
  charge_status_code_ = 0;
}
inline ::navService::ChargeStatusCode AutoChargeEvent::charge_status_code() const {
  // @@protoc_insertion_point(field_get:navService.AutoChargeEvent.charge_status_code)
  return static_cast< ::navService::ChargeStatusCode >(charge_status_code_);
}
inline void AutoChargeEvent::set_charge_status_code(::navService::ChargeStatusCode value) {
  
  charge_status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.AutoChargeEvent.charge_status_code)
}

// -------------------------------------------------------------------

// RotateEvent

// .navService.StatusCode status_code = 1;
inline void RotateEvent::clear_status_code() {
  status_code_ = 0;
}
inline ::navService::StatusCode RotateEvent::status_code() const {
  // @@protoc_insertion_point(field_get:navService.RotateEvent.status_code)
  return static_cast< ::navService::StatusCode >(status_code_);
}
inline void RotateEvent::set_status_code(::navService::StatusCode value) {
  
  status_code_ = value;
  // @@protoc_insertion_point(field_set:navService.RotateEvent.status_code)
}

// -------------------------------------------------------------------

// OnNavEventChangeResponse

// .navService.NavEventType nav_event_type = 1;
inline void OnNavEventChangeResponse::clear_nav_event_type() {
  nav_event_type_ = 0;
}
inline ::navService::NavEventType OnNavEventChangeResponse::nav_event_type() const {
  // @@protoc_insertion_point(field_get:navService.OnNavEventChangeResponse.nav_event_type)
  return static_cast< ::navService::NavEventType >(nav_event_type_);
}
inline void OnNavEventChangeResponse::set_nav_event_type(::navService::NavEventType value) {
  
  nav_event_type_ = value;
  // @@protoc_insertion_point(field_set:navService.OnNavEventChangeResponse.nav_event_type)
}

// .navService.MoveEvent move_event = 2;
inline bool OnNavEventChangeResponse::has_move_event() const {
  return change_oneof_case() == kMoveEvent;
}
inline void OnNavEventChangeResponse::set_has_move_event() {
  _oneof_case_[0] = kMoveEvent;
}
inline void OnNavEventChangeResponse::clear_move_event() {
  if (has_move_event()) {
    delete change_oneof_.move_event_;
    clear_has_change_oneof();
  }
}
inline ::navService::MoveEvent* OnNavEventChangeResponse::release_move_event() {
  // @@protoc_insertion_point(field_release:navService.OnNavEventChangeResponse.move_event)
  if (has_move_event()) {
    clear_has_change_oneof();
      ::navService::MoveEvent* temp = change_oneof_.move_event_;
    change_oneof_.move_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::MoveEvent& OnNavEventChangeResponse::move_event() const {
  // @@protoc_insertion_point(field_get:navService.OnNavEventChangeResponse.move_event)
  return has_move_event()
      ? *change_oneof_.move_event_
      : *reinterpret_cast< ::navService::MoveEvent*>(&::navService::_MoveEvent_default_instance_);
}
inline ::navService::MoveEvent* OnNavEventChangeResponse::mutable_move_event() {
  if (!has_move_event()) {
    clear_change_oneof();
    set_has_move_event();
    change_oneof_.move_event_ = CreateMaybeMessage< ::navService::MoveEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.OnNavEventChangeResponse.move_event)
  return change_oneof_.move_event_;
}

// .navService.NavEvent nav_event = 3;
inline bool OnNavEventChangeResponse::has_nav_event() const {
  return change_oneof_case() == kNavEvent;
}
inline void OnNavEventChangeResponse::set_has_nav_event() {
  _oneof_case_[0] = kNavEvent;
}
inline void OnNavEventChangeResponse::clear_nav_event() {
  if (has_nav_event()) {
    delete change_oneof_.nav_event_;
    clear_has_change_oneof();
  }
}
inline ::navService::NavEvent* OnNavEventChangeResponse::release_nav_event() {
  // @@protoc_insertion_point(field_release:navService.OnNavEventChangeResponse.nav_event)
  if (has_nav_event()) {
    clear_has_change_oneof();
      ::navService::NavEvent* temp = change_oneof_.nav_event_;
    change_oneof_.nav_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::NavEvent& OnNavEventChangeResponse::nav_event() const {
  // @@protoc_insertion_point(field_get:navService.OnNavEventChangeResponse.nav_event)
  return has_nav_event()
      ? *change_oneof_.nav_event_
      : *reinterpret_cast< ::navService::NavEvent*>(&::navService::_NavEvent_default_instance_);
}
inline ::navService::NavEvent* OnNavEventChangeResponse::mutable_nav_event() {
  if (!has_nav_event()) {
    clear_change_oneof();
    set_has_nav_event();
    change_oneof_.nav_event_ = CreateMaybeMessage< ::navService::NavEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.OnNavEventChangeResponse.nav_event)
  return change_oneof_.nav_event_;
}

// .navService.RotateEvent rotate_event = 4;
inline bool OnNavEventChangeResponse::has_rotate_event() const {
  return change_oneof_case() == kRotateEvent;
}
inline void OnNavEventChangeResponse::set_has_rotate_event() {
  _oneof_case_[0] = kRotateEvent;
}
inline void OnNavEventChangeResponse::clear_rotate_event() {
  if (has_rotate_event()) {
    delete change_oneof_.rotate_event_;
    clear_has_change_oneof();
  }
}
inline ::navService::RotateEvent* OnNavEventChangeResponse::release_rotate_event() {
  // @@protoc_insertion_point(field_release:navService.OnNavEventChangeResponse.rotate_event)
  if (has_rotate_event()) {
    clear_has_change_oneof();
      ::navService::RotateEvent* temp = change_oneof_.rotate_event_;
    change_oneof_.rotate_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::RotateEvent& OnNavEventChangeResponse::rotate_event() const {
  // @@protoc_insertion_point(field_get:navService.OnNavEventChangeResponse.rotate_event)
  return has_rotate_event()
      ? *change_oneof_.rotate_event_
      : *reinterpret_cast< ::navService::RotateEvent*>(&::navService::_RotateEvent_default_instance_);
}
inline ::navService::RotateEvent* OnNavEventChangeResponse::mutable_rotate_event() {
  if (!has_rotate_event()) {
    clear_change_oneof();
    set_has_rotate_event();
    change_oneof_.rotate_event_ = CreateMaybeMessage< ::navService::RotateEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.OnNavEventChangeResponse.rotate_event)
  return change_oneof_.rotate_event_;
}

// .navService.AutoChargeEvent auto_charge_event = 5;
inline bool OnNavEventChangeResponse::has_auto_charge_event() const {
  return change_oneof_case() == kAutoChargeEvent;
}
inline void OnNavEventChangeResponse::set_has_auto_charge_event() {
  _oneof_case_[0] = kAutoChargeEvent;
}
inline void OnNavEventChangeResponse::clear_auto_charge_event() {
  if (has_auto_charge_event()) {
    delete change_oneof_.auto_charge_event_;
    clear_has_change_oneof();
  }
}
inline ::navService::AutoChargeEvent* OnNavEventChangeResponse::release_auto_charge_event() {
  // @@protoc_insertion_point(field_release:navService.OnNavEventChangeResponse.auto_charge_event)
  if (has_auto_charge_event()) {
    clear_has_change_oneof();
      ::navService::AutoChargeEvent* temp = change_oneof_.auto_charge_event_;
    change_oneof_.auto_charge_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::navService::AutoChargeEvent& OnNavEventChangeResponse::auto_charge_event() const {
  // @@protoc_insertion_point(field_get:navService.OnNavEventChangeResponse.auto_charge_event)
  return has_auto_charge_event()
      ? *change_oneof_.auto_charge_event_
      : *reinterpret_cast< ::navService::AutoChargeEvent*>(&::navService::_AutoChargeEvent_default_instance_);
}
inline ::navService::AutoChargeEvent* OnNavEventChangeResponse::mutable_auto_charge_event() {
  if (!has_auto_charge_event()) {
    clear_change_oneof();
    set_has_auto_charge_event();
    change_oneof_.auto_charge_event_ = CreateMaybeMessage< ::navService::AutoChargeEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:navService.OnNavEventChangeResponse.auto_charge_event)
  return change_oneof_.auto_charge_event_;
}

inline bool OnNavEventChangeResponse::has_change_oneof() const {
  return change_oneof_case() != CHANGE_ONEOF_NOT_SET;
}
inline void OnNavEventChangeResponse::clear_has_change_oneof() {
  _oneof_case_[0] = CHANGE_ONEOF_NOT_SET;
}
inline OnNavEventChangeResponse::ChangeOneofCase OnNavEventChangeResponse::change_oneof_case() const {
  return OnNavEventChangeResponse::ChangeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Route

// string id = 1;
inline void Route::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Route::id() const {
  // @@protoc_insertion_point(field_get:navService.Route.id)
  return id_.GetNoArena();
}
inline void Route::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navService.Route.id)
}
inline void Route::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navService.Route.id)
}
inline void Route::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navService.Route.id)
}
inline void Route::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navService.Route.id)
}
inline std::string* Route::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:navService.Route.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Route::release_id() {
  // @@protoc_insertion_point(field_release:navService.Route.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Route::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:navService.Route.id)
}

// string name = 2;
inline void Route::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Route::name() const {
  // @@protoc_insertion_point(field_get:navService.Route.name)
  return name_.GetNoArena();
}
inline void Route::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navService.Route.name)
}
inline void Route::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navService.Route.name)
}
inline void Route::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navService.Route.name)
}
inline void Route::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navService.Route.name)
}
inline std::string* Route::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:navService.Route.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Route::release_name() {
  // @@protoc_insertion_point(field_release:navService.Route.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Route::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:navService.Route.name)
}

// bool is_active = 3;
inline void Route::clear_is_active() {
  is_active_ = false;
}
inline bool Route::is_active() const {
  // @@protoc_insertion_point(field_get:navService.Route.is_active)
  return is_active_;
}
inline void Route::set_is_active(bool value) {
  
  is_active_ = value;
  // @@protoc_insertion_point(field_set:navService.Route.is_active)
}

// repeated .navService.RoutePoint route_points = 4;
inline int Route::route_points_size() const {
  return route_points_.size();
}
inline void Route::clear_route_points() {
  route_points_.Clear();
}
inline ::navService::RoutePoint* Route::mutable_route_points(int index) {
  // @@protoc_insertion_point(field_mutable:navService.Route.route_points)
  return route_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::RoutePoint >*
Route::mutable_route_points() {
  // @@protoc_insertion_point(field_mutable_list:navService.Route.route_points)
  return &route_points_;
}
inline const ::navService::RoutePoint& Route::route_points(int index) const {
  // @@protoc_insertion_point(field_get:navService.Route.route_points)
  return route_points_.Get(index);
}
inline ::navService::RoutePoint* Route::add_route_points() {
  // @@protoc_insertion_point(field_add:navService.Route.route_points)
  return route_points_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::RoutePoint >&
Route::route_points() const {
  // @@protoc_insertion_point(field_list:navService.Route.route_points)
  return route_points_;
}

// -------------------------------------------------------------------

// RoutePoint

// string name = 1;
inline void RoutePoint::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoutePoint::name() const {
  // @@protoc_insertion_point(field_get:navService.RoutePoint.name)
  return name_.GetNoArena();
}
inline void RoutePoint::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navService.RoutePoint.name)
}
inline void RoutePoint::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navService.RoutePoint.name)
}
inline void RoutePoint::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navService.RoutePoint.name)
}
inline void RoutePoint::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navService.RoutePoint.name)
}
inline std::string* RoutePoint::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:navService.RoutePoint.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoutePoint::release_name() {
  // @@protoc_insertion_point(field_release:navService.RoutePoint.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoutePoint::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:navService.RoutePoint.name)
}

// uint32 rotate = 2;
inline void RoutePoint::clear_rotate() {
  rotate_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RoutePoint::rotate() const {
  // @@protoc_insertion_point(field_get:navService.RoutePoint.rotate)
  return rotate_;
}
inline void RoutePoint::set_rotate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  rotate_ = value;
  // @@protoc_insertion_point(field_set:navService.RoutePoint.rotate)
}

// -------------------------------------------------------------------

// NewRouteRequest

// .navService.Route route = 1;
inline bool NewRouteRequest::has_route() const {
  return this != internal_default_instance() && route_ != nullptr;
}
inline void NewRouteRequest::clear_route() {
  if (GetArenaNoVirtual() == nullptr && route_ != nullptr) {
    delete route_;
  }
  route_ = nullptr;
}
inline const ::navService::Route& NewRouteRequest::route() const {
  const ::navService::Route* p = route_;
  // @@protoc_insertion_point(field_get:navService.NewRouteRequest.route)
  return p != nullptr ? *p : *reinterpret_cast<const ::navService::Route*>(
      &::navService::_Route_default_instance_);
}
inline ::navService::Route* NewRouteRequest::release_route() {
  // @@protoc_insertion_point(field_release:navService.NewRouteRequest.route)
  
  ::navService::Route* temp = route_;
  route_ = nullptr;
  return temp;
}
inline ::navService::Route* NewRouteRequest::mutable_route() {
  
  if (route_ == nullptr) {
    auto* p = CreateMaybeMessage<::navService::Route>(GetArenaNoVirtual());
    route_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navService.NewRouteRequest.route)
  return route_;
}
inline void NewRouteRequest::set_allocated_route(::navService::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete route_;
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  route_ = route;
  // @@protoc_insertion_point(field_set_allocated:navService.NewRouteRequest.route)
}

// -------------------------------------------------------------------

// NewRouteResponse

// .navService.Route route = 1;
inline bool NewRouteResponse::has_route() const {
  return this != internal_default_instance() && route_ != nullptr;
}
inline void NewRouteResponse::clear_route() {
  if (GetArenaNoVirtual() == nullptr && route_ != nullptr) {
    delete route_;
  }
  route_ = nullptr;
}
inline const ::navService::Route& NewRouteResponse::route() const {
  const ::navService::Route* p = route_;
  // @@protoc_insertion_point(field_get:navService.NewRouteResponse.route)
  return p != nullptr ? *p : *reinterpret_cast<const ::navService::Route*>(
      &::navService::_Route_default_instance_);
}
inline ::navService::Route* NewRouteResponse::release_route() {
  // @@protoc_insertion_point(field_release:navService.NewRouteResponse.route)
  
  ::navService::Route* temp = route_;
  route_ = nullptr;
  return temp;
}
inline ::navService::Route* NewRouteResponse::mutable_route() {
  
  if (route_ == nullptr) {
    auto* p = CreateMaybeMessage<::navService::Route>(GetArenaNoVirtual());
    route_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navService.NewRouteResponse.route)
  return route_;
}
inline void NewRouteResponse::set_allocated_route(::navService::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete route_;
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  route_ = route;
  // @@protoc_insertion_point(field_set_allocated:navService.NewRouteResponse.route)
}

// -------------------------------------------------------------------

// ListRoutesRequest

// -------------------------------------------------------------------

// ListRoutesResponse

// repeated .navService.Route routes = 1;
inline int ListRoutesResponse::routes_size() const {
  return routes_.size();
}
inline void ListRoutesResponse::clear_routes() {
  routes_.Clear();
}
inline ::navService::Route* ListRoutesResponse::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:navService.ListRoutesResponse.routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::Route >*
ListRoutesResponse::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:navService.ListRoutesResponse.routes)
  return &routes_;
}
inline const ::navService::Route& ListRoutesResponse::routes(int index) const {
  // @@protoc_insertion_point(field_get:navService.ListRoutesResponse.routes)
  return routes_.Get(index);
}
inline ::navService::Route* ListRoutesResponse::add_routes() {
  // @@protoc_insertion_point(field_add:navService.ListRoutesResponse.routes)
  return routes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::navService::Route >&
ListRoutesResponse::routes() const {
  // @@protoc_insertion_point(field_list:navService.ListRoutesResponse.routes)
  return routes_;
}

// -------------------------------------------------------------------

// GetRouteRequest

// string id = 1;
inline void GetRouteRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GetRouteRequest::id() const {
  // @@protoc_insertion_point(field_get:navService.GetRouteRequest.id)
  return id_.GetNoArena();
}
inline void GetRouteRequest::set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:navService.GetRouteRequest.id)
}
inline void GetRouteRequest::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:navService.GetRouteRequest.id)
}
inline void GetRouteRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:navService.GetRouteRequest.id)
}
inline void GetRouteRequest::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:navService.GetRouteRequest.id)
}
inline std::string* GetRouteRequest::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:navService.GetRouteRequest.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetRouteRequest::release_id() {
  // @@protoc_insertion_point(field_release:navService.GetRouteRequest.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetRouteRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:navService.GetRouteRequest.id)
}

// -------------------------------------------------------------------

// GetRouteResponse

// .navService.Route route = 1;
inline bool GetRouteResponse::has_route() const {
  return this != internal_default_instance() && route_ != nullptr;
}
inline void GetRouteResponse::clear_route() {
  if (GetArenaNoVirtual() == nullptr && route_ != nullptr) {
    delete route_;
  }
  route_ = nullptr;
}
inline const ::navService::Route& GetRouteResponse::route() const {
  const ::navService::Route* p = route_;
  // @@protoc_insertion_point(field_get:navService.GetRouteResponse.route)
  return p != nullptr ? *p : *reinterpret_cast<const ::navService::Route*>(
      &::navService::_Route_default_instance_);
}
inline ::navService::Route* GetRouteResponse::release_route() {
  // @@protoc_insertion_point(field_release:navService.GetRouteResponse.route)
  
  ::navService::Route* temp = route_;
  route_ = nullptr;
  return temp;
}
inline ::navService::Route* GetRouteResponse::mutable_route() {
  
  if (route_ == nullptr) {
    auto* p = CreateMaybeMessage<::navService::Route>(GetArenaNoVirtual());
    route_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navService.GetRouteResponse.route)
  return route_;
}
inline void GetRouteResponse::set_allocated_route(::navService::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete route_;
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  route_ = route;
  // @@protoc_insertion_point(field_set_allocated:navService.GetRouteResponse.route)
}

// -------------------------------------------------------------------

// UpdateRouteRequest

// .navService.Route route = 1;
inline bool UpdateRouteRequest::has_route() const {
  return this != internal_default_instance() && route_ != nullptr;
}
inline void UpdateRouteRequest::clear_route() {
  if (GetArenaNoVirtual() == nullptr && route_ != nullptr) {
    delete route_;
  }
  route_ = nullptr;
}
inline const ::navService::Route& UpdateRouteRequest::route() const {
  const ::navService::Route* p = route_;
  // @@protoc_insertion_point(field_get:navService.UpdateRouteRequest.route)
  return p != nullptr ? *p : *reinterpret_cast<const ::navService::Route*>(
      &::navService::_Route_default_instance_);
}
inline ::navService::Route* UpdateRouteRequest::release_route() {
  // @@protoc_insertion_point(field_release:navService.UpdateRouteRequest.route)
  
  ::navService::Route* temp = route_;
  route_ = nullptr;
  return temp;
}
inline ::navService::Route* UpdateRouteRequest::mutable_route() {
  
  if (route_ == nullptr) {
    auto* p = CreateMaybeMessage<::navService::Route>(GetArenaNoVirtual());
    route_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navService.UpdateRouteRequest.route)
  return route_;
}
inline void UpdateRouteRequest::set_allocated_route(::navService::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete route_;
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  route_ = route;
  // @@protoc_insertion_point(field_set_allocated:navService.UpdateRouteRequest.route)
}

// -------------------------------------------------------------------

// UpdateRouteResponse

// .navService.Route route = 1;
inline bool UpdateRouteResponse::has_route() const {
  return this != internal_default_instance() && route_ != nullptr;
}
inline void UpdateRouteResponse::clear_route() {
  if (GetArenaNoVirtual() == nullptr && route_ != nullptr) {
    delete route_;
  }
  route_ = nullptr;
}
inline const ::navService::Route& UpdateRouteResponse::route() const {
  const ::navService::Route* p = route_;
  // @@protoc_insertion_point(field_get:navService.UpdateRouteResponse.route)
  return p != nullptr ? *p : *reinterpret_cast<const ::navService::Route*>(
      &::navService::_Route_default_instance_);
}
inline ::navService::Route* UpdateRouteResponse::release_route() {
  // @@protoc_insertion_point(field_release:navService.UpdateRouteResponse.route)
  
  ::navService::Route* temp = route_;
  route_ = nullptr;
  return temp;
}
inline ::navService::Route* UpdateRouteResponse::mutable_route() {
  
  if (route_ == nullptr) {
    auto* p = CreateMaybeMessage<::navService::Route>(GetArenaNoVirtual());
    route_ = p;
  }
  // @@protoc_insertion_point(field_mutable:navService.UpdateRouteResponse.route)
  return route_;
}
inline void UpdateRouteResponse::set_allocated_route(::navService::Route* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete route_;
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  route_ = route;
  // @@protoc_insertion_point(field_set_allocated:navService.UpdateRouteResponse.route)
}

// -------------------------------------------------------------------

// DeleteRoutesRequest

// repeated string routes_id = 1;
inline int DeleteRoutesRequest::routes_id_size() const {
  return routes_id_.size();
}
inline void DeleteRoutesRequest::clear_routes_id() {
  routes_id_.Clear();
}
inline const std::string& DeleteRoutesRequest::routes_id(int index) const {
  // @@protoc_insertion_point(field_get:navService.DeleteRoutesRequest.routes_id)
  return routes_id_.Get(index);
}
inline std::string* DeleteRoutesRequest::mutable_routes_id(int index) {
  // @@protoc_insertion_point(field_mutable:navService.DeleteRoutesRequest.routes_id)
  return routes_id_.Mutable(index);
}
inline void DeleteRoutesRequest::set_routes_id(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:navService.DeleteRoutesRequest.routes_id)
  routes_id_.Mutable(index)->assign(value);
}
inline void DeleteRoutesRequest::set_routes_id(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:navService.DeleteRoutesRequest.routes_id)
  routes_id_.Mutable(index)->assign(std::move(value));
}
inline void DeleteRoutesRequest::set_routes_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  routes_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:navService.DeleteRoutesRequest.routes_id)
}
inline void DeleteRoutesRequest::set_routes_id(int index, const char* value, size_t size) {
  routes_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:navService.DeleteRoutesRequest.routes_id)
}
inline std::string* DeleteRoutesRequest::add_routes_id() {
  // @@protoc_insertion_point(field_add_mutable:navService.DeleteRoutesRequest.routes_id)
  return routes_id_.Add();
}
inline void DeleteRoutesRequest::add_routes_id(const std::string& value) {
  routes_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:navService.DeleteRoutesRequest.routes_id)
}
inline void DeleteRoutesRequest::add_routes_id(std::string&& value) {
  routes_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:navService.DeleteRoutesRequest.routes_id)
}
inline void DeleteRoutesRequest::add_routes_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  routes_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:navService.DeleteRoutesRequest.routes_id)
}
inline void DeleteRoutesRequest::add_routes_id(const char* value, size_t size) {
  routes_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:navService.DeleteRoutesRequest.routes_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeleteRoutesRequest::routes_id() const {
  // @@protoc_insertion_point(field_list:navService.DeleteRoutesRequest.routes_id)
  return routes_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeleteRoutesRequest::mutable_routes_id() {
  // @@protoc_insertion_point(field_mutable_list:navService.DeleteRoutesRequest.routes_id)
  return &routes_id_;
}

// -------------------------------------------------------------------

// DeleteRoutesResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace navService

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::navService::StatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navService::StatusCode>() {
  return ::navService::StatusCode_descriptor();
}
template <> struct is_proto_enum< ::navService::MoveDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navService::MoveDirection>() {
  return ::navService::MoveDirection_descriptor();
}
template <> struct is_proto_enum< ::navService::RoamingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navService::RoamingType>() {
  return ::navService::RoamingType_descriptor();
}
template <> struct is_proto_enum< ::navService::ChargeStatusCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navService::ChargeStatusCode>() {
  return ::navService::ChargeStatusCode_descriptor();
}
template <> struct is_proto_enum< ::navService::NavEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::navService::NavEventType>() {
  return ::navService::NavEventType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_nav_2eproto
