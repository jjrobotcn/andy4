// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: facedetect.proto

package faceRecognition

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Gender int32

const (
	Gender_GENDER_UNKNOWN Gender = 0
	Gender_GENDER_MALE    Gender = 1
	Gender_GENDER_FEMALE  Gender = 2
)

var Gender_name = map[int32]string{
	0: "GENDER_UNKNOWN",
	1: "GENDER_MALE",
	2: "GENDER_FEMALE",
}

var Gender_value = map[string]int32{
	"GENDER_UNKNOWN": 0,
	"GENDER_MALE":    1,
	"GENDER_FEMALE":  2,
}

func (x Gender) String() string {
	return proto.EnumName(Gender_name, int32(x))
}

func (Gender) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{0}
}

//
//人脸中心位置坐标
//坐标由左上角至右下角
//(0,0)   --- (100,0) x
//|
//|
//(0,100) --- (100,100)
//y
type FacePosition struct {
	X                    uint32   `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    uint32   `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FacePosition) Reset()         { *m = FacePosition{} }
func (m *FacePosition) String() string { return proto.CompactTextString(m) }
func (*FacePosition) ProtoMessage()    {}
func (*FacePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{0}
}
func (m *FacePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FacePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FacePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FacePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacePosition.Merge(m, src)
}
func (m *FacePosition) XXX_Size() int {
	return m.Size()
}
func (m *FacePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_FacePosition.DiscardUnknown(m)
}

var xxx_messageInfo_FacePosition proto.InternalMessageInfo

func (m *FacePosition) GetX() uint32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *FacePosition) GetY() uint32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type FromImageRequest struct {
	// 检测图片内容
	Image []byte `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// 检测性别
	WithGender bool `protobuf:"varint,2,opt,name=with_gender,json=withGender,proto3" json:"with_gender,omitempty"`
	// 检测年龄
	WithAge bool `protobuf:"varint,3,opt,name=with_age,json=withAge,proto3" json:"with_age,omitempty"`
	// 检测人脸位置
	WithPosition bool `protobuf:"varint,4,opt,name=with_position,json=withPosition,proto3" json:"with_position,omitempty"`
	// 返回人脸图片戳宽度
	WithFaceCropWidth    bool     `protobuf:"varint,5,opt,name=with_face_crop_width,json=withFaceCropWidth,proto3" json:"with_face_crop_width,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FromImageRequest) Reset()         { *m = FromImageRequest{} }
func (m *FromImageRequest) String() string { return proto.CompactTextString(m) }
func (*FromImageRequest) ProtoMessage()    {}
func (*FromImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{1}
}
func (m *FromImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FromImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FromImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FromImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FromImageRequest.Merge(m, src)
}
func (m *FromImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *FromImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FromImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FromImageRequest proto.InternalMessageInfo

func (m *FromImageRequest) GetImage() []byte {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *FromImageRequest) GetWithGender() bool {
	if m != nil {
		return m.WithGender
	}
	return false
}

func (m *FromImageRequest) GetWithAge() bool {
	if m != nil {
		return m.WithAge
	}
	return false
}

func (m *FromImageRequest) GetWithPosition() bool {
	if m != nil {
		return m.WithPosition
	}
	return false
}

func (m *FromImageRequest) GetWithFaceCropWidth() bool {
	if m != nil {
		return m.WithFaceCropWidth
	}
	return false
}

type FromImageResponse struct {
	// 检测人脸图片戳列表
	FaceCrops [][]byte `protobuf:"bytes,1,rep,name=face_crops,json=faceCrops,proto3" json:"face_crops,omitempty"`
	// 检测人脸性别列表
	Genders []Gender `protobuf:"varint,2,rep,packed,name=genders,proto3,enum=faceRecognition.Gender" json:"genders,omitempty"`
	// 检测人脸年龄列表
	Ages []int32 `protobuf:"varint,3,rep,packed,name=ages,proto3" json:"ages,omitempty"`
	// 检测人脸坐标列表
	Positions []*FacePosition `protobuf:"bytes,4,rep,name=positions,proto3" json:"positions,omitempty"`
	// 人脸图片戳宽度列表
	FaceCropWidths       []uint32 `protobuf:"varint,5,rep,packed,name=face_crop_widths,json=faceCropWidths,proto3" json:"face_crop_widths,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FromImageResponse) Reset()         { *m = FromImageResponse{} }
func (m *FromImageResponse) String() string { return proto.CompactTextString(m) }
func (*FromImageResponse) ProtoMessage()    {}
func (*FromImageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{2}
}
func (m *FromImageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FromImageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FromImageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FromImageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FromImageResponse.Merge(m, src)
}
func (m *FromImageResponse) XXX_Size() int {
	return m.Size()
}
func (m *FromImageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FromImageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FromImageResponse proto.InternalMessageInfo

func (m *FromImageResponse) GetFaceCrops() [][]byte {
	if m != nil {
		return m.FaceCrops
	}
	return nil
}

func (m *FromImageResponse) GetGenders() []Gender {
	if m != nil {
		return m.Genders
	}
	return nil
}

func (m *FromImageResponse) GetAges() []int32 {
	if m != nil {
		return m.Ages
	}
	return nil
}

func (m *FromImageResponse) GetPositions() []*FacePosition {
	if m != nil {
		return m.Positions
	}
	return nil
}

func (m *FromImageResponse) GetFaceCropWidths() []uint32 {
	if m != nil {
		return m.FaceCropWidths
	}
	return nil
}

type OnFaceDetectRequest struct {
	// 检测间隔时间(毫秒)
	IntervalMillisecond uint32 `protobuf:"varint,1,opt,name=interval_millisecond,json=intervalMillisecond,proto3" json:"interval_millisecond,omitempty"`
	// 检测性别
	WithGender bool `protobuf:"varint,2,opt,name=with_gender,json=withGender,proto3" json:"with_gender,omitempty"`
	// 检测年龄
	WithAge bool `protobuf:"varint,3,opt,name=with_age,json=withAge,proto3" json:"with_age,omitempty"`
	// 检测人脸位置
	WithPosition bool `protobuf:"varint,4,opt,name=with_position,json=withPosition,proto3" json:"with_position,omitempty"`
	// 返回人脸图片戳宽度
	WithFaceCropWidth    bool     `protobuf:"varint,5,opt,name=with_face_crop_width,json=withFaceCropWidth,proto3" json:"with_face_crop_width,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnFaceDetectRequest) Reset()         { *m = OnFaceDetectRequest{} }
func (m *OnFaceDetectRequest) String() string { return proto.CompactTextString(m) }
func (*OnFaceDetectRequest) ProtoMessage()    {}
func (*OnFaceDetectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{3}
}
func (m *OnFaceDetectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnFaceDetectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnFaceDetectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnFaceDetectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnFaceDetectRequest.Merge(m, src)
}
func (m *OnFaceDetectRequest) XXX_Size() int {
	return m.Size()
}
func (m *OnFaceDetectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnFaceDetectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnFaceDetectRequest proto.InternalMessageInfo

func (m *OnFaceDetectRequest) GetIntervalMillisecond() uint32 {
	if m != nil {
		return m.IntervalMillisecond
	}
	return 0
}

func (m *OnFaceDetectRequest) GetWithGender() bool {
	if m != nil {
		return m.WithGender
	}
	return false
}

func (m *OnFaceDetectRequest) GetWithAge() bool {
	if m != nil {
		return m.WithAge
	}
	return false
}

func (m *OnFaceDetectRequest) GetWithPosition() bool {
	if m != nil {
		return m.WithPosition
	}
	return false
}

func (m *OnFaceDetectRequest) GetWithFaceCropWidth() bool {
	if m != nil {
		return m.WithFaceCropWidth
	}
	return false
}

type OnFaceDetectResponse struct {
	// 检测人脸图片戳列表
	FaceCrops [][]byte `protobuf:"bytes,1,rep,name=face_crops,json=faceCrops,proto3" json:"face_crops,omitempty"`
	// 检测人脸性别列表
	Genders []Gender `protobuf:"varint,2,rep,packed,name=genders,proto3,enum=faceRecognition.Gender" json:"genders,omitempty"`
	// 检测人脸年龄列表
	Ages []int32 `protobuf:"varint,3,rep,packed,name=ages,proto3" json:"ages,omitempty"`
	// 检测人脸坐标列表
	Positions []*FacePosition `protobuf:"bytes,4,rep,name=positions,proto3" json:"positions,omitempty"`
	// 人脸图片戳宽度列表
	FaceCropWidths       []uint32 `protobuf:"varint,5,rep,packed,name=face_crop_widths,json=faceCropWidths,proto3" json:"face_crop_widths,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnFaceDetectResponse) Reset()         { *m = OnFaceDetectResponse{} }
func (m *OnFaceDetectResponse) String() string { return proto.CompactTextString(m) }
func (*OnFaceDetectResponse) ProtoMessage()    {}
func (*OnFaceDetectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{4}
}
func (m *OnFaceDetectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnFaceDetectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnFaceDetectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnFaceDetectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnFaceDetectResponse.Merge(m, src)
}
func (m *OnFaceDetectResponse) XXX_Size() int {
	return m.Size()
}
func (m *OnFaceDetectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OnFaceDetectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OnFaceDetectResponse proto.InternalMessageInfo

func (m *OnFaceDetectResponse) GetFaceCrops() [][]byte {
	if m != nil {
		return m.FaceCrops
	}
	return nil
}

func (m *OnFaceDetectResponse) GetGenders() []Gender {
	if m != nil {
		return m.Genders
	}
	return nil
}

func (m *OnFaceDetectResponse) GetAges() []int32 {
	if m != nil {
		return m.Ages
	}
	return nil
}

func (m *OnFaceDetectResponse) GetPositions() []*FacePosition {
	if m != nil {
		return m.Positions
	}
	return nil
}

func (m *OnFaceDetectResponse) GetFaceCropWidths() []uint32 {
	if m != nil {
		return m.FaceCropWidths
	}
	return nil
}

type OnFaceSetFaceDetectRequest struct {
	// FaceSet.id
	FaceSetId string `protobuf:"bytes,1,opt,name=face_set_id,json=faceSetId,proto3" json:"face_set_id,omitempty"`
	// 返回结果是否包含人脸图片戳
	// false时Response中face数据将为空
	WithFaceCrop bool `protobuf:"varint,2,opt,name=with_face_crop,json=withFaceCrop,proto3" json:"with_face_crop,omitempty"`
	// 检测性别
	WithGender bool `protobuf:"varint,3,opt,name=with_gender,json=withGender,proto3" json:"with_gender,omitempty"`
	// 检测年龄
	WithAge bool `protobuf:"varint,4,opt,name=with_age,json=withAge,proto3" json:"with_age,omitempty"`
	// 检测人脸位置
	WithPosition bool `protobuf:"varint,5,opt,name=with_position,json=withPosition,proto3" json:"with_position,omitempty"`
	// 检测间隔时间(毫秒)
	IntervalMillisecond uint32 `protobuf:"varint,6,opt,name=interval_millisecond,json=intervalMillisecond,proto3" json:"interval_millisecond,omitempty"`
	// 最低信任值，小于该值的数据将无效并过滤 [0, 1]
	ConfidenceMin float32 `protobuf:"fixed32,7,opt,name=confidence_min,json=confidenceMin,proto3" json:"confidence_min,omitempty"`
	// 返回人脸图片戳宽度
	WithFaceCropWidth    bool     `protobuf:"varint,8,opt,name=with_face_crop_width,json=withFaceCropWidth,proto3" json:"with_face_crop_width,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnFaceSetFaceDetectRequest) Reset()         { *m = OnFaceSetFaceDetectRequest{} }
func (m *OnFaceSetFaceDetectRequest) String() string { return proto.CompactTextString(m) }
func (*OnFaceSetFaceDetectRequest) ProtoMessage()    {}
func (*OnFaceSetFaceDetectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{5}
}
func (m *OnFaceSetFaceDetectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnFaceSetFaceDetectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnFaceSetFaceDetectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnFaceSetFaceDetectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnFaceSetFaceDetectRequest.Merge(m, src)
}
func (m *OnFaceSetFaceDetectRequest) XXX_Size() int {
	return m.Size()
}
func (m *OnFaceSetFaceDetectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnFaceSetFaceDetectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnFaceSetFaceDetectRequest proto.InternalMessageInfo

func (m *OnFaceSetFaceDetectRequest) GetFaceSetId() string {
	if m != nil {
		return m.FaceSetId
	}
	return ""
}

func (m *OnFaceSetFaceDetectRequest) GetWithFaceCrop() bool {
	if m != nil {
		return m.WithFaceCrop
	}
	return false
}

func (m *OnFaceSetFaceDetectRequest) GetWithGender() bool {
	if m != nil {
		return m.WithGender
	}
	return false
}

func (m *OnFaceSetFaceDetectRequest) GetWithAge() bool {
	if m != nil {
		return m.WithAge
	}
	return false
}

func (m *OnFaceSetFaceDetectRequest) GetWithPosition() bool {
	if m != nil {
		return m.WithPosition
	}
	return false
}

func (m *OnFaceSetFaceDetectRequest) GetIntervalMillisecond() uint32 {
	if m != nil {
		return m.IntervalMillisecond
	}
	return 0
}

func (m *OnFaceSetFaceDetectRequest) GetConfidenceMin() float32 {
	if m != nil {
		return m.ConfidenceMin
	}
	return 0
}

func (m *OnFaceSetFaceDetectRequest) GetWithFaceCropWidth() bool {
	if m != nil {
		return m.WithFaceCropWidth
	}
	return false
}

type OnFaceSetFaceDetectResponse struct {
	// 匹配结果信任值列表 [0, 1.0]
	Confidences []float32 `protobuf:"fixed32,1,rep,packed,name=confidences,proto3" json:"confidences,omitempty"`
	// 检测人脸token列表
	FaceTokens []string `protobuf:"bytes,2,rep,name=face_tokens,json=faceTokens,proto3" json:"face_tokens,omitempty"`
	// 检测人脸图片戳列表
	FaceCrops [][]byte `protobuf:"bytes,3,rep,name=face_crops,json=faceCrops,proto3" json:"face_crops,omitempty"`
	// 检测人脸性别列表
	Genders []Gender `protobuf:"varint,4,rep,packed,name=genders,proto3,enum=faceRecognition.Gender" json:"genders,omitempty"`
	// 检测人脸年龄列表
	Ages []int32 `protobuf:"varint,5,rep,packed,name=ages,proto3" json:"ages,omitempty"`
	// 检测人脸坐标列表
	Positions []*FacePosition `protobuf:"bytes,6,rep,name=positions,proto3" json:"positions,omitempty"`
	// 人脸图片戳宽度列表
	FaceCropWidths       []uint32 `protobuf:"varint,7,rep,packed,name=face_crop_widths,json=faceCropWidths,proto3" json:"face_crop_widths,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnFaceSetFaceDetectResponse) Reset()         { *m = OnFaceSetFaceDetectResponse{} }
func (m *OnFaceSetFaceDetectResponse) String() string { return proto.CompactTextString(m) }
func (*OnFaceSetFaceDetectResponse) ProtoMessage()    {}
func (*OnFaceSetFaceDetectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5314bd1755b5a080, []int{6}
}
func (m *OnFaceSetFaceDetectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnFaceSetFaceDetectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnFaceSetFaceDetectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnFaceSetFaceDetectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnFaceSetFaceDetectResponse.Merge(m, src)
}
func (m *OnFaceSetFaceDetectResponse) XXX_Size() int {
	return m.Size()
}
func (m *OnFaceSetFaceDetectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OnFaceSetFaceDetectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OnFaceSetFaceDetectResponse proto.InternalMessageInfo

func (m *OnFaceSetFaceDetectResponse) GetConfidences() []float32 {
	if m != nil {
		return m.Confidences
	}
	return nil
}

func (m *OnFaceSetFaceDetectResponse) GetFaceTokens() []string {
	if m != nil {
		return m.FaceTokens
	}
	return nil
}

func (m *OnFaceSetFaceDetectResponse) GetFaceCrops() [][]byte {
	if m != nil {
		return m.FaceCrops
	}
	return nil
}

func (m *OnFaceSetFaceDetectResponse) GetGenders() []Gender {
	if m != nil {
		return m.Genders
	}
	return nil
}

func (m *OnFaceSetFaceDetectResponse) GetAges() []int32 {
	if m != nil {
		return m.Ages
	}
	return nil
}

func (m *OnFaceSetFaceDetectResponse) GetPositions() []*FacePosition {
	if m != nil {
		return m.Positions
	}
	return nil
}

func (m *OnFaceSetFaceDetectResponse) GetFaceCropWidths() []uint32 {
	if m != nil {
		return m.FaceCropWidths
	}
	return nil
}

func init() {
	proto.RegisterEnum("faceRecognition.Gender", Gender_name, Gender_value)
	proto.RegisterType((*FacePosition)(nil), "faceRecognition.FacePosition")
	proto.RegisterType((*FromImageRequest)(nil), "faceRecognition.FromImageRequest")
	proto.RegisterType((*FromImageResponse)(nil), "faceRecognition.FromImageResponse")
	proto.RegisterType((*OnFaceDetectRequest)(nil), "faceRecognition.OnFaceDetectRequest")
	proto.RegisterType((*OnFaceDetectResponse)(nil), "faceRecognition.OnFaceDetectResponse")
	proto.RegisterType((*OnFaceSetFaceDetectRequest)(nil), "faceRecognition.OnFaceSetFaceDetectRequest")
	proto.RegisterType((*OnFaceSetFaceDetectResponse)(nil), "faceRecognition.OnFaceSetFaceDetectResponse")
}

func init() { proto.RegisterFile("facedetect.proto", fileDescriptor_5314bd1755b5a080) }

var fileDescriptor_5314bd1755b5a080 = []byte{
	// 741 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0x4b, 0x6f, 0xd3, 0x40,
	0x10, 0x66, 0xed, 0x3c, 0x9a, 0x89, 0x93, 0xa6, 0xdb, 0x48, 0x98, 0x40, 0x83, 0x71, 0x5b, 0xc9,
	0xa4, 0xd0, 0xd0, 0xf4, 0x06, 0x17, 0x0a, 0x4d, 0xab, 0x0a, 0x9a, 0x22, 0x17, 0xd4, 0xa3, 0x65,
	0x9c, 0x4d, 0x6a, 0x91, 0x78, 0x43, 0x6c, 0xfa, 0x38, 0x70, 0xe1, 0xc6, 0x99, 0x1f, 0xc1, 0x89,
	0x3f, 0xc0, 0x8d, 0x1b, 0x27, 0x84, 0xc4, 0x8d, 0x53, 0x55, 0xf8, 0x21, 0x68, 0x77, 0x9d, 0xf7,
	0xa3, 0x20, 0x71, 0x40, 0xdc, 0xb2, 0xdf, 0xcc, 0x8e, 0xbf, 0x99, 0xef, 0xd3, 0x6c, 0x20, 0x53,
	0xb3, 0x1d, 0x52, 0x25, 0x01, 0x71, 0x82, 0xd5, 0x56, 0x9b, 0x06, 0x14, 0xcf, 0x32, 0xc4, 0x24,
	0x0e, 0xad, 0x7b, 0x6e, 0xe0, 0x52, 0x2f, 0x77, 0xad, 0x4e, 0x69, 0xbd, 0x41, 0x8a, 0x76, 0xcb,
	0x2d, 0xda, 0x9e, 0x47, 0x03, 0x9b, 0xc1, 0xbe, 0x48, 0xd7, 0x0b, 0xa0, 0x6c, 0xd9, 0x0e, 0x79,
	0x42, 0x7d, 0x9e, 0x8d, 0x15, 0x40, 0x27, 0x2a, 0xd2, 0x90, 0x91, 0x32, 0xd1, 0x09, 0x3b, 0x9d,
	0xaa, 0x92, 0x38, 0x9d, 0xea, 0x1f, 0x11, 0x64, 0xb6, 0xda, 0xb4, 0xb9, 0xd3, 0xb4, 0xeb, 0xc4,
	0x24, 0x2f, 0x5f, 0x11, 0x3f, 0xc0, 0x59, 0x88, 0xba, 0xec, 0xcc, 0x2f, 0x29, 0xa6, 0x38, 0xe0,
	0xeb, 0x90, 0x3c, 0x76, 0x83, 0x43, 0xab, 0x4e, 0xbc, 0x2a, 0x69, 0xf3, 0x12, 0x33, 0x26, 0x30,
	0x68, 0x9b, 0x23, 0xf8, 0x0a, 0xcc, 0xf0, 0x04, 0x76, 0x53, 0xe6, 0xd1, 0x38, 0x3b, 0x6f, 0xd4,
	0x09, 0x5e, 0x84, 0x14, 0x0f, 0xb5, 0x42, 0x4e, 0x6a, 0x84, 0xc7, 0x15, 0x06, 0x76, 0x79, 0x16,
	0x21, 0xcb, 0x93, 0x58, 0xb7, 0x96, 0xd3, 0xa6, 0x2d, 0xeb, 0xd8, 0xad, 0x06, 0x87, 0x6a, 0x94,
	0xe7, 0xce, 0xb1, 0x18, 0xeb, 0xeb, 0x61, 0x9b, 0xb6, 0x0e, 0x58, 0x40, 0x3f, 0x43, 0x30, 0xd7,
	0x47, 0xde, 0x6f, 0x51, 0xcf, 0x27, 0x78, 0x01, 0xa0, 0x5b, 0xc1, 0x57, 0x91, 0x26, 0x1b, 0x8a,
	0x99, 0xa8, 0x85, 0x17, 0x7d, 0xbc, 0x06, 0x71, 0xd1, 0x81, 0xaf, 0x4a, 0x9a, 0x6c, 0xa4, 0x4b,
	0x97, 0x57, 0x87, 0xc6, 0xbb, 0x2a, 0xfa, 0x31, 0x3b, 0x79, 0x18, 0x43, 0xc4, 0xae, 0x13, 0x5f,
	0x95, 0x35, 0xd9, 0x88, 0x9a, 0xfc, 0x37, 0xbe, 0x07, 0x89, 0x4e, 0x33, 0xbe, 0x1a, 0xd1, 0x64,
	0x23, 0x59, 0x5a, 0x18, 0x29, 0xd4, 0x2f, 0x83, 0xd9, 0xcb, 0xc7, 0x86, 0x10, 0xb9, 0xaf, 0x49,
	0x5f, 0x8d, 0x6a, 0xb2, 0x91, 0x32, 0xd3, 0xb5, 0xfe, 0x0e, 0x7d, 0xfd, 0x3b, 0x82, 0xf9, 0x3d,
	0x8f, 0xd5, 0xd9, 0xe4, 0x8e, 0xe8, 0x48, 0xb4, 0x06, 0x59, 0xd7, 0x0b, 0x48, 0xfb, 0xc8, 0x6e,
	0x58, 0x4d, 0xb7, 0xd1, 0x70, 0x7d, 0xe2, 0x50, 0xaf, 0x1a, 0xca, 0x3c, 0xdf, 0x89, 0xed, 0xf6,
	0x42, 0xff, 0xa0, 0x7e, 0x3f, 0x10, 0x64, 0x07, 0x9b, 0xfb, 0x1f, 0x25, 0xfc, 0x22, 0x41, 0x4e,
	0x74, 0xb9, 0x4f, 0x82, 0x51, 0x25, 0xf3, 0x90, 0xe4, 0x85, 0x7c, 0x12, 0x58, 0xae, 0x10, 0x30,
	0x21, 0x9a, 0xdd, 0x27, 0xc1, 0x4e, 0x15, 0x2f, 0x41, 0x7a, 0x70, 0xaa, 0xa1, 0x72, 0x4a, 0xff,
	0x3c, 0x87, 0xc5, 0x95, 0xa7, 0x8a, 0x1b, 0xb9, 0x40, 0xdc, 0xe8, 0x18, 0x71, 0x27, 0x19, 0x2e,
	0x36, 0xd9, 0x70, 0xcb, 0x90, 0x76, 0xa8, 0x57, 0x73, 0xab, 0xc4, 0x73, 0x88, 0xd5, 0x74, 0x3d,
	0x35, 0xae, 0x21, 0x43, 0x32, 0x53, 0x3d, 0x74, 0xd7, 0x9d, 0x6c, 0x9b, 0x99, 0x49, 0xb6, 0xf9,
	0x20, 0xc1, 0xd5, 0xb1, 0x03, 0x0d, 0xdd, 0xa3, 0x41, 0xb2, 0xf7, 0x05, 0x61, 0x1f, 0xc9, 0xec,
	0x87, 0xd8, 0xb4, 0xf8, 0xd7, 0x02, 0xfa, 0x82, 0x78, 0xc2, 0x44, 0x09, 0x93, 0x5b, 0xee, 0x29,
	0x47, 0x86, 0x0c, 0x28, 0x4f, 0x31, 0x60, 0xe4, 0x0f, 0x0d, 0x18, 0x9d, 0x64, 0xc0, 0xd8, 0x5f,
	0x30, 0x60, 0x7c, 0x9c, 0x01, 0x0b, 0xf7, 0x21, 0x16, 0x9a, 0x00, 0x43, 0x7a, 0xbb, 0x5c, 0xd9,
	0x2c, 0x9b, 0xd6, 0xb3, 0xca, 0xa3, 0xca, 0xde, 0x41, 0x25, 0x73, 0x09, 0xcf, 0x42, 0x32, 0xc4,
	0x76, 0x37, 0x1e, 0x97, 0x33, 0x08, 0xcf, 0x41, 0x2a, 0x04, 0xb6, 0xca, 0x1c, 0x92, 0x4a, 0x9f,
	0x64, 0x80, 0xde, 0xa0, 0xf1, 0x6b, 0x48, 0x74, 0xd7, 0x2e, 0xbe, 0x31, 0xca, 0x78, 0xe8, 0x3d,
	0xc9, 0xe9, 0xd3, 0x52, 0x84, 0x68, 0xfa, 0xcd, 0x37, 0xdf, 0x7e, 0xbe, 0x93, 0x16, 0xf5, 0x3c,
	0x7f, 0xd4, 0x8e, 0x4a, 0x45, 0x76, 0xa5, 0x28, 0x9e, 0xc1, 0x62, 0xad, 0x4d, 0x9b, 0x16, 0x7f,
	0x85, 0xee, 0xa2, 0x02, 0x7e, 0x8b, 0x40, 0xe9, 0x5f, 0x1b, 0x78, 0x69, 0xa4, 0xfe, 0x98, 0x95,
	0x99, 0x5b, 0xbe, 0x20, 0x2b, 0x24, 0x52, 0xe0, 0x44, 0x96, 0xb0, 0x3e, 0x8e, 0x08, 0xf5, 0x84,
	0x4d, 0xc5, 0xf1, 0x0e, 0xc2, 0xef, 0xbb, 0xfb, 0x79, 0xc0, 0x8b, 0x78, 0x65, 0xc2, 0xc7, 0xc6,
	0xad, 0x80, 0xdc, 0xad, 0xdf, 0x4b, 0x0e, 0x09, 0xae, 0x73, 0x82, 0xb7, 0xf1, 0xca, 0x34, 0x82,
	0x6c, 0x9b, 0x0c, 0x30, 0x7d, 0xa0, 0x7c, 0x3e, 0xcf, 0xa3, 0xaf, 0xe7, 0x79, 0x74, 0x76, 0x9e,
	0x47, 0xcf, 0x63, 0xfc, 0xaf, 0xc2, 0xfa, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x96, 0xa5,
	0x8e, 0x6d, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FaceDetectClient is the client API for FaceDetect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FaceDetectClient interface {
	// FromImage实现对输入图片进行人脸检测，返回检测人脸图片列表
	FromImage(ctx context.Context, in *FromImageRequest, opts ...grpc.CallOption) (*FromImageResponse, error)
	// OnFaceDetect实现动态检测人脸，流式返回检测人脸图片戳列表
	OnFaceDetect(ctx context.Context, in *OnFaceDetectRequest, opts ...grpc.CallOption) (FaceDetect_OnFaceDetectClient, error)
	// OnFaceSetFaceDetect实现动态检测人脸并与指定FaceSet进行对比，流式返回检测结果
	OnFaceSetFaceDetect(ctx context.Context, in *OnFaceSetFaceDetectRequest, opts ...grpc.CallOption) (FaceDetect_OnFaceSetFaceDetectClient, error)
}

type faceDetectClient struct {
	cc *grpc.ClientConn
}

func NewFaceDetectClient(cc *grpc.ClientConn) FaceDetectClient {
	return &faceDetectClient{cc}
}

func (c *faceDetectClient) FromImage(ctx context.Context, in *FromImageRequest, opts ...grpc.CallOption) (*FromImageResponse, error) {
	out := new(FromImageResponse)
	err := c.cc.Invoke(ctx, "/faceRecognition.FaceDetect/FromImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *faceDetectClient) OnFaceDetect(ctx context.Context, in *OnFaceDetectRequest, opts ...grpc.CallOption) (FaceDetect_OnFaceDetectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FaceDetect_serviceDesc.Streams[0], "/faceRecognition.FaceDetect/OnFaceDetect", opts...)
	if err != nil {
		return nil, err
	}
	x := &faceDetectOnFaceDetectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FaceDetect_OnFaceDetectClient interface {
	Recv() (*OnFaceDetectResponse, error)
	grpc.ClientStream
}

type faceDetectOnFaceDetectClient struct {
	grpc.ClientStream
}

func (x *faceDetectOnFaceDetectClient) Recv() (*OnFaceDetectResponse, error) {
	m := new(OnFaceDetectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *faceDetectClient) OnFaceSetFaceDetect(ctx context.Context, in *OnFaceSetFaceDetectRequest, opts ...grpc.CallOption) (FaceDetect_OnFaceSetFaceDetectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FaceDetect_serviceDesc.Streams[1], "/faceRecognition.FaceDetect/OnFaceSetFaceDetect", opts...)
	if err != nil {
		return nil, err
	}
	x := &faceDetectOnFaceSetFaceDetectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FaceDetect_OnFaceSetFaceDetectClient interface {
	Recv() (*OnFaceSetFaceDetectResponse, error)
	grpc.ClientStream
}

type faceDetectOnFaceSetFaceDetectClient struct {
	grpc.ClientStream
}

func (x *faceDetectOnFaceSetFaceDetectClient) Recv() (*OnFaceSetFaceDetectResponse, error) {
	m := new(OnFaceSetFaceDetectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FaceDetectServer is the server API for FaceDetect service.
type FaceDetectServer interface {
	// FromImage实现对输入图片进行人脸检测，返回检测人脸图片列表
	FromImage(context.Context, *FromImageRequest) (*FromImageResponse, error)
	// OnFaceDetect实现动态检测人脸，流式返回检测人脸图片戳列表
	OnFaceDetect(*OnFaceDetectRequest, FaceDetect_OnFaceDetectServer) error
	// OnFaceSetFaceDetect实现动态检测人脸并与指定FaceSet进行对比，流式返回检测结果
	OnFaceSetFaceDetect(*OnFaceSetFaceDetectRequest, FaceDetect_OnFaceSetFaceDetectServer) error
}

// UnimplementedFaceDetectServer can be embedded to have forward compatible implementations.
type UnimplementedFaceDetectServer struct {
}

func (*UnimplementedFaceDetectServer) FromImage(ctx context.Context, req *FromImageRequest) (*FromImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FromImage not implemented")
}
func (*UnimplementedFaceDetectServer) OnFaceDetect(req *OnFaceDetectRequest, srv FaceDetect_OnFaceDetectServer) error {
	return status.Errorf(codes.Unimplemented, "method OnFaceDetect not implemented")
}
func (*UnimplementedFaceDetectServer) OnFaceSetFaceDetect(req *OnFaceSetFaceDetectRequest, srv FaceDetect_OnFaceSetFaceDetectServer) error {
	return status.Errorf(codes.Unimplemented, "method OnFaceSetFaceDetect not implemented")
}

func RegisterFaceDetectServer(s *grpc.Server, srv FaceDetectServer) {
	s.RegisterService(&_FaceDetect_serviceDesc, srv)
}

func _FaceDetect_FromImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FromImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FaceDetectServer).FromImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/faceRecognition.FaceDetect/FromImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FaceDetectServer).FromImage(ctx, req.(*FromImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FaceDetect_OnFaceDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OnFaceDetectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FaceDetectServer).OnFaceDetect(m, &faceDetectOnFaceDetectServer{stream})
}

type FaceDetect_OnFaceDetectServer interface {
	Send(*OnFaceDetectResponse) error
	grpc.ServerStream
}

type faceDetectOnFaceDetectServer struct {
	grpc.ServerStream
}

func (x *faceDetectOnFaceDetectServer) Send(m *OnFaceDetectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _FaceDetect_OnFaceSetFaceDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OnFaceSetFaceDetectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FaceDetectServer).OnFaceSetFaceDetect(m, &faceDetectOnFaceSetFaceDetectServer{stream})
}

type FaceDetect_OnFaceSetFaceDetectServer interface {
	Send(*OnFaceSetFaceDetectResponse) error
	grpc.ServerStream
}

type faceDetectOnFaceSetFaceDetectServer struct {
	grpc.ServerStream
}

func (x *faceDetectOnFaceSetFaceDetectServer) Send(m *OnFaceSetFaceDetectResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _FaceDetect_serviceDesc = grpc.ServiceDesc{
	ServiceName: "faceRecognition.FaceDetect",
	HandlerType: (*FaceDetectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FromImage",
			Handler:    _FaceDetect_FromImage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OnFaceDetect",
			Handler:       _FaceDetect_OnFaceDetect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OnFaceSetFaceDetect",
			Handler:       _FaceDetect_OnFaceSetFaceDetect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "facedetect.proto",
}

func (m *FacePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FacePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FacePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != 0 {
		i = encodeVarintFacedetect(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintFacedetect(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FromImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FromImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FromImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithFaceCropWidth {
		i--
		if m.WithFaceCropWidth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.WithPosition {
		i--
		if m.WithPosition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.WithAge {
		i--
		if m.WithAge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.WithGender {
		i--
		if m.WithGender {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintFacedetect(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FromImageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FromImageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FromImageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FaceCropWidths) > 0 {
		dAtA2 := make([]byte, len(m.FaceCropWidths)*10)
		var j1 int
		for _, num := range m.FaceCropWidths {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintFacedetect(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFacedetect(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Ages) > 0 {
		dAtA4 := make([]byte, len(m.Ages)*10)
		var j3 int
		for _, num1 := range m.Ages {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintFacedetect(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Genders) > 0 {
		dAtA6 := make([]byte, len(m.Genders)*10)
		var j5 int
		for _, num := range m.Genders {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintFacedetect(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FaceCrops) > 0 {
		for iNdEx := len(m.FaceCrops) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FaceCrops[iNdEx])
			copy(dAtA[i:], m.FaceCrops[iNdEx])
			i = encodeVarintFacedetect(dAtA, i, uint64(len(m.FaceCrops[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OnFaceDetectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnFaceDetectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnFaceDetectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithFaceCropWidth {
		i--
		if m.WithFaceCropWidth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.WithPosition {
		i--
		if m.WithPosition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.WithAge {
		i--
		if m.WithAge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.WithGender {
		i--
		if m.WithGender {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IntervalMillisecond != 0 {
		i = encodeVarintFacedetect(dAtA, i, uint64(m.IntervalMillisecond))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnFaceDetectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnFaceDetectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnFaceDetectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FaceCropWidths) > 0 {
		dAtA8 := make([]byte, len(m.FaceCropWidths)*10)
		var j7 int
		for _, num := range m.FaceCropWidths {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintFacedetect(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFacedetect(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Ages) > 0 {
		dAtA10 := make([]byte, len(m.Ages)*10)
		var j9 int
		for _, num1 := range m.Ages {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintFacedetect(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Genders) > 0 {
		dAtA12 := make([]byte, len(m.Genders)*10)
		var j11 int
		for _, num := range m.Genders {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintFacedetect(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FaceCrops) > 0 {
		for iNdEx := len(m.FaceCrops) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FaceCrops[iNdEx])
			copy(dAtA[i:], m.FaceCrops[iNdEx])
			i = encodeVarintFacedetect(dAtA, i, uint64(len(m.FaceCrops[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OnFaceSetFaceDetectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnFaceSetFaceDetectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnFaceSetFaceDetectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WithFaceCropWidth {
		i--
		if m.WithFaceCropWidth {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ConfidenceMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ConfidenceMin))))
		i--
		dAtA[i] = 0x3d
	}
	if m.IntervalMillisecond != 0 {
		i = encodeVarintFacedetect(dAtA, i, uint64(m.IntervalMillisecond))
		i--
		dAtA[i] = 0x30
	}
	if m.WithPosition {
		i--
		if m.WithPosition {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.WithAge {
		i--
		if m.WithAge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.WithGender {
		i--
		if m.WithGender {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.WithFaceCrop {
		i--
		if m.WithFaceCrop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.FaceSetId) > 0 {
		i -= len(m.FaceSetId)
		copy(dAtA[i:], m.FaceSetId)
		i = encodeVarintFacedetect(dAtA, i, uint64(len(m.FaceSetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OnFaceSetFaceDetectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnFaceSetFaceDetectResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnFaceSetFaceDetectResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FaceCropWidths) > 0 {
		dAtA14 := make([]byte, len(m.FaceCropWidths)*10)
		var j13 int
		for _, num := range m.FaceCropWidths {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintFacedetect(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Positions) > 0 {
		for iNdEx := len(m.Positions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Positions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFacedetect(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Ages) > 0 {
		dAtA16 := make([]byte, len(m.Ages)*10)
		var j15 int
		for _, num1 := range m.Ages {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		i -= j15
		copy(dAtA[i:], dAtA16[:j15])
		i = encodeVarintFacedetect(dAtA, i, uint64(j15))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Genders) > 0 {
		dAtA18 := make([]byte, len(m.Genders)*10)
		var j17 int
		for _, num := range m.Genders {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintFacedetect(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FaceCrops) > 0 {
		for iNdEx := len(m.FaceCrops) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FaceCrops[iNdEx])
			copy(dAtA[i:], m.FaceCrops[iNdEx])
			i = encodeVarintFacedetect(dAtA, i, uint64(len(m.FaceCrops[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.FaceTokens) > 0 {
		for iNdEx := len(m.FaceTokens) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FaceTokens[iNdEx])
			copy(dAtA[i:], m.FaceTokens[iNdEx])
			i = encodeVarintFacedetect(dAtA, i, uint64(len(m.FaceTokens[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Confidences) > 0 {
		for iNdEx := len(m.Confidences) - 1; iNdEx >= 0; iNdEx-- {
			f19 := math.Float32bits(float32(m.Confidences[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f19))
		}
		i = encodeVarintFacedetect(dAtA, i, uint64(len(m.Confidences)*4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFacedetect(dAtA []byte, offset int, v uint64) int {
	offset -= sovFacedetect(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FacePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovFacedetect(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovFacedetect(uint64(m.Y))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FromImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovFacedetect(uint64(l))
	}
	if m.WithGender {
		n += 2
	}
	if m.WithAge {
		n += 2
	}
	if m.WithPosition {
		n += 2
	}
	if m.WithFaceCropWidth {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FromImageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FaceCrops) > 0 {
		for _, b := range m.FaceCrops {
			l = len(b)
			n += 1 + l + sovFacedetect(uint64(l))
		}
	}
	if len(m.Genders) > 0 {
		l = 0
		for _, e := range m.Genders {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if len(m.Ages) > 0 {
		l = 0
		for _, e := range m.Ages {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovFacedetect(uint64(l))
		}
	}
	if len(m.FaceCropWidths) > 0 {
		l = 0
		for _, e := range m.FaceCropWidths {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnFaceDetectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IntervalMillisecond != 0 {
		n += 1 + sovFacedetect(uint64(m.IntervalMillisecond))
	}
	if m.WithGender {
		n += 2
	}
	if m.WithAge {
		n += 2
	}
	if m.WithPosition {
		n += 2
	}
	if m.WithFaceCropWidth {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnFaceDetectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FaceCrops) > 0 {
		for _, b := range m.FaceCrops {
			l = len(b)
			n += 1 + l + sovFacedetect(uint64(l))
		}
	}
	if len(m.Genders) > 0 {
		l = 0
		for _, e := range m.Genders {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if len(m.Ages) > 0 {
		l = 0
		for _, e := range m.Ages {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovFacedetect(uint64(l))
		}
	}
	if len(m.FaceCropWidths) > 0 {
		l = 0
		for _, e := range m.FaceCropWidths {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnFaceSetFaceDetectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FaceSetId)
	if l > 0 {
		n += 1 + l + sovFacedetect(uint64(l))
	}
	if m.WithFaceCrop {
		n += 2
	}
	if m.WithGender {
		n += 2
	}
	if m.WithAge {
		n += 2
	}
	if m.WithPosition {
		n += 2
	}
	if m.IntervalMillisecond != 0 {
		n += 1 + sovFacedetect(uint64(m.IntervalMillisecond))
	}
	if m.ConfidenceMin != 0 {
		n += 5
	}
	if m.WithFaceCropWidth {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnFaceSetFaceDetectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Confidences) > 0 {
		n += 1 + sovFacedetect(uint64(len(m.Confidences)*4)) + len(m.Confidences)*4
	}
	if len(m.FaceTokens) > 0 {
		for _, s := range m.FaceTokens {
			l = len(s)
			n += 1 + l + sovFacedetect(uint64(l))
		}
	}
	if len(m.FaceCrops) > 0 {
		for _, b := range m.FaceCrops {
			l = len(b)
			n += 1 + l + sovFacedetect(uint64(l))
		}
	}
	if len(m.Genders) > 0 {
		l = 0
		for _, e := range m.Genders {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if len(m.Ages) > 0 {
		l = 0
		for _, e := range m.Ages {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if len(m.Positions) > 0 {
		for _, e := range m.Positions {
			l = e.Size()
			n += 1 + l + sovFacedetect(uint64(l))
		}
	}
	if len(m.FaceCropWidths) > 0 {
		l = 0
		for _, e := range m.FaceCropWidths {
			l += sovFacedetect(uint64(e))
		}
		n += 1 + sovFacedetect(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFacedetect(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFacedetect(x uint64) (n int) {
	return sovFacedetect(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FacePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FacePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FacePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFacedetect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FromImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FromImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FromImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = append(m.Image[:0], dAtA[iNdEx:postIndex]...)
			if m.Image == nil {
				m.Image = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithGender", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithGender = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithAge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithAge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPosition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithPosition = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithFaceCropWidth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithFaceCropWidth = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFacedetect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FromImageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FromImageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FromImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCrops", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceCrops = append(m.FaceCrops, make([]byte, postIndex-iNdEx))
			copy(m.FaceCrops[len(m.FaceCrops)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Gender
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Gender(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Genders = append(m.Genders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Genders) == 0 {
					m.Genders = make([]Gender, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Gender
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Gender(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Genders = append(m.Genders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Genders", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ages = append(m.Ages, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ages) == 0 {
					m.Ages = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ages = append(m.Ages, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ages", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &FacePosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FaceCropWidths = append(m.FaceCropWidths, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FaceCropWidths) == 0 {
					m.FaceCropWidths = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FaceCropWidths = append(m.FaceCropWidths, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCropWidths", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFacedetect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnFaceDetectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnFaceDetectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnFaceDetectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalMillisecond", wireType)
			}
			m.IntervalMillisecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalMillisecond |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithGender", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithGender = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithAge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithAge = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPosition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithPosition = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithFaceCropWidth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithFaceCropWidth = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFacedetect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnFaceDetectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnFaceDetectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnFaceDetectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCrops", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceCrops = append(m.FaceCrops, make([]byte, postIndex-iNdEx))
			copy(m.FaceCrops[len(m.FaceCrops)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v Gender
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Gender(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Genders = append(m.Genders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Genders) == 0 {
					m.Genders = make([]Gender, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Gender
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Gender(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Genders = append(m.Genders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Genders", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ages = append(m.Ages, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ages) == 0 {
					m.Ages = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ages = append(m.Ages, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ages", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &FacePosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FaceCropWidths = append(m.FaceCropWidths, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FaceCropWidths) == 0 {
					m.FaceCropWidths = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FaceCropWidths = append(m.FaceCropWidths, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCropWidths", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFacedetect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnFaceSetFaceDetectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnFaceSetFaceDetectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnFaceSetFaceDetectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithFaceCrop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithFaceCrop = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithGender", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithGender = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithAge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithAge = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithPosition", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithPosition = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntervalMillisecond", wireType)
			}
			m.IntervalMillisecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntervalMillisecond |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfidenceMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ConfidenceMin = float32(math.Float32frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithFaceCropWidth", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithFaceCropWidth = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFacedetect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnFaceSetFaceDetectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnFaceSetFaceDetectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnFaceSetFaceDetectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Confidences = append(m.Confidences, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Confidences) == 0 {
					m.Confidences = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Confidences = append(m.Confidences, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidences", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceTokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceTokens = append(m.FaceTokens, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCrops", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceCrops = append(m.FaceCrops, make([]byte, postIndex-iNdEx))
			copy(m.FaceCrops[len(m.FaceCrops)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v Gender
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Gender(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Genders = append(m.Genders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Genders) == 0 {
					m.Genders = make([]Gender, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Gender
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Gender(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Genders = append(m.Genders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Genders", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ages = append(m.Ages, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ages) == 0 {
					m.Ages = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ages = append(m.Ages, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ages", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFacedetect
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFacedetect
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Positions = append(m.Positions, &FacePosition{})
			if err := m.Positions[len(m.Positions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.FaceCropWidths = append(m.FaceCropWidths, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFacedetect
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFacedetect
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.FaceCropWidths) == 0 {
					m.FaceCropWidths = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFacedetect
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.FaceCropWidths = append(m.FaceCropWidths, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCropWidths", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFacedetect(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFacedetect
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFacedetect(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFacedetect
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFacedetect
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFacedetect
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthFacedetect
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFacedetect
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFacedetect(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthFacedetect
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFacedetect = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFacedetect   = fmt.Errorf("proto: integer overflow")
)
