// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messaging.proto

#ifndef PROTOBUF_INCLUDED_messaging_2eproto
#define PROTOBUF_INCLUDED_messaging_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messaging_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_messaging_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_messaging_2eproto();
namespace messaging {
class MessagePublish;
class MessagePublishDefaultTypeInternal;
extern MessagePublishDefaultTypeInternal _MessagePublish_default_instance_;
class MessagingRequest;
class MessagingRequestDefaultTypeInternal;
extern MessagingRequestDefaultTypeInternal _MessagingRequest_default_instance_;
class MessagingResponse;
class MessagingResponseDefaultTypeInternal;
extern MessagingResponseDefaultTypeInternal _MessagingResponse_default_instance_;
class Subscribe;
class SubscribeDefaultTypeInternal;
extern SubscribeDefaultTypeInternal _Subscribe_default_instance_;
class Unsubscribe;
class UnsubscribeDefaultTypeInternal;
extern UnsubscribeDefaultTypeInternal _Unsubscribe_default_instance_;
}  // namespace messaging
namespace google {
namespace protobuf {
template<> ::messaging::MessagePublish* Arena::CreateMaybeMessage<::messaging::MessagePublish>(Arena*);
template<> ::messaging::MessagingRequest* Arena::CreateMaybeMessage<::messaging::MessagingRequest>(Arena*);
template<> ::messaging::MessagingResponse* Arena::CreateMaybeMessage<::messaging::MessagingResponse>(Arena*);
template<> ::messaging::Subscribe* Arena::CreateMaybeMessage<::messaging::Subscribe>(Arena*);
template<> ::messaging::Unsubscribe* Arena::CreateMaybeMessage<::messaging::Unsubscribe>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace messaging {

// ===================================================================

class Subscribe final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messaging.Subscribe) */ {
 public:
  Subscribe();
  virtual ~Subscribe();

  Subscribe(const Subscribe& from);

  inline Subscribe& operator=(const Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Subscribe(Subscribe&& from) noexcept
    : Subscribe() {
    *this = ::std::move(from);
  }

  inline Subscribe& operator=(Subscribe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Subscribe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Subscribe* internal_default_instance() {
    return reinterpret_cast<const Subscribe*>(
               &_Subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Subscribe* other);
  friend void swap(Subscribe& a, Subscribe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Subscribe* New() const final {
    return CreateMaybeMessage<Subscribe>(nullptr);
  }

  Subscribe* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Subscribe>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Subscribe& from);
  void MergeFrom(const Subscribe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subscribe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topics = 1;
  int topics_size() const;
  void clear_topics();
  static const int kTopicsFieldNumber = 1;
  const ::std::string& topics(int index) const;
  ::std::string* mutable_topics(int index);
  void set_topics(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topics(int index, ::std::string&& value);
  #endif
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  ::std::string* add_topics();
  void add_topics(const ::std::string& value);
  #if LANG_CXX11
  void add_topics(::std::string&& value);
  #endif
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& topics() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_topics();

  // @@protoc_insertion_point(class_scope:messaging.Subscribe)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> topics_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class Unsubscribe final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messaging.Unsubscribe) */ {
 public:
  Unsubscribe();
  virtual ~Unsubscribe();

  Unsubscribe(const Unsubscribe& from);

  inline Unsubscribe& operator=(const Unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Unsubscribe(Unsubscribe&& from) noexcept
    : Unsubscribe() {
    *this = ::std::move(from);
  }

  inline Unsubscribe& operator=(Unsubscribe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Unsubscribe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Unsubscribe* internal_default_instance() {
    return reinterpret_cast<const Unsubscribe*>(
               &_Unsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Unsubscribe* other);
  friend void swap(Unsubscribe& a, Unsubscribe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Unsubscribe* New() const final {
    return CreateMaybeMessage<Unsubscribe>(nullptr);
  }

  Unsubscribe* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Unsubscribe>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Unsubscribe& from);
  void MergeFrom(const Unsubscribe& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Unsubscribe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topics = 1;
  int topics_size() const;
  void clear_topics();
  static const int kTopicsFieldNumber = 1;
  const ::std::string& topics(int index) const;
  ::std::string* mutable_topics(int index);
  void set_topics(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topics(int index, ::std::string&& value);
  #endif
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  ::std::string* add_topics();
  void add_topics(const ::std::string& value);
  #if LANG_CXX11
  void add_topics(::std::string&& value);
  #endif
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& topics() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_topics();

  // @@protoc_insertion_point(class_scope:messaging.Unsubscribe)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> topics_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class MessagePublish final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messaging.MessagePublish) */ {
 public:
  MessagePublish();
  virtual ~MessagePublish();

  MessagePublish(const MessagePublish& from);

  inline MessagePublish& operator=(const MessagePublish& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessagePublish(MessagePublish&& from) noexcept
    : MessagePublish() {
    *this = ::std::move(from);
  }

  inline MessagePublish& operator=(MessagePublish&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MessagePublish& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessagePublish* internal_default_instance() {
    return reinterpret_cast<const MessagePublish*>(
               &_MessagePublish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(MessagePublish* other);
  friend void swap(MessagePublish& a, MessagePublish& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessagePublish* New() const final {
    return CreateMaybeMessage<MessagePublish>(nullptr);
  }

  MessagePublish* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessagePublish>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessagePublish& from);
  void MergeFrom(const MessagePublish& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagePublish* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string topics = 1;
  int topics_size() const;
  void clear_topics();
  static const int kTopicsFieldNumber = 1;
  const ::std::string& topics(int index) const;
  ::std::string* mutable_topics(int index);
  void set_topics(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_topics(int index, ::std::string&& value);
  #endif
  void set_topics(int index, const char* value);
  void set_topics(int index, const char* value, size_t size);
  ::std::string* add_topics();
  void add_topics(const ::std::string& value);
  #if LANG_CXX11
  void add_topics(::std::string&& value);
  #endif
  void add_topics(const char* value);
  void add_topics(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& topics() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_topics();

  // bytes payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:messaging.MessagePublish)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> topics_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class MessagingRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messaging.MessagingRequest) */ {
 public:
  MessagingRequest();
  virtual ~MessagingRequest();

  MessagingRequest(const MessagingRequest& from);

  inline MessagingRequest& operator=(const MessagingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessagingRequest(MessagingRequest&& from) noexcept
    : MessagingRequest() {
    *this = ::std::move(from);
  }

  inline MessagingRequest& operator=(MessagingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MessagingRequest& default_instance();

  enum MessagingOneofCase {
    kSubscribe = 1,
    kUnsubscribe = 2,
    kMessagePublish = 3,
    MESSAGING_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessagingRequest* internal_default_instance() {
    return reinterpret_cast<const MessagingRequest*>(
               &_MessagingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MessagingRequest* other);
  friend void swap(MessagingRequest& a, MessagingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessagingRequest* New() const final {
    return CreateMaybeMessage<MessagingRequest>(nullptr);
  }

  MessagingRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessagingRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessagingRequest& from);
  void MergeFrom(const MessagingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .messaging.Subscribe subscribe = 1;
  bool has_subscribe() const;
  void clear_subscribe();
  static const int kSubscribeFieldNumber = 1;
  const ::messaging::Subscribe& subscribe() const;
  ::messaging::Subscribe* release_subscribe();
  ::messaging::Subscribe* mutable_subscribe();
  void set_allocated_subscribe(::messaging::Subscribe* subscribe);

  // .messaging.Unsubscribe unsubscribe = 2;
  bool has_unsubscribe() const;
  void clear_unsubscribe();
  static const int kUnsubscribeFieldNumber = 2;
  const ::messaging::Unsubscribe& unsubscribe() const;
  ::messaging::Unsubscribe* release_unsubscribe();
  ::messaging::Unsubscribe* mutable_unsubscribe();
  void set_allocated_unsubscribe(::messaging::Unsubscribe* unsubscribe);

  // .messaging.MessagePublish message_publish = 3;
  bool has_message_publish() const;
  void clear_message_publish();
  static const int kMessagePublishFieldNumber = 3;
  const ::messaging::MessagePublish& message_publish() const;
  ::messaging::MessagePublish* release_message_publish();
  ::messaging::MessagePublish* mutable_message_publish();
  void set_allocated_message_publish(::messaging::MessagePublish* message_publish);

  void clear_messaging_oneof();
  MessagingOneofCase messaging_oneof_case() const;
  // @@protoc_insertion_point(class_scope:messaging.MessagingRequest)
 private:
  class HasBitSetters;
  void set_has_subscribe();
  void set_has_unsubscribe();
  void set_has_message_publish();

  inline bool has_messaging_oneof() const;
  inline void clear_has_messaging_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessagingOneofUnion {
    MessagingOneofUnion() {}
    ::messaging::Subscribe* subscribe_;
    ::messaging::Unsubscribe* unsubscribe_;
    ::messaging::MessagePublish* message_publish_;
  } messaging_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_messaging_2eproto;
};
// -------------------------------------------------------------------

class MessagingResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:messaging.MessagingResponse) */ {
 public:
  MessagingResponse();
  virtual ~MessagingResponse();

  MessagingResponse(const MessagingResponse& from);

  inline MessagingResponse& operator=(const MessagingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessagingResponse(MessagingResponse&& from) noexcept
    : MessagingResponse() {
    *this = ::std::move(from);
  }

  inline MessagingResponse& operator=(MessagingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const MessagingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessagingResponse* internal_default_instance() {
    return reinterpret_cast<const MessagingResponse*>(
               &_MessagingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MessagingResponse* other);
  friend void swap(MessagingResponse& a, MessagingResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessagingResponse* New() const final {
    return CreateMaybeMessage<MessagingResponse>(nullptr);
  }

  MessagingResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessagingResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessagingResponse& from);
  void MergeFrom(const MessagingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string topic = 1;
  void clear_topic();
  static const int kTopicFieldNumber = 1;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // bytes payload = 2;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:messaging.MessagingResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messaging_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Subscribe

// repeated string topics = 1;
inline int Subscribe::topics_size() const {
  return topics_.size();
}
inline void Subscribe::clear_topics() {
  topics_.Clear();
}
inline const ::std::string& Subscribe::topics(int index) const {
  // @@protoc_insertion_point(field_get:messaging.Subscribe.topics)
  return topics_.Get(index);
}
inline ::std::string* Subscribe::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:messaging.Subscribe.topics)
  return topics_.Mutable(index);
}
inline void Subscribe::set_topics(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:messaging.Subscribe.topics)
  topics_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Subscribe::set_topics(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:messaging.Subscribe.topics)
  topics_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Subscribe::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:messaging.Subscribe.topics)
}
inline void Subscribe::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:messaging.Subscribe.topics)
}
inline ::std::string* Subscribe::add_topics() {
  // @@protoc_insertion_point(field_add_mutable:messaging.Subscribe.topics)
  return topics_.Add();
}
inline void Subscribe::add_topics(const ::std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:messaging.Subscribe.topics)
}
#if LANG_CXX11
inline void Subscribe::add_topics(::std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:messaging.Subscribe.topics)
}
#endif
inline void Subscribe::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:messaging.Subscribe.topics)
}
inline void Subscribe::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:messaging.Subscribe.topics)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Subscribe::topics() const {
  // @@protoc_insertion_point(field_list:messaging.Subscribe.topics)
  return topics_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Subscribe::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:messaging.Subscribe.topics)
  return &topics_;
}

// -------------------------------------------------------------------

// Unsubscribe

// repeated string topics = 1;
inline int Unsubscribe::topics_size() const {
  return topics_.size();
}
inline void Unsubscribe::clear_topics() {
  topics_.Clear();
}
inline const ::std::string& Unsubscribe::topics(int index) const {
  // @@protoc_insertion_point(field_get:messaging.Unsubscribe.topics)
  return topics_.Get(index);
}
inline ::std::string* Unsubscribe::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:messaging.Unsubscribe.topics)
  return topics_.Mutable(index);
}
inline void Unsubscribe::set_topics(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:messaging.Unsubscribe.topics)
  topics_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Unsubscribe::set_topics(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:messaging.Unsubscribe.topics)
  topics_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Unsubscribe::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:messaging.Unsubscribe.topics)
}
inline void Unsubscribe::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:messaging.Unsubscribe.topics)
}
inline ::std::string* Unsubscribe::add_topics() {
  // @@protoc_insertion_point(field_add_mutable:messaging.Unsubscribe.topics)
  return topics_.Add();
}
inline void Unsubscribe::add_topics(const ::std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:messaging.Unsubscribe.topics)
}
#if LANG_CXX11
inline void Unsubscribe::add_topics(::std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:messaging.Unsubscribe.topics)
}
#endif
inline void Unsubscribe::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:messaging.Unsubscribe.topics)
}
inline void Unsubscribe::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:messaging.Unsubscribe.topics)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Unsubscribe::topics() const {
  // @@protoc_insertion_point(field_list:messaging.Unsubscribe.topics)
  return topics_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Unsubscribe::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:messaging.Unsubscribe.topics)
  return &topics_;
}

// -------------------------------------------------------------------

// MessagePublish

// repeated string topics = 1;
inline int MessagePublish::topics_size() const {
  return topics_.size();
}
inline void MessagePublish::clear_topics() {
  topics_.Clear();
}
inline const ::std::string& MessagePublish::topics(int index) const {
  // @@protoc_insertion_point(field_get:messaging.MessagePublish.topics)
  return topics_.Get(index);
}
inline ::std::string* MessagePublish::mutable_topics(int index) {
  // @@protoc_insertion_point(field_mutable:messaging.MessagePublish.topics)
  return topics_.Mutable(index);
}
inline void MessagePublish::set_topics(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:messaging.MessagePublish.topics)
  topics_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MessagePublish::set_topics(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:messaging.MessagePublish.topics)
  topics_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MessagePublish::set_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:messaging.MessagePublish.topics)
}
inline void MessagePublish::set_topics(int index, const char* value, size_t size) {
  topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:messaging.MessagePublish.topics)
}
inline ::std::string* MessagePublish::add_topics() {
  // @@protoc_insertion_point(field_add_mutable:messaging.MessagePublish.topics)
  return topics_.Add();
}
inline void MessagePublish::add_topics(const ::std::string& value) {
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:messaging.MessagePublish.topics)
}
#if LANG_CXX11
inline void MessagePublish::add_topics(::std::string&& value) {
  topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:messaging.MessagePublish.topics)
}
#endif
inline void MessagePublish::add_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:messaging.MessagePublish.topics)
}
inline void MessagePublish::add_topics(const char* value, size_t size) {
  topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:messaging.MessagePublish.topics)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
MessagePublish::topics() const {
  // @@protoc_insertion_point(field_list:messaging.MessagePublish.topics)
  return topics_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
MessagePublish::mutable_topics() {
  // @@protoc_insertion_point(field_mutable_list:messaging.MessagePublish.topics)
  return &topics_;
}

// bytes payload = 2;
inline void MessagePublish::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessagePublish::payload() const {
  // @@protoc_insertion_point(field_get:messaging.MessagePublish.payload)
  return payload_.GetNoArena();
}
inline void MessagePublish::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:messaging.MessagePublish.payload)
}
#if LANG_CXX11
inline void MessagePublish::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:messaging.MessagePublish.payload)
}
#endif
inline void MessagePublish::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:messaging.MessagePublish.payload)
}
inline void MessagePublish::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:messaging.MessagePublish.payload)
}
inline ::std::string* MessagePublish::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:messaging.MessagePublish.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessagePublish::release_payload() {
  // @@protoc_insertion_point(field_release:messaging.MessagePublish.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessagePublish::set_allocated_payload(::std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:messaging.MessagePublish.payload)
}

// -------------------------------------------------------------------

// MessagingRequest

// .messaging.Subscribe subscribe = 1;
inline bool MessagingRequest::has_subscribe() const {
  return messaging_oneof_case() == kSubscribe;
}
inline void MessagingRequest::set_has_subscribe() {
  _oneof_case_[0] = kSubscribe;
}
inline void MessagingRequest::clear_subscribe() {
  if (has_subscribe()) {
    delete messaging_oneof_.subscribe_;
    clear_has_messaging_oneof();
  }
}
inline ::messaging::Subscribe* MessagingRequest::release_subscribe() {
  // @@protoc_insertion_point(field_release:messaging.MessagingRequest.subscribe)
  if (has_subscribe()) {
    clear_has_messaging_oneof();
      ::messaging::Subscribe* temp = messaging_oneof_.subscribe_;
    messaging_oneof_.subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::Subscribe& MessagingRequest::subscribe() const {
  // @@protoc_insertion_point(field_get:messaging.MessagingRequest.subscribe)
  return has_subscribe()
      ? *messaging_oneof_.subscribe_
      : *reinterpret_cast< ::messaging::Subscribe*>(&::messaging::_Subscribe_default_instance_);
}
inline ::messaging::Subscribe* MessagingRequest::mutable_subscribe() {
  if (!has_subscribe()) {
    clear_messaging_oneof();
    set_has_subscribe();
    messaging_oneof_.subscribe_ = CreateMaybeMessage< ::messaging::Subscribe >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:messaging.MessagingRequest.subscribe)
  return messaging_oneof_.subscribe_;
}

// .messaging.Unsubscribe unsubscribe = 2;
inline bool MessagingRequest::has_unsubscribe() const {
  return messaging_oneof_case() == kUnsubscribe;
}
inline void MessagingRequest::set_has_unsubscribe() {
  _oneof_case_[0] = kUnsubscribe;
}
inline void MessagingRequest::clear_unsubscribe() {
  if (has_unsubscribe()) {
    delete messaging_oneof_.unsubscribe_;
    clear_has_messaging_oneof();
  }
}
inline ::messaging::Unsubscribe* MessagingRequest::release_unsubscribe() {
  // @@protoc_insertion_point(field_release:messaging.MessagingRequest.unsubscribe)
  if (has_unsubscribe()) {
    clear_has_messaging_oneof();
      ::messaging::Unsubscribe* temp = messaging_oneof_.unsubscribe_;
    messaging_oneof_.unsubscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::Unsubscribe& MessagingRequest::unsubscribe() const {
  // @@protoc_insertion_point(field_get:messaging.MessagingRequest.unsubscribe)
  return has_unsubscribe()
      ? *messaging_oneof_.unsubscribe_
      : *reinterpret_cast< ::messaging::Unsubscribe*>(&::messaging::_Unsubscribe_default_instance_);
}
inline ::messaging::Unsubscribe* MessagingRequest::mutable_unsubscribe() {
  if (!has_unsubscribe()) {
    clear_messaging_oneof();
    set_has_unsubscribe();
    messaging_oneof_.unsubscribe_ = CreateMaybeMessage< ::messaging::Unsubscribe >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:messaging.MessagingRequest.unsubscribe)
  return messaging_oneof_.unsubscribe_;
}

// .messaging.MessagePublish message_publish = 3;
inline bool MessagingRequest::has_message_publish() const {
  return messaging_oneof_case() == kMessagePublish;
}
inline void MessagingRequest::set_has_message_publish() {
  _oneof_case_[0] = kMessagePublish;
}
inline void MessagingRequest::clear_message_publish() {
  if (has_message_publish()) {
    delete messaging_oneof_.message_publish_;
    clear_has_messaging_oneof();
  }
}
inline ::messaging::MessagePublish* MessagingRequest::release_message_publish() {
  // @@protoc_insertion_point(field_release:messaging.MessagingRequest.message_publish)
  if (has_message_publish()) {
    clear_has_messaging_oneof();
      ::messaging::MessagePublish* temp = messaging_oneof_.message_publish_;
    messaging_oneof_.message_publish_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::MessagePublish& MessagingRequest::message_publish() const {
  // @@protoc_insertion_point(field_get:messaging.MessagingRequest.message_publish)
  return has_message_publish()
      ? *messaging_oneof_.message_publish_
      : *reinterpret_cast< ::messaging::MessagePublish*>(&::messaging::_MessagePublish_default_instance_);
}
inline ::messaging::MessagePublish* MessagingRequest::mutable_message_publish() {
  if (!has_message_publish()) {
    clear_messaging_oneof();
    set_has_message_publish();
    messaging_oneof_.message_publish_ = CreateMaybeMessage< ::messaging::MessagePublish >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:messaging.MessagingRequest.message_publish)
  return messaging_oneof_.message_publish_;
}

inline bool MessagingRequest::has_messaging_oneof() const {
  return messaging_oneof_case() != MESSAGING_ONEOF_NOT_SET;
}
inline void MessagingRequest::clear_has_messaging_oneof() {
  _oneof_case_[0] = MESSAGING_ONEOF_NOT_SET;
}
inline MessagingRequest::MessagingOneofCase MessagingRequest::messaging_oneof_case() const {
  return MessagingRequest::MessagingOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MessagingResponse

// string topic = 1;
inline void MessagingResponse::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessagingResponse::topic() const {
  // @@protoc_insertion_point(field_get:messaging.MessagingResponse.topic)
  return topic_.GetNoArena();
}
inline void MessagingResponse::set_topic(const ::std::string& value) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:messaging.MessagingResponse.topic)
}
#if LANG_CXX11
inline void MessagingResponse::set_topic(::std::string&& value) {
  
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:messaging.MessagingResponse.topic)
}
#endif
inline void MessagingResponse::set_topic(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:messaging.MessagingResponse.topic)
}
inline void MessagingResponse::set_topic(const char* value, size_t size) {
  
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:messaging.MessagingResponse.topic)
}
inline ::std::string* MessagingResponse::mutable_topic() {
  
  // @@protoc_insertion_point(field_mutable:messaging.MessagingResponse.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessagingResponse::release_topic() {
  // @@protoc_insertion_point(field_release:messaging.MessagingResponse.topic)
  
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessagingResponse::set_allocated_topic(::std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:messaging.MessagingResponse.topic)
}

// bytes payload = 2;
inline void MessagingResponse::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MessagingResponse::payload() const {
  // @@protoc_insertion_point(field_get:messaging.MessagingResponse.payload)
  return payload_.GetNoArena();
}
inline void MessagingResponse::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:messaging.MessagingResponse.payload)
}
#if LANG_CXX11
inline void MessagingResponse::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:messaging.MessagingResponse.payload)
}
#endif
inline void MessagingResponse::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:messaging.MessagingResponse.payload)
}
inline void MessagingResponse::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:messaging.MessagingResponse.payload)
}
inline ::std::string* MessagingResponse::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:messaging.MessagingResponse.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessagingResponse::release_payload() {
  // @@protoc_insertion_point(field_release:messaging.MessagingResponse.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessagingResponse::set_allocated_payload(::std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:messaging.MessagingResponse.payload)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messaging

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_messaging_2eproto
