// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: map.proto

package navService

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type MapPosition struct {
	// 水平坐标 [0: mapWidth]
	X uint32 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	// 垂直坐标 [0: mapHeight]
	Y uint32 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	// 角度 水平右方向为0, 顺时针
	//     270
	// 180  ----0
	//     90
	Angle                uint32   `protobuf:"varint,3,opt,name=angle,proto3" json:"angle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MapPosition) Reset()         { *m = MapPosition{} }
func (m *MapPosition) String() string { return proto.CompactTextString(m) }
func (*MapPosition) ProtoMessage()    {}
func (*MapPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{0}
}
func (m *MapPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapPosition.Merge(m, src)
}
func (m *MapPosition) XXX_Size() int {
	return m.Size()
}
func (m *MapPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MapPosition.DiscardUnknown(m)
}

var xxx_messageInfo_MapPosition proto.InternalMessageInfo

func (m *MapPosition) GetX() uint32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *MapPosition) GetY() uint32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *MapPosition) GetAngle() uint32 {
	if m != nil {
		return m.Angle
	}
	return 0
}

type GetMapInfoRequest struct {
	// true: 不返回map_image信息
	NoMapImage bool `protobuf:"varint,1,opt,name=no_map_image,json=noMapImage,proto3" json:"no_map_image,omitempty"`
	// true: 不返回map_points信息
	NoMapPoints          bool     `protobuf:"varint,2,opt,name=no_map_points,json=noMapPoints,proto3" json:"no_map_points,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMapInfoRequest) Reset()         { *m = GetMapInfoRequest{} }
func (m *GetMapInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetMapInfoRequest) ProtoMessage()    {}
func (*GetMapInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{1}
}
func (m *GetMapInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMapInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMapInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMapInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMapInfoRequest.Merge(m, src)
}
func (m *GetMapInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMapInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMapInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMapInfoRequest proto.InternalMessageInfo

func (m *GetMapInfoRequest) GetNoMapImage() bool {
	if m != nil {
		return m.NoMapImage
	}
	return false
}

func (m *GetMapInfoRequest) GetNoMapPoints() bool {
	if m != nil {
		return m.NoMapPoints
	}
	return false
}

type GetMapInfoResponse struct {
	// 地图id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// 地图名
	Name                 string                         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MapImage             *GetMapInfoResponse_MapImage   `protobuf:"bytes,3,opt,name=map_image,json=mapImage,proto3" json:"map_image,omitempty"`
	MapPoints            []*GetMapInfoResponse_MapPoint `protobuf:"bytes,4,rep,name=map_points,json=mapPoints,proto3" json:"map_points,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *GetMapInfoResponse) Reset()         { *m = GetMapInfoResponse{} }
func (m *GetMapInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetMapInfoResponse) ProtoMessage()    {}
func (*GetMapInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{2}
}
func (m *GetMapInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMapInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMapInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMapInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMapInfoResponse.Merge(m, src)
}
func (m *GetMapInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMapInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMapInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMapInfoResponse proto.InternalMessageInfo

func (m *GetMapInfoResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GetMapInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetMapInfoResponse) GetMapImage() *GetMapInfoResponse_MapImage {
	if m != nil {
		return m.MapImage
	}
	return nil
}

func (m *GetMapInfoResponse) GetMapPoints() []*GetMapInfoResponse_MapPoint {
	if m != nil {
		return m.MapPoints
	}
	return nil
}

// 地图图片信息
type GetMapInfoResponse_MapImage struct {
	Width                uint32   `protobuf:"varint,1,opt,name=width,proto3" json:"width,omitempty"`
	Height               uint32   `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	Image                []byte   `protobuf:"bytes,3,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMapInfoResponse_MapImage) Reset()         { *m = GetMapInfoResponse_MapImage{} }
func (m *GetMapInfoResponse_MapImage) String() string { return proto.CompactTextString(m) }
func (*GetMapInfoResponse_MapImage) ProtoMessage()    {}
func (*GetMapInfoResponse_MapImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{2, 0}
}
func (m *GetMapInfoResponse_MapImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMapInfoResponse_MapImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMapInfoResponse_MapImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMapInfoResponse_MapImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMapInfoResponse_MapImage.Merge(m, src)
}
func (m *GetMapInfoResponse_MapImage) XXX_Size() int {
	return m.Size()
}
func (m *GetMapInfoResponse_MapImage) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMapInfoResponse_MapImage.DiscardUnknown(m)
}

var xxx_messageInfo_GetMapInfoResponse_MapImage proto.InternalMessageInfo

func (m *GetMapInfoResponse_MapImage) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *GetMapInfoResponse_MapImage) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *GetMapInfoResponse_MapImage) GetImage() []byte {
	if m != nil {
		return m.Image
	}
	return nil
}

// 地图点数据
// 与nav.RoutePoint信息一致，
// 区别为包含地图坐标信息
type GetMapInfoResponse_MapPoint struct {
	Name                 string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Position             *MapPosition `protobuf:"bytes,2,opt,name=position,proto3" json:"position,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetMapInfoResponse_MapPoint) Reset()         { *m = GetMapInfoResponse_MapPoint{} }
func (m *GetMapInfoResponse_MapPoint) String() string { return proto.CompactTextString(m) }
func (*GetMapInfoResponse_MapPoint) ProtoMessage()    {}
func (*GetMapInfoResponse_MapPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{2, 1}
}
func (m *GetMapInfoResponse_MapPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMapInfoResponse_MapPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMapInfoResponse_MapPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMapInfoResponse_MapPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMapInfoResponse_MapPoint.Merge(m, src)
}
func (m *GetMapInfoResponse_MapPoint) XXX_Size() int {
	return m.Size()
}
func (m *GetMapInfoResponse_MapPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMapInfoResponse_MapPoint.DiscardUnknown(m)
}

var xxx_messageInfo_GetMapInfoResponse_MapPoint proto.InternalMessageInfo

func (m *GetMapInfoResponse_MapPoint) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetMapInfoResponse_MapPoint) GetPosition() *MapPosition {
	if m != nil {
		return m.Position
	}
	return nil
}

type MapPositionStreamRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MapPositionStreamRequest) Reset()         { *m = MapPositionStreamRequest{} }
func (m *MapPositionStreamRequest) String() string { return proto.CompactTextString(m) }
func (*MapPositionStreamRequest) ProtoMessage()    {}
func (*MapPositionStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{3}
}
func (m *MapPositionStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapPositionStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapPositionStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapPositionStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapPositionStreamRequest.Merge(m, src)
}
func (m *MapPositionStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *MapPositionStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MapPositionStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MapPositionStreamRequest proto.InternalMessageInfo

type MapPositionStreamResponse struct {
	Position             *MapPosition `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MapPositionStreamResponse) Reset()         { *m = MapPositionStreamResponse{} }
func (m *MapPositionStreamResponse) String() string { return proto.CompactTextString(m) }
func (*MapPositionStreamResponse) ProtoMessage()    {}
func (*MapPositionStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{4}
}
func (m *MapPositionStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MapPositionStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MapPositionStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MapPositionStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MapPositionStreamResponse.Merge(m, src)
}
func (m *MapPositionStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *MapPositionStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MapPositionStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MapPositionStreamResponse proto.InternalMessageInfo

func (m *MapPositionStreamResponse) GetPosition() *MapPosition {
	if m != nil {
		return m.Position
	}
	return nil
}

type LocationResetRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocationResetRequest) Reset()         { *m = LocationResetRequest{} }
func (m *LocationResetRequest) String() string { return proto.CompactTextString(m) }
func (*LocationResetRequest) ProtoMessage()    {}
func (*LocationResetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{5}
}
func (m *LocationResetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationResetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationResetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationResetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationResetRequest.Merge(m, src)
}
func (m *LocationResetRequest) XXX_Size() int {
	return m.Size()
}
func (m *LocationResetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationResetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LocationResetRequest proto.InternalMessageInfo

type LocationResetResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocationResetResponse) Reset()         { *m = LocationResetResponse{} }
func (m *LocationResetResponse) String() string { return proto.CompactTextString(m) }
func (*LocationResetResponse) ProtoMessage()    {}
func (*LocationResetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_670a3ee274ba020a, []int{6}
}
func (m *LocationResetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationResetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationResetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationResetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationResetResponse.Merge(m, src)
}
func (m *LocationResetResponse) XXX_Size() int {
	return m.Size()
}
func (m *LocationResetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationResetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LocationResetResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MapPosition)(nil), "navService.MapPosition")
	proto.RegisterType((*GetMapInfoRequest)(nil), "navService.GetMapInfoRequest")
	proto.RegisterType((*GetMapInfoResponse)(nil), "navService.GetMapInfoResponse")
	proto.RegisterType((*GetMapInfoResponse_MapImage)(nil), "navService.GetMapInfoResponse.MapImage")
	proto.RegisterType((*GetMapInfoResponse_MapPoint)(nil), "navService.GetMapInfoResponse.MapPoint")
	proto.RegisterType((*MapPositionStreamRequest)(nil), "navService.MapPositionStreamRequest")
	proto.RegisterType((*MapPositionStreamResponse)(nil), "navService.MapPositionStreamResponse")
	proto.RegisterType((*LocationResetRequest)(nil), "navService.LocationResetRequest")
	proto.RegisterType((*LocationResetResponse)(nil), "navService.LocationResetResponse")
}

func init() { proto.RegisterFile("map.proto", fileDescriptor_670a3ee274ba020a) }

var fileDescriptor_670a3ee274ba020a = []byte{
	// 520 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x4d, 0x6f, 0x13, 0x31,
	0x10, 0x95, 0xb7, 0x1f, 0x4a, 0x26, 0x09, 0x52, 0xad, 0xd0, 0x86, 0x15, 0xa4, 0xdb, 0x15, 0x55,
	0x11, 0x87, 0x04, 0xa5, 0x37, 0x2e, 0x48, 0x08, 0x81, 0x90, 0x08, 0x8a, 0x9c, 0x13, 0xa7, 0xc8,
	0x34, 0x66, 0x63, 0x29, 0x6b, 0x9b, 0xac, 0x09, 0xad, 0xb8, 0x71, 0xe5, 0xc8, 0x9f, 0xe2, 0x88,
	0xc4, 0x1f, 0x40, 0x11, 0x37, 0x7e, 0x04, 0x68, 0xc7, 0x4e, 0xe2, 0xd2, 0x0f, 0x7a, 0xdb, 0x19,
	0xbf, 0x7d, 0xef, 0xcd, 0x1b, 0xef, 0x42, 0x35, 0xe7, 0xa6, 0x63, 0x66, 0xda, 0x6a, 0x0a, 0x8a,
	0xcf, 0x87, 0x62, 0x36, 0x97, 0x27, 0x22, 0xbe, 0x9b, 0x69, 0x9d, 0x4d, 0x45, 0x97, 0x1b, 0xd9,
	0xe5, 0x4a, 0x69, 0xcb, 0xad, 0xd4, 0xaa, 0x70, 0xc8, 0xf4, 0x09, 0xd4, 0xfa, 0xdc, 0x0c, 0x74,
	0x21, 0xcb, 0x2e, 0xad, 0x03, 0x39, 0x6d, 0x91, 0x84, 0x3c, 0x68, 0x30, 0x72, 0x5a, 0x56, 0x67,
	0xad, 0xc8, 0x55, 0x67, 0xb4, 0x09, 0x5b, 0x5c, 0x65, 0x53, 0xd1, 0xda, 0xc0, 0x8e, 0x2b, 0xd2,
	0x37, 0xb0, 0xf3, 0x42, 0xd8, 0x3e, 0x37, 0x2f, 0xd5, 0x3b, 0xcd, 0xc4, 0xfb, 0x0f, 0xa2, 0xb0,
	0x34, 0x81, 0xba, 0xd2, 0xa3, 0x9c, 0x9b, 0x91, 0xcc, 0x79, 0x26, 0x90, 0xb1, 0xc2, 0x40, 0xe9,
	0x12, 0x57, 0x76, 0x68, 0x0a, 0x0d, 0x8f, 0x30, 0x5a, 0x2a, 0x5b, 0xa0, 0x4c, 0x85, 0xd5, 0x10,
	0x32, 0xc0, 0x56, 0xfa, 0x3b, 0x02, 0x1a, 0x72, 0x17, 0x46, 0xab, 0x42, 0xd0, 0x5b, 0x10, 0xc9,
	0x31, 0x52, 0x56, 0x59, 0x24, 0xc7, 0x94, 0xc2, 0xa6, 0xe2, 0xb9, 0x40, 0x86, 0x2a, 0xc3, 0x67,
	0xfa, 0x0c, 0xd3, 0xf0, 0xea, 0xa5, 0xdf, 0x5a, 0xef, 0xa8, 0xb3, 0x0e, 0xa5, 0x73, 0x91, 0xb6,
	0xb3, 0xb4, 0xc6, 0x2a, 0xf9, 0xd2, 0xe4, 0x73, 0x80, 0xc0, 0xe1, 0x66, 0xb2, 0x71, 0x33, 0x1a,
	0xb4, 0xcf, 0x4a, 0x03, 0x6e, 0x90, 0xf8, 0x35, 0x54, 0x56, 0x83, 0x37, 0x61, 0xeb, 0xa3, 0x1c,
	0xdb, 0x89, 0x4f, 0xd9, 0x15, 0x74, 0x17, 0xb6, 0x27, 0x42, 0x66, 0x13, 0xeb, 0xe3, 0xf6, 0x55,
	0x89, 0x5e, 0xcf, 0x50, 0x67, 0xae, 0x88, 0x87, 0xc8, 0x87, 0xe4, 0xab, 0xe9, 0x49, 0x30, 0xfd,
	0x31, 0x54, 0x8c, 0xdf, 0x28, 0xf2, 0xd5, 0x7a, 0x7b, 0xa1, 0xeb, 0x60, 0xe1, 0x6c, 0x05, 0x4c,
	0x63, 0x68, 0x05, 0x07, 0x43, 0x3b, 0x13, 0x3c, 0xf7, 0xfb, 0x4c, 0x07, 0x70, 0xe7, 0x92, 0x33,
	0xbf, 0x8f, 0x50, 0x8d, 0xdc, 0x54, 0x6d, 0x17, 0x9a, 0xaf, 0xf4, 0x09, 0x5e, 0x45, 0x26, 0x0a,
	0x61, 0x97, 0x4a, 0x7b, 0x70, 0xfb, 0x9f, 0xbe, 0x53, 0xe9, 0xfd, 0x89, 0x60, 0xa3, 0xcf, 0x0d,
	0xcd, 0x01, 0xd6, 0xa9, 0xd3, 0x7b, 0x57, 0x6d, 0x03, 0xd9, 0xe2, 0xf6, 0xf5, 0xcb, 0x4a, 0x93,
	0xcf, 0x3f, 0x7e, 0x7d, 0x8d, 0x62, 0xda, 0xc2, 0xaf, 0x63, 0xde, 0xeb, 0x2a, 0x3e, 0xef, 0x66,
	0xc2, 0xba, 0xab, 0x5b, 0x0a, 0x7c, 0x21, 0xb0, 0x73, 0x61, 0x74, 0x7a, 0xff, 0x8a, 0x01, 0xcf,
	0xa5, 0x16, 0x1f, 0xfe, 0x07, 0xe5, 0x4d, 0x1c, 0xa1, 0x89, 0x03, 0xba, 0x1f, 0x9a, 0x70, 0xf7,
	0xce, 0xe1, 0x47, 0x05, 0xbe, 0xf0, 0x88, 0xd0, 0x4f, 0xd0, 0x38, 0x97, 0x0e, 0x4d, 0x42, 0x89,
	0xcb, 0x02, 0x8d, 0x0f, 0xae, 0x41, 0x78, 0x03, 0x87, 0x68, 0x60, 0x3f, 0x8d, 0x43, 0x03, 0x53,
	0x0f, 0x1d, 0xcd, 0x4a, 0xec, 0x63, 0xf2, 0xf0, 0x69, 0xfd, 0xdb, 0xa2, 0x4d, 0xbe, 0x2f, 0xda,
	0xe4, 0xe7, 0xa2, 0x4d, 0xde, 0x6e, 0xe3, 0xff, 0xe3, 0xf8, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x25, 0x4c, 0x01, 0xaa, 0x76, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MapClient is the client API for Map service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MapClient interface {
	GetMapInfo(ctx context.Context, in *GetMapInfoRequest, opts ...grpc.CallOption) (*GetMapInfoResponse, error)
	MapPositionStream(ctx context.Context, in *MapPositionStreamRequest, opts ...grpc.CallOption) (Map_MapPositionStreamClient, error)
	// 重置当前定位
	// 用于发生定位异常/错误状态，重新初始化导航定位
	// 重定位错误：定位状态超时|无地图|UWB错误
	// 重定位超时判断: 默认10s，仅在非错误状态下重置
	LocationReset(ctx context.Context, in *LocationResetRequest, opts ...grpc.CallOption) (*LocationResetResponse, error)
}

type mapClient struct {
	cc *grpc.ClientConn
}

func NewMapClient(cc *grpc.ClientConn) MapClient {
	return &mapClient{cc}
}

func (c *mapClient) GetMapInfo(ctx context.Context, in *GetMapInfoRequest, opts ...grpc.CallOption) (*GetMapInfoResponse, error) {
	out := new(GetMapInfoResponse)
	err := c.cc.Invoke(ctx, "/navService.Map/GetMapInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mapClient) MapPositionStream(ctx context.Context, in *MapPositionStreamRequest, opts ...grpc.CallOption) (Map_MapPositionStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Map_serviceDesc.Streams[0], "/navService.Map/MapPositionStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &mapMapPositionStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Map_MapPositionStreamClient interface {
	Recv() (*MapPositionStreamResponse, error)
	grpc.ClientStream
}

type mapMapPositionStreamClient struct {
	grpc.ClientStream
}

func (x *mapMapPositionStreamClient) Recv() (*MapPositionStreamResponse, error) {
	m := new(MapPositionStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mapClient) LocationReset(ctx context.Context, in *LocationResetRequest, opts ...grpc.CallOption) (*LocationResetResponse, error) {
	out := new(LocationResetResponse)
	err := c.cc.Invoke(ctx, "/navService.Map/LocationReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MapServer is the server API for Map service.
type MapServer interface {
	GetMapInfo(context.Context, *GetMapInfoRequest) (*GetMapInfoResponse, error)
	MapPositionStream(*MapPositionStreamRequest, Map_MapPositionStreamServer) error
	// 重置当前定位
	// 用于发生定位异常/错误状态，重新初始化导航定位
	// 重定位错误：定位状态超时|无地图|UWB错误
	// 重定位超时判断: 默认10s，仅在非错误状态下重置
	LocationReset(context.Context, *LocationResetRequest) (*LocationResetResponse, error)
}

// UnimplementedMapServer can be embedded to have forward compatible implementations.
type UnimplementedMapServer struct {
}

func (*UnimplementedMapServer) GetMapInfo(ctx context.Context, req *GetMapInfoRequest) (*GetMapInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMapInfo not implemented")
}
func (*UnimplementedMapServer) MapPositionStream(req *MapPositionStreamRequest, srv Map_MapPositionStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method MapPositionStream not implemented")
}
func (*UnimplementedMapServer) LocationReset(ctx context.Context, req *LocationResetRequest) (*LocationResetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocationReset not implemented")
}

func RegisterMapServer(s *grpc.Server, srv MapServer) {
	s.RegisterService(&_Map_serviceDesc, srv)
}

func _Map_GetMapInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMapInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).GetMapInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.Map/GetMapInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).GetMapInfo(ctx, req.(*GetMapInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Map_MapPositionStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MapPositionStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MapServer).MapPositionStream(m, &mapMapPositionStreamServer{stream})
}

type Map_MapPositionStreamServer interface {
	Send(*MapPositionStreamResponse) error
	grpc.ServerStream
}

type mapMapPositionStreamServer struct {
	grpc.ServerStream
}

func (x *mapMapPositionStreamServer) Send(m *MapPositionStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Map_LocationReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LocationResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MapServer).LocationReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.Map/LocationReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MapServer).LocationReset(ctx, req.(*LocationResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Map_serviceDesc = grpc.ServiceDesc{
	ServiceName: "navService.Map",
	HandlerType: (*MapServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMapInfo",
			Handler:    _Map_GetMapInfo_Handler,
		},
		{
			MethodName: "LocationReset",
			Handler:    _Map_LocationReset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MapPositionStream",
			Handler:       _Map_MapPositionStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "map.proto",
}

func (m *MapPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Angle != 0 {
		i = encodeVarintMap(dAtA, i, uint64(m.Angle))
		i--
		dAtA[i] = 0x18
	}
	if m.Y != 0 {
		i = encodeVarintMap(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintMap(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetMapInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMapInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMapInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NoMapPoints {
		i--
		if m.NoMapPoints {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NoMapImage {
		i--
		if m.NoMapImage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetMapInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMapInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMapInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MapPoints) > 0 {
		for iNdEx := len(m.MapPoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MapPoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMap(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MapImage != nil {
		{
			size, err := m.MapImage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMap(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMapInfoResponse_MapImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMapInfoResponse_MapImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMapInfoResponse_MapImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintMap(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintMap(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Width != 0 {
		i = encodeVarintMap(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetMapInfoResponse_MapPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMapInfoResponse_MapPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMapInfoResponse_MapPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMap(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MapPositionStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapPositionStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapPositionStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MapPositionStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MapPositionStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MapPositionStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Position != nil {
		{
			size, err := m.Position.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMap(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocationResetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationResetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationResetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *LocationResetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationResetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationResetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintMap(dAtA []byte, offset int, v uint64) int {
	offset -= sovMap(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MapPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovMap(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovMap(uint64(m.Y))
	}
	if m.Angle != 0 {
		n += 1 + sovMap(uint64(m.Angle))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMapInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoMapImage {
		n += 2
	}
	if m.NoMapPoints {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMapInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMap(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMap(uint64(l))
	}
	if m.MapImage != nil {
		l = m.MapImage.Size()
		n += 1 + l + sovMap(uint64(l))
	}
	if len(m.MapPoints) > 0 {
		for _, e := range m.MapPoints {
			l = e.Size()
			n += 1 + l + sovMap(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMapInfoResponse_MapImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovMap(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovMap(uint64(m.Height))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovMap(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMapInfoResponse_MapPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMap(uint64(l))
	}
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovMap(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MapPositionStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MapPositionStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Position != nil {
		l = m.Position.Size()
		n += 1 + l + sovMap(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationResetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationResetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMap(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMap(x uint64) (n int) {
	return sovMap(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MapPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			m.Angle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Angle |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMapInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMapInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMapInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoMapImage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoMapImage = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoMapPoints", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoMapPoints = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMapInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMapInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMapInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapImage == nil {
				m.MapImage = &GetMapInfoResponse_MapImage{}
			}
			if err := m.MapImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapPoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapPoints = append(m.MapPoints, &GetMapInfoResponse_MapPoint{})
			if err := m.MapPoints[len(m.MapPoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMapInfoResponse_MapImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = append(m.Image[:0], dAtA[iNdEx:postIndex]...)
			if m.Image == nil {
				m.Image = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMapInfoResponse_MapPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &MapPosition{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapPositionStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapPositionStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapPositionStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MapPositionStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MapPositionStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MapPositionStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMap
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMap
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMap
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Position == nil {
				m.Position = &MapPosition{}
			}
			if err := m.Position.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationResetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationResetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationResetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationResetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMap
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationResetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationResetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMap(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMap
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMap(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMap
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMap
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMap
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMap
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMap
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMap(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMap
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMap = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMap   = fmt.Errorf("proto: integer overflow")
)
