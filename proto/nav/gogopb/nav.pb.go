// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nav.proto

package navService

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type StatusCode int32

const (
	// 状态零值, 不使用
	StatusCode_UNKNOWN StatusCode = 0
	// 停止状态
	// 遥控移动状态: 已停止
	// 导航状态: 导航结束
	// 旋转状态: 旋转结束
	StatusCode_STOPPED StatusCode = 1
	// 移动中状态
	// 遥控移动状态: 遥控移动中
	// 导航状态: 导航移动中
	// 旋转状态: 旋转中
	StatusCode_MOVING StatusCode = 2
	// 准备状态
	// 导航状态: 导航准备中
	// 旋转状态: 旋转准备中
	StatusCode_PREPARING StatusCode = 3
	// 用户取消状态
	// 导航状态: 导航被中止
	// 旋转状态: 旋转被中止
	StatusCode_CANCEL StatusCode = 4
	// 遥控控制权释放状态
	// 遥控移动状态: 遥控权限超时释放,
	// 其它遥控端可接管遥控控制权,
	// 其它类型操作可接管
	StatusCode_RELEASED StatusCode = 5
	// 遇到障碍物
	// 遥控移动状态: 遥控移动遇到障碍物
	// 导航状态: 导航过程中遇到障碍(自动导航方式支持自动避障)
	StatusCode_ERR_OBSTACLE StatusCode = 10
	// 未就绪状态
	StatusCode_ERR_NOT_READY StatusCode = 11
	// 电机错误
	StatusCode_ERR_MOTOR_FAIL StatusCode = 12
	// 导航目标错误
	StatusCode_ERR_WRONG_TARGET StatusCode = 13
	// 操作被拒绝， 当前遥控移动中
	StatusCode_REJ_MOVING StatusCode = 20
	// 操作被拒绝， 当前导航中
	StatusCode_REJ_NAVING StatusCode = 21
	// 操作被拒绝， 当前充电中
	StatusCode_REJ_CHARGING StatusCode = 22
	// 操作被拒绝， 当前旋转中
	StatusCode_REJ_ROTATING StatusCode = 23
)

var StatusCode_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "STOPPED",
	2:  "MOVING",
	3:  "PREPARING",
	4:  "CANCEL",
	5:  "RELEASED",
	10: "ERR_OBSTACLE",
	11: "ERR_NOT_READY",
	12: "ERR_MOTOR_FAIL",
	13: "ERR_WRONG_TARGET",
	20: "REJ_MOVING",
	21: "REJ_NAVING",
	22: "REJ_CHARGING",
	23: "REJ_ROTATING",
}

var StatusCode_value = map[string]int32{
	"UNKNOWN":          0,
	"STOPPED":          1,
	"MOVING":           2,
	"PREPARING":        3,
	"CANCEL":           4,
	"RELEASED":         5,
	"ERR_OBSTACLE":     10,
	"ERR_NOT_READY":    11,
	"ERR_MOTOR_FAIL":   12,
	"ERR_WRONG_TARGET": 13,
	"REJ_MOVING":       20,
	"REJ_NAVING":       21,
	"REJ_CHARGING":     22,
	"REJ_ROTATING":     23,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}

func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{0}
}

// 移动方向
type MoveDirection int32

const (
	MoveDirection_RELEASE        MoveDirection = 0
	MoveDirection_FORWARD        MoveDirection = 1
	MoveDirection_BACKWARD       MoveDirection = 2
	MoveDirection_LEFT           MoveDirection = 3
	MoveDirection_RIGHT          MoveDirection = 4
	MoveDirection_LEFT_FORWARD   MoveDirection = 5
	MoveDirection_RIGHT_FORWARD  MoveDirection = 6
	MoveDirection_LEFT_BACKWARD  MoveDirection = 7
	MoveDirection_RIGHT_BACKWARD MoveDirection = 8
)

var MoveDirection_name = map[int32]string{
	0: "RELEASE",
	1: "FORWARD",
	2: "BACKWARD",
	3: "LEFT",
	4: "RIGHT",
	5: "LEFT_FORWARD",
	6: "RIGHT_FORWARD",
	7: "LEFT_BACKWARD",
	8: "RIGHT_BACKWARD",
}

var MoveDirection_value = map[string]int32{
	"RELEASE":        0,
	"FORWARD":        1,
	"BACKWARD":       2,
	"LEFT":           3,
	"RIGHT":          4,
	"LEFT_FORWARD":   5,
	"RIGHT_FORWARD":  6,
	"LEFT_BACKWARD":  7,
	"RIGHT_BACKWARD": 8,
}

func (x MoveDirection) String() string {
	return proto.EnumName(MoveDirection_name, int32(x))
}

func (MoveDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{1}
}

// 导航漫游方式
type RoamingType int32

const (
	RoamingType_ROAMING_TYPE_CONTINUE RoamingType = 0
	RoamingType_ROAMING_TYPE_ORDER    RoamingType = 1
	RoamingType_ROAMING_TYPE_RANDOM   RoamingType = 2
)

var RoamingType_name = map[int32]string{
	0: "ROAMING_TYPE_CONTINUE",
	1: "ROAMING_TYPE_ORDER",
	2: "ROAMING_TYPE_RANDOM",
}

var RoamingType_value = map[string]int32{
	"ROAMING_TYPE_CONTINUE": 0,
	"ROAMING_TYPE_ORDER":    1,
	"ROAMING_TYPE_RANDOM":   2,
}

func (x RoamingType) String() string {
	return proto.EnumName(RoamingType_name, int32(x))
}

func (RoamingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{2}
}

// 充电状态码
type ChargeStatusCode int32

const (
	// 状态零值
	ChargeStatusCode_CHARGE_STATUS_UNKNOWN ChargeStatusCode = 0
	// 准备中
	// 充电导航: 导航开始/CHARGE_STATUS_NAV_OBSTACLE导航恢复
	ChargeStatusCode_CHARGE_STATUS_PREPARING ChargeStatusCode = 1
	// 已释放
	// 充电断开结束完成与未充电时为此状态
	ChargeStatusCode_CHARGE_STATUS_RELEASED ChargeStatusCode = 2
	// 充电连接中
	ChargeStatusCode_CHARGE_STATUS_CONNECTING ChargeStatusCode = 3
	// 充电中
	ChargeStatusCode_CHARGE_STATUS_CHARGING ChargeStatusCode = 4
	// 充电断开中
	ChargeStatusCode_CHARGE_STATUS_DISCONNECTING ChargeStatusCode = 5
	// 连接失败
	ChargeStatusCode_CHARGE_CONNECT_FAIL ChargeStatusCode = 6
	// 充电导航过程遇到障碍
	// 2.2.7新增
	ChargeStatusCode_CHARGE_STATUS_NAV_OBSTACLE ChargeStatusCode = 7
)

var ChargeStatusCode_name = map[int32]string{
	0: "CHARGE_STATUS_UNKNOWN",
	1: "CHARGE_STATUS_PREPARING",
	2: "CHARGE_STATUS_RELEASED",
	3: "CHARGE_STATUS_CONNECTING",
	4: "CHARGE_STATUS_CHARGING",
	5: "CHARGE_STATUS_DISCONNECTING",
	6: "CHARGE_CONNECT_FAIL",
	7: "CHARGE_STATUS_NAV_OBSTACLE",
}

var ChargeStatusCode_value = map[string]int32{
	"CHARGE_STATUS_UNKNOWN":       0,
	"CHARGE_STATUS_PREPARING":     1,
	"CHARGE_STATUS_RELEASED":      2,
	"CHARGE_STATUS_CONNECTING":    3,
	"CHARGE_STATUS_CHARGING":      4,
	"CHARGE_STATUS_DISCONNECTING": 5,
	"CHARGE_CONNECT_FAIL":         6,
	"CHARGE_STATUS_NAV_OBSTACLE":  7,
}

func (x ChargeStatusCode) String() string {
	return proto.EnumName(ChargeStatusCode_name, int32(x))
}

func (ChargeStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{3}
}

// 导航事件
type NavEventType int32

const (
	NavEventType_NAV_EVENT_REVERSED NavEventType = 0
	NavEventType_MOVE_EVENT         NavEventType = 1
	NavEventType_NAV_EVENT          NavEventType = 2
	NavEventType_AUTO_CHARGE_EVENT  NavEventType = 3
	NavEventType_ROTATE_EVENT       NavEventType = 4
)

var NavEventType_name = map[int32]string{
	0: "NAV_EVENT_REVERSED",
	1: "MOVE_EVENT",
	2: "NAV_EVENT",
	3: "AUTO_CHARGE_EVENT",
	4: "ROTATE_EVENT",
}

var NavEventType_value = map[string]int32{
	"NAV_EVENT_REVERSED": 0,
	"MOVE_EVENT":         1,
	"NAV_EVENT":          2,
	"AUTO_CHARGE_EVENT":  3,
	"ROTATE_EVENT":       4,
}

func (x NavEventType) String() string {
	return proto.EnumName(NavEventType_name, int32(x))
}

func (NavEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{4}
}

type MoveRequest struct {
	Speed                uint32        `protobuf:"varint,1,opt,name=speed,proto3" json:"speed,omitempty"`
	Rspeed               uint32        `protobuf:"varint,2,opt,name=rspeed,proto3" json:"rspeed,omitempty"`
	Direction            MoveDirection `protobuf:"varint,3,opt,name=direction,proto3,enum=navService.MoveDirection" json:"direction,omitempty"`
	Mode                 string        `protobuf:"bytes,4,opt,name=mode,proto3" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MoveRequest) Reset()         { *m = MoveRequest{} }
func (m *MoveRequest) String() string { return proto.CompactTextString(m) }
func (*MoveRequest) ProtoMessage()    {}
func (*MoveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{0}
}
func (m *MoveRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveRequest.Merge(m, src)
}
func (m *MoveRequest) XXX_Size() int {
	return m.Size()
}
func (m *MoveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MoveRequest proto.InternalMessageInfo

func (m *MoveRequest) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *MoveRequest) GetRspeed() uint32 {
	if m != nil {
		return m.Rspeed
	}
	return 0
}

func (m *MoveRequest) GetDirection() MoveDirection {
	if m != nil {
		return m.Direction
	}
	return MoveDirection_RELEASE
}

func (m *MoveRequest) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

type MoveResponse struct {
	StatusCode           StatusCode `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3,enum=navService.StatusCode" json:"status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MoveResponse) Reset()         { *m = MoveResponse{} }
func (m *MoveResponse) String() string { return proto.CompactTextString(m) }
func (*MoveResponse) ProtoMessage()    {}
func (*MoveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{1}
}
func (m *MoveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveResponse.Merge(m, src)
}
func (m *MoveResponse) XXX_Size() int {
	return m.Size()
}
func (m *MoveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MoveResponse proto.InternalMessageInfo

func (m *MoveResponse) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_UNKNOWN
}

// 导航目标信息
// 判断顺序为index>name
type NavTarget struct {
	Index                string   `protobuf:"bytes,1,opt,name=index,proto3" json:"index,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NavTarget) Reset()         { *m = NavTarget{} }
func (m *NavTarget) String() string { return proto.CompactTextString(m) }
func (*NavTarget) ProtoMessage()    {}
func (*NavTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{2}
}
func (m *NavTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NavTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NavTarget.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NavTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NavTarget.Merge(m, src)
}
func (m *NavTarget) XXX_Size() int {
	return m.Size()
}
func (m *NavTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_NavTarget.DiscardUnknown(m)
}

var xxx_messageInfo_NavTarget proto.InternalMessageInfo

func (m *NavTarget) GetIndex() string {
	if m != nil {
		return m.Index
	}
	return ""
}

func (m *NavTarget) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type NavRoaming struct {
	NavRoamingType       RoamingType `protobuf:"varint,1,opt,name=nav_roaming_type,json=navRoamingType,proto3,enum=navService.RoamingType" json:"nav_roaming_type,omitempty"`
	WaitSec              int32       `protobuf:"varint,2,opt,name=wait_sec,json=waitSec,proto3" json:"wait_sec,omitempty"`
	RoamingTargetIndexes []string    `protobuf:"bytes,3,rep,name=roaming_target_indexes,json=roamingTargetIndexes,proto3" json:"roaming_target_indexes,omitempty"`
	OrderLoop            bool        `protobuf:"varint,4,opt,name=order_loop,json=orderLoop,proto3" json:"order_loop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NavRoaming) Reset()         { *m = NavRoaming{} }
func (m *NavRoaming) String() string { return proto.CompactTextString(m) }
func (*NavRoaming) ProtoMessage()    {}
func (*NavRoaming) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{3}
}
func (m *NavRoaming) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NavRoaming) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NavRoaming.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NavRoaming) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NavRoaming.Merge(m, src)
}
func (m *NavRoaming) XXX_Size() int {
	return m.Size()
}
func (m *NavRoaming) XXX_DiscardUnknown() {
	xxx_messageInfo_NavRoaming.DiscardUnknown(m)
}

var xxx_messageInfo_NavRoaming proto.InternalMessageInfo

func (m *NavRoaming) GetNavRoamingType() RoamingType {
	if m != nil {
		return m.NavRoamingType
	}
	return RoamingType_ROAMING_TYPE_CONTINUE
}

func (m *NavRoaming) GetWaitSec() int32 {
	if m != nil {
		return m.WaitSec
	}
	return 0
}

func (m *NavRoaming) GetRoamingTargetIndexes() []string {
	if m != nil {
		return m.RoamingTargetIndexes
	}
	return nil
}

func (m *NavRoaming) GetOrderLoop() bool {
	if m != nil {
		return m.OrderLoop
	}
	return false
}

// 导航请求
type NavToRequest struct {
	// Types that are valid to be assigned to TargetOneof:
	//	*NavToRequest_Target
	//	*NavToRequest_Roaming
	//	*NavToRequest_MapPosition
	TargetOneof isNavToRequest_TargetOneof `protobuf_oneof:"target_oneof"`
	Speed       uint32                     `protobuf:"varint,2,opt,name=speed,proto3" json:"speed,omitempty"`
	// 同步模式标识
	// *false: 当导航开始时立即返回PREPARING, 漫游模式强制为异步
	// true: 目标模式下当导航STOPPED|CANCEL|ERR*时返回
	SyncMode             bool     `protobuf:"varint,4,opt,name=sync_mode,json=syncMode,proto3" json:"sync_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NavToRequest) Reset()         { *m = NavToRequest{} }
func (m *NavToRequest) String() string { return proto.CompactTextString(m) }
func (*NavToRequest) ProtoMessage()    {}
func (*NavToRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{4}
}
func (m *NavToRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NavToRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NavToRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NavToRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NavToRequest.Merge(m, src)
}
func (m *NavToRequest) XXX_Size() int {
	return m.Size()
}
func (m *NavToRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NavToRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NavToRequest proto.InternalMessageInfo

type isNavToRequest_TargetOneof interface {
	isNavToRequest_TargetOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NavToRequest_Target struct {
	Target *NavTarget `protobuf:"bytes,1,opt,name=target,proto3,oneof"`
}
type NavToRequest_Roaming struct {
	Roaming *NavRoaming `protobuf:"bytes,3,opt,name=roaming,proto3,oneof"`
}
type NavToRequest_MapPosition struct {
	MapPosition *MapPosition `protobuf:"bytes,5,opt,name=map_position,json=mapPosition,proto3,oneof"`
}

func (*NavToRequest_Target) isNavToRequest_TargetOneof()      {}
func (*NavToRequest_Roaming) isNavToRequest_TargetOneof()     {}
func (*NavToRequest_MapPosition) isNavToRequest_TargetOneof() {}

func (m *NavToRequest) GetTargetOneof() isNavToRequest_TargetOneof {
	if m != nil {
		return m.TargetOneof
	}
	return nil
}

func (m *NavToRequest) GetTarget() *NavTarget {
	if x, ok := m.GetTargetOneof().(*NavToRequest_Target); ok {
		return x.Target
	}
	return nil
}

func (m *NavToRequest) GetRoaming() *NavRoaming {
	if x, ok := m.GetTargetOneof().(*NavToRequest_Roaming); ok {
		return x.Roaming
	}
	return nil
}

func (m *NavToRequest) GetMapPosition() *MapPosition {
	if x, ok := m.GetTargetOneof().(*NavToRequest_MapPosition); ok {
		return x.MapPosition
	}
	return nil
}

func (m *NavToRequest) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *NavToRequest) GetSyncMode() bool {
	if m != nil {
		return m.SyncMode
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NavToRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NavToRequest_OneofMarshaler, _NavToRequest_OneofUnmarshaler, _NavToRequest_OneofSizer, []interface{}{
		(*NavToRequest_Target)(nil),
		(*NavToRequest_Roaming)(nil),
		(*NavToRequest_MapPosition)(nil),
	}
}

func _NavToRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NavToRequest)
	// target_oneof
	switch x := m.TargetOneof.(type) {
	case *NavToRequest_Target:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Target); err != nil {
			return err
		}
	case *NavToRequest_Roaming:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Roaming); err != nil {
			return err
		}
	case *NavToRequest_MapPosition:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MapPosition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NavToRequest.TargetOneof has unexpected type %T", x)
	}
	return nil
}

func _NavToRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NavToRequest)
	switch tag {
	case 1: // target_oneof.target
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NavTarget)
		err := b.DecodeMessage(msg)
		m.TargetOneof = &NavToRequest_Target{msg}
		return true, err
	case 3: // target_oneof.roaming
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NavRoaming)
		err := b.DecodeMessage(msg)
		m.TargetOneof = &NavToRequest_Roaming{msg}
		return true, err
	case 5: // target_oneof.map_position
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MapPosition)
		err := b.DecodeMessage(msg)
		m.TargetOneof = &NavToRequest_MapPosition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NavToRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NavToRequest)
	// target_oneof
	switch x := m.TargetOneof.(type) {
	case *NavToRequest_Target:
		s := proto.Size(x.Target)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NavToRequest_Roaming:
		s := proto.Size(x.Roaming)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NavToRequest_MapPosition:
		s := proto.Size(x.MapPosition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// 导航状态
type NavToResponse struct {
	StatusCode StatusCode `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3,enum=navService.StatusCode" json:"status_code,omitempty"`
	// Types that are valid to be assigned to TargetOneof:
	//	*NavToResponse_Target
	//	*NavToResponse_IsRoaming
	//	*NavToResponse_MapPosition
	TargetOneof          isNavToResponse_TargetOneof `protobuf_oneof:"target_oneof"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *NavToResponse) Reset()         { *m = NavToResponse{} }
func (m *NavToResponse) String() string { return proto.CompactTextString(m) }
func (*NavToResponse) ProtoMessage()    {}
func (*NavToResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{5}
}
func (m *NavToResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NavToResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NavToResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NavToResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NavToResponse.Merge(m, src)
}
func (m *NavToResponse) XXX_Size() int {
	return m.Size()
}
func (m *NavToResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NavToResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NavToResponse proto.InternalMessageInfo

type isNavToResponse_TargetOneof interface {
	isNavToResponse_TargetOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NavToResponse_Target struct {
	Target *NavTarget `protobuf:"bytes,2,opt,name=target,proto3,oneof"`
}
type NavToResponse_IsRoaming struct {
	IsRoaming bool `protobuf:"varint,3,opt,name=is_roaming,json=isRoaming,proto3,oneof"`
}
type NavToResponse_MapPosition struct {
	MapPosition *MapPosition `protobuf:"bytes,4,opt,name=map_position,json=mapPosition,proto3,oneof"`
}

func (*NavToResponse_Target) isNavToResponse_TargetOneof()      {}
func (*NavToResponse_IsRoaming) isNavToResponse_TargetOneof()   {}
func (*NavToResponse_MapPosition) isNavToResponse_TargetOneof() {}

func (m *NavToResponse) GetTargetOneof() isNavToResponse_TargetOneof {
	if m != nil {
		return m.TargetOneof
	}
	return nil
}

func (m *NavToResponse) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_UNKNOWN
}

func (m *NavToResponse) GetTarget() *NavTarget {
	if x, ok := m.GetTargetOneof().(*NavToResponse_Target); ok {
		return x.Target
	}
	return nil
}

func (m *NavToResponse) GetIsRoaming() bool {
	if x, ok := m.GetTargetOneof().(*NavToResponse_IsRoaming); ok {
		return x.IsRoaming
	}
	return false
}

func (m *NavToResponse) GetMapPosition() *MapPosition {
	if x, ok := m.GetTargetOneof().(*NavToResponse_MapPosition); ok {
		return x.MapPosition
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NavToResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NavToResponse_OneofMarshaler, _NavToResponse_OneofUnmarshaler, _NavToResponse_OneofSizer, []interface{}{
		(*NavToResponse_Target)(nil),
		(*NavToResponse_IsRoaming)(nil),
		(*NavToResponse_MapPosition)(nil),
	}
}

func _NavToResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NavToResponse)
	// target_oneof
	switch x := m.TargetOneof.(type) {
	case *NavToResponse_Target:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Target); err != nil {
			return err
		}
	case *NavToResponse_IsRoaming:
		t := uint64(0)
		if x.IsRoaming {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *NavToResponse_MapPosition:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MapPosition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NavToResponse.TargetOneof has unexpected type %T", x)
	}
	return nil
}

func _NavToResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NavToResponse)
	switch tag {
	case 2: // target_oneof.target
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NavTarget)
		err := b.DecodeMessage(msg)
		m.TargetOneof = &NavToResponse_Target{msg}
		return true, err
	case 3: // target_oneof.is_roaming
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.TargetOneof = &NavToResponse_IsRoaming{x != 0}
		return true, err
	case 4: // target_oneof.map_position
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MapPosition)
		err := b.DecodeMessage(msg)
		m.TargetOneof = &NavToResponse_MapPosition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NavToResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NavToResponse)
	// target_oneof
	switch x := m.TargetOneof.(type) {
	case *NavToResponse_Target:
		s := proto.Size(x.Target)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NavToResponse_IsRoaming:
		n += 1 // tag and wire
		n += 1
	case *NavToResponse_MapPosition:
		s := proto.Size(x.MapPosition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// 导航停止请求
type NavStopRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NavStopRequest) Reset()         { *m = NavStopRequest{} }
func (m *NavStopRequest) String() string { return proto.CompactTextString(m) }
func (*NavStopRequest) ProtoMessage()    {}
func (*NavStopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{6}
}
func (m *NavStopRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NavStopRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NavStopRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NavStopRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NavStopRequest.Merge(m, src)
}
func (m *NavStopRequest) XXX_Size() int {
	return m.Size()
}
func (m *NavStopRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NavStopRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NavStopRequest proto.InternalMessageInfo

// 导航停止状态
type NavStopResponse struct {
	StatusCode           StatusCode `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3,enum=navService.StatusCode" json:"status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NavStopResponse) Reset()         { *m = NavStopResponse{} }
func (m *NavStopResponse) String() string { return proto.CompactTextString(m) }
func (*NavStopResponse) ProtoMessage()    {}
func (*NavStopResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{7}
}
func (m *NavStopResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NavStopResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NavStopResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NavStopResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NavStopResponse.Merge(m, src)
}
func (m *NavStopResponse) XXX_Size() int {
	return m.Size()
}
func (m *NavStopResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NavStopResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NavStopResponse proto.InternalMessageInfo

func (m *NavStopResponse) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_UNKNOWN
}

// 充电请求
type AutoChargeRequest struct {
	// Types that are valid to be assigned to ChargeOptionOneof:
	//	*AutoChargeRequest_Charge
	//	*AutoChargeRequest_Cancel
	//	*AutoChargeRequest_ChargePreset
	ChargeOptionOneof isAutoChargeRequest_ChargeOptionOneof `protobuf_oneof:"charge_option_oneof"`
	// 等待充电状态为CHARGE_STATUS_CHARGING的超时配置(秒), 默认60s
	TimeoutSec           uint32   `protobuf:"varint,4,opt,name=timeout_sec,json=timeoutSec,proto3" json:"timeout_sec,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutoChargeRequest) Reset()         { *m = AutoChargeRequest{} }
func (m *AutoChargeRequest) String() string { return proto.CompactTextString(m) }
func (*AutoChargeRequest) ProtoMessage()    {}
func (*AutoChargeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{8}
}
func (m *AutoChargeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoChargeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoChargeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoChargeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoChargeRequest.Merge(m, src)
}
func (m *AutoChargeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AutoChargeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoChargeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AutoChargeRequest proto.InternalMessageInfo

type isAutoChargeRequest_ChargeOptionOneof interface {
	isAutoChargeRequest_ChargeOptionOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AutoChargeRequest_Charge struct {
	Charge bool `protobuf:"varint,1,opt,name=charge,proto3,oneof"`
}
type AutoChargeRequest_Cancel struct {
	Cancel bool `protobuf:"varint,2,opt,name=cancel,proto3,oneof"`
}
type AutoChargeRequest_ChargePreset struct {
	ChargePreset bool `protobuf:"varint,3,opt,name=charge_preset,json=chargePreset,proto3,oneof"`
}

func (*AutoChargeRequest_Charge) isAutoChargeRequest_ChargeOptionOneof()       {}
func (*AutoChargeRequest_Cancel) isAutoChargeRequest_ChargeOptionOneof()       {}
func (*AutoChargeRequest_ChargePreset) isAutoChargeRequest_ChargeOptionOneof() {}

func (m *AutoChargeRequest) GetChargeOptionOneof() isAutoChargeRequest_ChargeOptionOneof {
	if m != nil {
		return m.ChargeOptionOneof
	}
	return nil
}

func (m *AutoChargeRequest) GetCharge() bool {
	if x, ok := m.GetChargeOptionOneof().(*AutoChargeRequest_Charge); ok {
		return x.Charge
	}
	return false
}

func (m *AutoChargeRequest) GetCancel() bool {
	if x, ok := m.GetChargeOptionOneof().(*AutoChargeRequest_Cancel); ok {
		return x.Cancel
	}
	return false
}

func (m *AutoChargeRequest) GetChargePreset() bool {
	if x, ok := m.GetChargeOptionOneof().(*AutoChargeRequest_ChargePreset); ok {
		return x.ChargePreset
	}
	return false
}

func (m *AutoChargeRequest) GetTimeoutSec() uint32 {
	if m != nil {
		return m.TimeoutSec
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AutoChargeRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AutoChargeRequest_OneofMarshaler, _AutoChargeRequest_OneofUnmarshaler, _AutoChargeRequest_OneofSizer, []interface{}{
		(*AutoChargeRequest_Charge)(nil),
		(*AutoChargeRequest_Cancel)(nil),
		(*AutoChargeRequest_ChargePreset)(nil),
	}
}

func _AutoChargeRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AutoChargeRequest)
	// charge_option_oneof
	switch x := m.ChargeOptionOneof.(type) {
	case *AutoChargeRequest_Charge:
		t := uint64(0)
		if x.Charge {
			t = 1
		}
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AutoChargeRequest_Cancel:
		t := uint64(0)
		if x.Cancel {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *AutoChargeRequest_ChargePreset:
		t := uint64(0)
		if x.ChargePreset {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("AutoChargeRequest.ChargeOptionOneof has unexpected type %T", x)
	}
	return nil
}

func _AutoChargeRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AutoChargeRequest)
	switch tag {
	case 1: // charge_option_oneof.charge
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ChargeOptionOneof = &AutoChargeRequest_Charge{x != 0}
		return true, err
	case 2: // charge_option_oneof.cancel
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ChargeOptionOneof = &AutoChargeRequest_Cancel{x != 0}
		return true, err
	case 3: // charge_option_oneof.charge_preset
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ChargeOptionOneof = &AutoChargeRequest_ChargePreset{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _AutoChargeRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AutoChargeRequest)
	// charge_option_oneof
	switch x := m.ChargeOptionOneof.(type) {
	case *AutoChargeRequest_Charge:
		n += 1 // tag and wire
		n += 1
	case *AutoChargeRequest_Cancel:
		n += 1 // tag and wire
		n += 1
	case *AutoChargeRequest_ChargePreset:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// 充电状态反馈
type AutoChargeResponse struct {
	ChargeStatusCode     ChargeStatusCode `protobuf:"varint,1,opt,name=charge_status_code,json=chargeStatusCode,proto3,enum=navService.ChargeStatusCode" json:"charge_status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AutoChargeResponse) Reset()         { *m = AutoChargeResponse{} }
func (m *AutoChargeResponse) String() string { return proto.CompactTextString(m) }
func (*AutoChargeResponse) ProtoMessage()    {}
func (*AutoChargeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{9}
}
func (m *AutoChargeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoChargeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoChargeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoChargeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoChargeResponse.Merge(m, src)
}
func (m *AutoChargeResponse) XXX_Size() int {
	return m.Size()
}
func (m *AutoChargeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoChargeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AutoChargeResponse proto.InternalMessageInfo

func (m *AutoChargeResponse) GetChargeStatusCode() ChargeStatusCode {
	if m != nil {
		return m.ChargeStatusCode
	}
	return ChargeStatusCode_CHARGE_STATUS_UNKNOWN
}

// 原地旋转请求
type RotateRequest struct {
	// Types that are valid to be assigned to RotateOneof:
	//	*RotateRequest_Angle
	//	*RotateRequest_Rollback
	RotateOneof          isRotateRequest_RotateOneof `protobuf_oneof:"rotate_oneof"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *RotateRequest) Reset()         { *m = RotateRequest{} }
func (m *RotateRequest) String() string { return proto.CompactTextString(m) }
func (*RotateRequest) ProtoMessage()    {}
func (*RotateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{10}
}
func (m *RotateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RotateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RotateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RotateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotateRequest.Merge(m, src)
}
func (m *RotateRequest) XXX_Size() int {
	return m.Size()
}
func (m *RotateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RotateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RotateRequest proto.InternalMessageInfo

type isRotateRequest_RotateOneof interface {
	isRotateRequest_RotateOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RotateRequest_Angle struct {
	Angle int32 `protobuf:"varint,1,opt,name=angle,proto3,oneof"`
}
type RotateRequest_Rollback struct {
	Rollback bool `protobuf:"varint,2,opt,name=rollback,proto3,oneof"`
}

func (*RotateRequest_Angle) isRotateRequest_RotateOneof()    {}
func (*RotateRequest_Rollback) isRotateRequest_RotateOneof() {}

func (m *RotateRequest) GetRotateOneof() isRotateRequest_RotateOneof {
	if m != nil {
		return m.RotateOneof
	}
	return nil
}

func (m *RotateRequest) GetAngle() int32 {
	if x, ok := m.GetRotateOneof().(*RotateRequest_Angle); ok {
		return x.Angle
	}
	return 0
}

func (m *RotateRequest) GetRollback() bool {
	if x, ok := m.GetRotateOneof().(*RotateRequest_Rollback); ok {
		return x.Rollback
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RotateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RotateRequest_OneofMarshaler, _RotateRequest_OneofUnmarshaler, _RotateRequest_OneofSizer, []interface{}{
		(*RotateRequest_Angle)(nil),
		(*RotateRequest_Rollback)(nil),
	}
}

func _RotateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RotateRequest)
	// rotate_oneof
	switch x := m.RotateOneof.(type) {
	case *RotateRequest_Angle:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Angle))
	case *RotateRequest_Rollback:
		t := uint64(0)
		if x.Rollback {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("RotateRequest.RotateOneof has unexpected type %T", x)
	}
	return nil
}

func _RotateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RotateRequest)
	switch tag {
	case 1: // rotate_oneof.angle
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.RotateOneof = &RotateRequest_Angle{int32(x)}
		return true, err
	case 2: // rotate_oneof.rollback
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.RotateOneof = &RotateRequest_Rollback{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _RotateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RotateRequest)
	// rotate_oneof
	switch x := m.RotateOneof.(type) {
	case *RotateRequest_Angle:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Angle))
	case *RotateRequest_Rollback:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RotateResponse struct {
	StatusCode           StatusCode `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3,enum=navService.StatusCode" json:"status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RotateResponse) Reset()         { *m = RotateResponse{} }
func (m *RotateResponse) String() string { return proto.CompactTextString(m) }
func (*RotateResponse) ProtoMessage()    {}
func (*RotateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{11}
}
func (m *RotateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RotateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RotateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RotateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotateResponse.Merge(m, src)
}
func (m *RotateResponse) XXX_Size() int {
	return m.Size()
}
func (m *RotateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RotateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RotateResponse proto.InternalMessageInfo

func (m *RotateResponse) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_UNKNOWN
}

type OnNavEventChangeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnNavEventChangeRequest) Reset()         { *m = OnNavEventChangeRequest{} }
func (m *OnNavEventChangeRequest) String() string { return proto.CompactTextString(m) }
func (*OnNavEventChangeRequest) ProtoMessage()    {}
func (*OnNavEventChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{12}
}
func (m *OnNavEventChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnNavEventChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnNavEventChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnNavEventChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnNavEventChangeRequest.Merge(m, src)
}
func (m *OnNavEventChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *OnNavEventChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnNavEventChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnNavEventChangeRequest proto.InternalMessageInfo

type MoveEvent struct {
	StatusCode           StatusCode `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3,enum=navService.StatusCode" json:"status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *MoveEvent) Reset()         { *m = MoveEvent{} }
func (m *MoveEvent) String() string { return proto.CompactTextString(m) }
func (*MoveEvent) ProtoMessage()    {}
func (*MoveEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{13}
}
func (m *MoveEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoveEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoveEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoveEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoveEvent.Merge(m, src)
}
func (m *MoveEvent) XXX_Size() int {
	return m.Size()
}
func (m *MoveEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MoveEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MoveEvent proto.InternalMessageInfo

func (m *MoveEvent) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_UNKNOWN
}

type NavEvent struct {
	StatusCode           StatusCode `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3,enum=navService.StatusCode" json:"status_code,omitempty"`
	NavTarget            *NavTarget `protobuf:"bytes,2,opt,name=nav_target,json=navTarget,proto3" json:"nav_target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NavEvent) Reset()         { *m = NavEvent{} }
func (m *NavEvent) String() string { return proto.CompactTextString(m) }
func (*NavEvent) ProtoMessage()    {}
func (*NavEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{14}
}
func (m *NavEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NavEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NavEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NavEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NavEvent.Merge(m, src)
}
func (m *NavEvent) XXX_Size() int {
	return m.Size()
}
func (m *NavEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_NavEvent.DiscardUnknown(m)
}

var xxx_messageInfo_NavEvent proto.InternalMessageInfo

func (m *NavEvent) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_UNKNOWN
}

func (m *NavEvent) GetNavTarget() *NavTarget {
	if m != nil {
		return m.NavTarget
	}
	return nil
}

type AutoChargeEvent struct {
	ChargeStatusCode     ChargeStatusCode `protobuf:"varint,1,opt,name=charge_status_code,json=chargeStatusCode,proto3,enum=navService.ChargeStatusCode" json:"charge_status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AutoChargeEvent) Reset()         { *m = AutoChargeEvent{} }
func (m *AutoChargeEvent) String() string { return proto.CompactTextString(m) }
func (*AutoChargeEvent) ProtoMessage()    {}
func (*AutoChargeEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{15}
}
func (m *AutoChargeEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AutoChargeEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AutoChargeEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AutoChargeEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutoChargeEvent.Merge(m, src)
}
func (m *AutoChargeEvent) XXX_Size() int {
	return m.Size()
}
func (m *AutoChargeEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_AutoChargeEvent.DiscardUnknown(m)
}

var xxx_messageInfo_AutoChargeEvent proto.InternalMessageInfo

func (m *AutoChargeEvent) GetChargeStatusCode() ChargeStatusCode {
	if m != nil {
		return m.ChargeStatusCode
	}
	return ChargeStatusCode_CHARGE_STATUS_UNKNOWN
}

type RotateEvent struct {
	StatusCode           StatusCode `protobuf:"varint,1,opt,name=status_code,json=statusCode,proto3,enum=navService.StatusCode" json:"status_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RotateEvent) Reset()         { *m = RotateEvent{} }
func (m *RotateEvent) String() string { return proto.CompactTextString(m) }
func (*RotateEvent) ProtoMessage()    {}
func (*RotateEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{16}
}
func (m *RotateEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RotateEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RotateEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RotateEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotateEvent.Merge(m, src)
}
func (m *RotateEvent) XXX_Size() int {
	return m.Size()
}
func (m *RotateEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RotateEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RotateEvent proto.InternalMessageInfo

func (m *RotateEvent) GetStatusCode() StatusCode {
	if m != nil {
		return m.StatusCode
	}
	return StatusCode_UNKNOWN
}

type OnNavEventChangeResponse struct {
	NavEventType NavEventType `protobuf:"varint,1,opt,name=nav_event_type,json=navEventType,proto3,enum=navService.NavEventType" json:"nav_event_type,omitempty"`
	// Types that are valid to be assigned to ChangeOneof:
	//	*OnNavEventChangeResponse_MoveEvent
	//	*OnNavEventChangeResponse_NavEvent
	//	*OnNavEventChangeResponse_RotateEvent
	//	*OnNavEventChangeResponse_AutoChargeEvent
	ChangeOneof          isOnNavEventChangeResponse_ChangeOneof `protobuf_oneof:"change_oneof"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *OnNavEventChangeResponse) Reset()         { *m = OnNavEventChangeResponse{} }
func (m *OnNavEventChangeResponse) String() string { return proto.CompactTextString(m) }
func (*OnNavEventChangeResponse) ProtoMessage()    {}
func (*OnNavEventChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{17}
}
func (m *OnNavEventChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnNavEventChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnNavEventChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnNavEventChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnNavEventChangeResponse.Merge(m, src)
}
func (m *OnNavEventChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *OnNavEventChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OnNavEventChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OnNavEventChangeResponse proto.InternalMessageInfo

type isOnNavEventChangeResponse_ChangeOneof interface {
	isOnNavEventChangeResponse_ChangeOneof()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OnNavEventChangeResponse_MoveEvent struct {
	MoveEvent *MoveEvent `protobuf:"bytes,2,opt,name=move_event,json=moveEvent,proto3,oneof"`
}
type OnNavEventChangeResponse_NavEvent struct {
	NavEvent *NavEvent `protobuf:"bytes,3,opt,name=nav_event,json=navEvent,proto3,oneof"`
}
type OnNavEventChangeResponse_RotateEvent struct {
	RotateEvent *RotateEvent `protobuf:"bytes,4,opt,name=rotate_event,json=rotateEvent,proto3,oneof"`
}
type OnNavEventChangeResponse_AutoChargeEvent struct {
	AutoChargeEvent *AutoChargeEvent `protobuf:"bytes,5,opt,name=auto_charge_event,json=autoChargeEvent,proto3,oneof"`
}

func (*OnNavEventChangeResponse_MoveEvent) isOnNavEventChangeResponse_ChangeOneof()       {}
func (*OnNavEventChangeResponse_NavEvent) isOnNavEventChangeResponse_ChangeOneof()        {}
func (*OnNavEventChangeResponse_RotateEvent) isOnNavEventChangeResponse_ChangeOneof()     {}
func (*OnNavEventChangeResponse_AutoChargeEvent) isOnNavEventChangeResponse_ChangeOneof() {}

func (m *OnNavEventChangeResponse) GetChangeOneof() isOnNavEventChangeResponse_ChangeOneof {
	if m != nil {
		return m.ChangeOneof
	}
	return nil
}

func (m *OnNavEventChangeResponse) GetNavEventType() NavEventType {
	if m != nil {
		return m.NavEventType
	}
	return NavEventType_NAV_EVENT_REVERSED
}

func (m *OnNavEventChangeResponse) GetMoveEvent() *MoveEvent {
	if x, ok := m.GetChangeOneof().(*OnNavEventChangeResponse_MoveEvent); ok {
		return x.MoveEvent
	}
	return nil
}

func (m *OnNavEventChangeResponse) GetNavEvent() *NavEvent {
	if x, ok := m.GetChangeOneof().(*OnNavEventChangeResponse_NavEvent); ok {
		return x.NavEvent
	}
	return nil
}

func (m *OnNavEventChangeResponse) GetRotateEvent() *RotateEvent {
	if x, ok := m.GetChangeOneof().(*OnNavEventChangeResponse_RotateEvent); ok {
		return x.RotateEvent
	}
	return nil
}

func (m *OnNavEventChangeResponse) GetAutoChargeEvent() *AutoChargeEvent {
	if x, ok := m.GetChangeOneof().(*OnNavEventChangeResponse_AutoChargeEvent); ok {
		return x.AutoChargeEvent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OnNavEventChangeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _OnNavEventChangeResponse_OneofMarshaler, _OnNavEventChangeResponse_OneofUnmarshaler, _OnNavEventChangeResponse_OneofSizer, []interface{}{
		(*OnNavEventChangeResponse_MoveEvent)(nil),
		(*OnNavEventChangeResponse_NavEvent)(nil),
		(*OnNavEventChangeResponse_RotateEvent)(nil),
		(*OnNavEventChangeResponse_AutoChargeEvent)(nil),
	}
}

func _OnNavEventChangeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OnNavEventChangeResponse)
	// change_oneof
	switch x := m.ChangeOneof.(type) {
	case *OnNavEventChangeResponse_MoveEvent:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MoveEvent); err != nil {
			return err
		}
	case *OnNavEventChangeResponse_NavEvent:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NavEvent); err != nil {
			return err
		}
	case *OnNavEventChangeResponse_RotateEvent:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RotateEvent); err != nil {
			return err
		}
	case *OnNavEventChangeResponse_AutoChargeEvent:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AutoChargeEvent); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("OnNavEventChangeResponse.ChangeOneof has unexpected type %T", x)
	}
	return nil
}

func _OnNavEventChangeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OnNavEventChangeResponse)
	switch tag {
	case 2: // change_oneof.move_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MoveEvent)
		err := b.DecodeMessage(msg)
		m.ChangeOneof = &OnNavEventChangeResponse_MoveEvent{msg}
		return true, err
	case 3: // change_oneof.nav_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NavEvent)
		err := b.DecodeMessage(msg)
		m.ChangeOneof = &OnNavEventChangeResponse_NavEvent{msg}
		return true, err
	case 4: // change_oneof.rotate_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RotateEvent)
		err := b.DecodeMessage(msg)
		m.ChangeOneof = &OnNavEventChangeResponse_RotateEvent{msg}
		return true, err
	case 5: // change_oneof.auto_charge_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AutoChargeEvent)
		err := b.DecodeMessage(msg)
		m.ChangeOneof = &OnNavEventChangeResponse_AutoChargeEvent{msg}
		return true, err
	default:
		return false, nil
	}
}

func _OnNavEventChangeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*OnNavEventChangeResponse)
	// change_oneof
	switch x := m.ChangeOneof.(type) {
	case *OnNavEventChangeResponse_MoveEvent:
		s := proto.Size(x.MoveEvent)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OnNavEventChangeResponse_NavEvent:
		s := proto.Size(x.NavEvent)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OnNavEventChangeResponse_RotateEvent:
		s := proto.Size(x.RotateEvent)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *OnNavEventChangeResponse_AutoChargeEvent:
		s := proto.Size(x.AutoChargeEvent)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// 线路数据
type Route struct {
	Id                   string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string        `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	IsActive             bool          `protobuf:"varint,3,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	RoutePoints          []*RoutePoint `protobuf:"bytes,4,rep,name=route_points,json=routePoints,proto3" json:"route_points,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Route) Reset()         { *m = Route{} }
func (m *Route) String() string { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()    {}
func (*Route) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{18}
}
func (m *Route) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Route) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Route.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Route) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Route.Merge(m, src)
}
func (m *Route) XXX_Size() int {
	return m.Size()
}
func (m *Route) XXX_DiscardUnknown() {
	xxx_messageInfo_Route.DiscardUnknown(m)
}

var xxx_messageInfo_Route proto.InternalMessageInfo

func (m *Route) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Route) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Route) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *Route) GetRoutePoints() []*RoutePoint {
	if m != nil {
		return m.RoutePoints
	}
	return nil
}

// 线路点数据
type RoutePoint struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Rotate               uint32   `protobuf:"varint,2,opt,name=rotate,proto3" json:"rotate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoutePoint) Reset()         { *m = RoutePoint{} }
func (m *RoutePoint) String() string { return proto.CompactTextString(m) }
func (*RoutePoint) ProtoMessage()    {}
func (*RoutePoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{19}
}
func (m *RoutePoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoutePoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoutePoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoutePoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoutePoint.Merge(m, src)
}
func (m *RoutePoint) XXX_Size() int {
	return m.Size()
}
func (m *RoutePoint) XXX_DiscardUnknown() {
	xxx_messageInfo_RoutePoint.DiscardUnknown(m)
}

var xxx_messageInfo_RoutePoint proto.InternalMessageInfo

func (m *RoutePoint) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RoutePoint) GetRotate() uint32 {
	if m != nil {
		return m.Rotate
	}
	return 0
}

// 创建线路请求
// route.name为空时将创建随机名
// route.is_active仅允许唯一激活, 若创建线路指定为激活将自动设置此线路为激活
// route.route_points若为空将自动创建默认数量线路点
type NewRouteRequest struct {
	Route                *Route   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewRouteRequest) Reset()         { *m = NewRouteRequest{} }
func (m *NewRouteRequest) String() string { return proto.CompactTextString(m) }
func (*NewRouteRequest) ProtoMessage()    {}
func (*NewRouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{20}
}
func (m *NewRouteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewRouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewRouteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewRouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewRouteRequest.Merge(m, src)
}
func (m *NewRouteRequest) XXX_Size() int {
	return m.Size()
}
func (m *NewRouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewRouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewRouteRequest proto.InternalMessageInfo

func (m *NewRouteRequest) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

type NewRouteResponse struct {
	Route                *Route   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewRouteResponse) Reset()         { *m = NewRouteResponse{} }
func (m *NewRouteResponse) String() string { return proto.CompactTextString(m) }
func (*NewRouteResponse) ProtoMessage()    {}
func (*NewRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{21}
}
func (m *NewRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewRouteResponse.Merge(m, src)
}
func (m *NewRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *NewRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NewRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NewRouteResponse proto.InternalMessageInfo

func (m *NewRouteResponse) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

type ListRoutesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRoutesRequest) Reset()         { *m = ListRoutesRequest{} }
func (m *ListRoutesRequest) String() string { return proto.CompactTextString(m) }
func (*ListRoutesRequest) ProtoMessage()    {}
func (*ListRoutesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{22}
}
func (m *ListRoutesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRoutesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRoutesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRoutesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRoutesRequest.Merge(m, src)
}
func (m *ListRoutesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRoutesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRoutesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRoutesRequest proto.InternalMessageInfo

type ListRoutesResponse struct {
	Routes               []*Route `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRoutesResponse) Reset()         { *m = ListRoutesResponse{} }
func (m *ListRoutesResponse) String() string { return proto.CompactTextString(m) }
func (*ListRoutesResponse) ProtoMessage()    {}
func (*ListRoutesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{23}
}
func (m *ListRoutesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRoutesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRoutesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRoutesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRoutesResponse.Merge(m, src)
}
func (m *ListRoutesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListRoutesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRoutesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRoutesResponse proto.InternalMessageInfo

func (m *ListRoutesResponse) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

type GetRouteRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRouteRequest) Reset()         { *m = GetRouteRequest{} }
func (m *GetRouteRequest) String() string { return proto.CompactTextString(m) }
func (*GetRouteRequest) ProtoMessage()    {}
func (*GetRouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{24}
}
func (m *GetRouteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRouteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRouteRequest.Merge(m, src)
}
func (m *GetRouteRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRouteRequest proto.InternalMessageInfo

func (m *GetRouteRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GetRouteResponse struct {
	Route                *Route   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRouteResponse) Reset()         { *m = GetRouteResponse{} }
func (m *GetRouteResponse) String() string { return proto.CompactTextString(m) }
func (*GetRouteResponse) ProtoMessage()    {}
func (*GetRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{25}
}
func (m *GetRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRouteResponse.Merge(m, src)
}
func (m *GetRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRouteResponse proto.InternalMessageInfo

func (m *GetRouteResponse) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

// 更新线路请求
// route.id根据此id获取线路
// route.name不可为空
// route.route_points不可为空
type UpdateRouteRequest struct {
	Route                *Route   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateRouteRequest) Reset()         { *m = UpdateRouteRequest{} }
func (m *UpdateRouteRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateRouteRequest) ProtoMessage()    {}
func (*UpdateRouteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{26}
}
func (m *UpdateRouteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateRouteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateRouteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateRouteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateRouteRequest.Merge(m, src)
}
func (m *UpdateRouteRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateRouteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateRouteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateRouteRequest proto.InternalMessageInfo

func (m *UpdateRouteRequest) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

type UpdateRouteResponse struct {
	Route                *Route   `protobuf:"bytes,1,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateRouteResponse) Reset()         { *m = UpdateRouteResponse{} }
func (m *UpdateRouteResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateRouteResponse) ProtoMessage()    {}
func (*UpdateRouteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{27}
}
func (m *UpdateRouteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateRouteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateRouteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateRouteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateRouteResponse.Merge(m, src)
}
func (m *UpdateRouteResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateRouteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateRouteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateRouteResponse proto.InternalMessageInfo

func (m *UpdateRouteResponse) GetRoute() *Route {
	if m != nil {
		return m.Route
	}
	return nil
}

type DeleteRoutesRequest struct {
	RoutesId             []string `protobuf:"bytes,1,rep,name=routes_id,json=routesId,proto3" json:"routes_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRoutesRequest) Reset()         { *m = DeleteRoutesRequest{} }
func (m *DeleteRoutesRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRoutesRequest) ProtoMessage()    {}
func (*DeleteRoutesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{28}
}
func (m *DeleteRoutesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRoutesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRoutesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRoutesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRoutesRequest.Merge(m, src)
}
func (m *DeleteRoutesRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRoutesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRoutesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRoutesRequest proto.InternalMessageInfo

func (m *DeleteRoutesRequest) GetRoutesId() []string {
	if m != nil {
		return m.RoutesId
	}
	return nil
}

type DeleteRoutesResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRoutesResponse) Reset()         { *m = DeleteRoutesResponse{} }
func (m *DeleteRoutesResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteRoutesResponse) ProtoMessage()    {}
func (*DeleteRoutesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e03fef413b705070, []int{29}
}
func (m *DeleteRoutesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRoutesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRoutesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRoutesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRoutesResponse.Merge(m, src)
}
func (m *DeleteRoutesResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRoutesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRoutesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRoutesResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("navService.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterEnum("navService.MoveDirection", MoveDirection_name, MoveDirection_value)
	proto.RegisterEnum("navService.RoamingType", RoamingType_name, RoamingType_value)
	proto.RegisterEnum("navService.ChargeStatusCode", ChargeStatusCode_name, ChargeStatusCode_value)
	proto.RegisterEnum("navService.NavEventType", NavEventType_name, NavEventType_value)
	proto.RegisterType((*MoveRequest)(nil), "navService.MoveRequest")
	proto.RegisterType((*MoveResponse)(nil), "navService.MoveResponse")
	proto.RegisterType((*NavTarget)(nil), "navService.NavTarget")
	proto.RegisterType((*NavRoaming)(nil), "navService.NavRoaming")
	proto.RegisterType((*NavToRequest)(nil), "navService.NavToRequest")
	proto.RegisterType((*NavToResponse)(nil), "navService.NavToResponse")
	proto.RegisterType((*NavStopRequest)(nil), "navService.NavStopRequest")
	proto.RegisterType((*NavStopResponse)(nil), "navService.NavStopResponse")
	proto.RegisterType((*AutoChargeRequest)(nil), "navService.AutoChargeRequest")
	proto.RegisterType((*AutoChargeResponse)(nil), "navService.AutoChargeResponse")
	proto.RegisterType((*RotateRequest)(nil), "navService.RotateRequest")
	proto.RegisterType((*RotateResponse)(nil), "navService.RotateResponse")
	proto.RegisterType((*OnNavEventChangeRequest)(nil), "navService.OnNavEventChangeRequest")
	proto.RegisterType((*MoveEvent)(nil), "navService.MoveEvent")
	proto.RegisterType((*NavEvent)(nil), "navService.NavEvent")
	proto.RegisterType((*AutoChargeEvent)(nil), "navService.AutoChargeEvent")
	proto.RegisterType((*RotateEvent)(nil), "navService.RotateEvent")
	proto.RegisterType((*OnNavEventChangeResponse)(nil), "navService.OnNavEventChangeResponse")
	proto.RegisterType((*Route)(nil), "navService.Route")
	proto.RegisterType((*RoutePoint)(nil), "navService.RoutePoint")
	proto.RegisterType((*NewRouteRequest)(nil), "navService.NewRouteRequest")
	proto.RegisterType((*NewRouteResponse)(nil), "navService.NewRouteResponse")
	proto.RegisterType((*ListRoutesRequest)(nil), "navService.ListRoutesRequest")
	proto.RegisterType((*ListRoutesResponse)(nil), "navService.ListRoutesResponse")
	proto.RegisterType((*GetRouteRequest)(nil), "navService.GetRouteRequest")
	proto.RegisterType((*GetRouteResponse)(nil), "navService.GetRouteResponse")
	proto.RegisterType((*UpdateRouteRequest)(nil), "navService.UpdateRouteRequest")
	proto.RegisterType((*UpdateRouteResponse)(nil), "navService.UpdateRouteResponse")
	proto.RegisterType((*DeleteRoutesRequest)(nil), "navService.DeleteRoutesRequest")
	proto.RegisterType((*DeleteRoutesResponse)(nil), "navService.DeleteRoutesResponse")
}

func init() { proto.RegisterFile("nav.proto", fileDescriptor_e03fef413b705070) }

var fileDescriptor_e03fef413b705070 = []byte{
	// 1814 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x73, 0x23, 0x47,
	0x15, 0xf7, 0xc8, 0x92, 0x2d, 0x3d, 0xc9, 0xf6, 0xb8, 0xfd, 0x25, 0xcb, 0x5e, 0xdb, 0x99, 0x84,
	0x8a, 0xf1, 0x61, 0x9d, 0x72, 0x02, 0x81, 0x00, 0xa1, 0xc6, 0xf2, 0xac, 0xad, 0x8d, 0x3d, 0xe3,
	0x6a, 0xc9, 0xde, 0xda, 0xa2, 0x60, 0x98, 0x48, 0x8d, 0x33, 0x85, 0x3d, 0x3d, 0x68, 0xc6, 0x5a,
	0xf6, 0x0a, 0x97, 0xdc, 0xb9, 0xf0, 0x17, 0xf0, 0x6f, 0x70, 0xe5, 0x44, 0x51, 0xc5, 0x3f, 0x90,
	0xda, 0xe2, 0xc0, 0x89, 0x13, 0x27, 0x4e, 0xd4, 0xeb, 0xee, 0xf9, 0x92, 0xe4, 0xd4, 0x7e, 0xe4,
	0x36, 0xef, 0xa3, 0xdf, 0xef, 0x7d, 0x75, 0xbf, 0x27, 0x41, 0x2d, 0xf0, 0x46, 0x8f, 0xc3, 0x21,
	0x8f, 0x39, 0x81, 0xc0, 0x1b, 0x75, 0xd9, 0x70, 0xe4, 0xf7, 0x59, 0x6b, 0xfb, 0x86, 0xf3, 0x9b,
	0x5b, 0x76, 0xe8, 0x85, 0xfe, 0xa1, 0x17, 0x04, 0x3c, 0xf6, 0x62, 0x9f, 0x07, 0x91, 0xd4, 0x6c,
	0xd5, 0xee, 0xbc, 0x50, 0x7e, 0x1a, 0x5f, 0x6b, 0x50, 0xbf, 0xe0, 0x23, 0x46, 0xd9, 0xef, 0xee,
	0x59, 0x14, 0x93, 0x55, 0xa8, 0x44, 0x21, 0x63, 0x83, 0xa6, 0xb6, 0xa7, 0xed, 0x2f, 0x50, 0x49,
	0x90, 0x75, 0x98, 0x1b, 0x4a, 0x76, 0x49, 0xb0, 0x15, 0x45, 0x3e, 0x85, 0xda, 0xc0, 0x1f, 0xb2,
	0x3e, 0x1a, 0x6f, 0xce, 0xee, 0x69, 0xfb, 0x8b, 0x47, 0x9b, 0x8f, 0x33, 0x37, 0x1e, 0xa3, 0xe5,
	0x93, 0x44, 0x81, 0x66, 0xba, 0x84, 0x40, 0xf9, 0x8e, 0x0f, 0x58, 0xb3, 0xbc, 0xa7, 0xed, 0xd7,
	0xa8, 0xf8, 0x36, 0x4e, 0xa1, 0x21, 0x3d, 0x89, 0x42, 0x1e, 0x44, 0x8c, 0x7c, 0x0a, 0xf5, 0x28,
	0xf6, 0xe2, 0xfb, 0xc8, 0xed, 0xa3, 0xaa, 0x26, 0xcc, 0xaf, 0xe7, 0xcd, 0x77, 0x85, 0xb8, 0xcd,
	0x07, 0x8c, 0x42, 0x94, 0x7e, 0x1b, 0x3f, 0x80, 0x9a, 0xed, 0x8d, 0x7a, 0xde, 0xf0, 0x86, 0x89,
	0x80, 0xfc, 0x60, 0xc0, 0x7e, 0x2f, 0xce, 0xd7, 0xa8, 0x24, 0x10, 0x3f, 0xf0, 0xee, 0x98, 0x08,
	0xa7, 0x46, 0xc5, 0xb7, 0xf1, 0x57, 0x0d, 0xc0, 0xf6, 0x46, 0x94, 0x7b, 0x77, 0x7e, 0x70, 0x43,
	0x4c, 0xd0, 0x03, 0x6f, 0xe4, 0x0e, 0x25, 0xe9, 0xc6, 0x2f, 0xc3, 0xc4, 0x87, 0x8d, 0xbc, 0x0f,
	0x4a, 0xbd, 0xf7, 0x32, 0x64, 0x74, 0x31, 0x48, 0x8f, 0x23, 0x4d, 0x36, 0xa1, 0xfa, 0xc2, 0xf3,
	0x63, 0x37, 0x62, 0x7d, 0x81, 0x54, 0xa1, 0xf3, 0x48, 0x77, 0x59, 0x9f, 0x7c, 0x02, 0xeb, 0xa9,
	0x65, 0xe1, 0xa8, 0x2b, 0x1c, 0x63, 0x51, 0x73, 0x76, 0x6f, 0x76, 0xbf, 0x46, 0x57, 0x95, 0x54,
	0x46, 0xd1, 0x91, 0x32, 0xf2, 0x08, 0x80, 0x0f, 0x07, 0x6c, 0xe8, 0xde, 0x72, 0x1e, 0x8a, 0xe4,
	0x55, 0x69, 0x4d, 0x70, 0xce, 0x39, 0x0f, 0x8d, 0xff, 0x6a, 0xd0, 0xc0, 0xc8, 0x79, 0x52, 0xcd,
	0x43, 0x98, 0x93, 0xd6, 0x85, 0xe7, 0xf5, 0xa3, 0xb5, 0xbc, 0xe7, 0x69, 0x8e, 0xce, 0x66, 0xa8,
	0x52, 0x23, 0x47, 0x30, 0xaf, 0x80, 0x45, 0x39, 0xeb, 0xc5, 0x7c, 0x67, 0xd9, 0x39, 0x9b, 0xa1,
	0x89, 0x22, 0xf9, 0x29, 0x34, 0xee, 0xbc, 0xd0, 0x0d, 0x79, 0xe4, 0x8b, 0x3e, 0xa8, 0x88, 0x83,
	0x85, 0x24, 0x5d, 0x78, 0xe1, 0xa5, 0x12, 0x9f, 0xcd, 0xd0, 0xfa, 0x5d, 0x46, 0x66, 0x0d, 0x57,
	0xca, 0x37, 0xdc, 0x16, 0xd4, 0xa2, 0x97, 0x41, 0xdf, 0x4d, 0x9b, 0xa4, 0x4a, 0xab, 0xc8, 0xb8,
	0xe0, 0x03, 0x76, 0xbc, 0x08, 0x0d, 0x95, 0x33, 0x1e, 0x30, 0xfe, 0x1b, 0xe3, 0xdf, 0x1a, 0x2c,
	0xa8, 0xb0, 0xdf, 0xb1, 0x75, 0x72, 0x09, 0x2b, 0xbd, 0x5e, 0xc2, 0x76, 0x01, 0xfc, 0xc8, 0xcd,
	0xe7, 0xac, 0x7a, 0x36, 0x43, 0x6b, 0x7e, 0x44, 0x1f, 0xc8, 0x4e, 0xf9, 0x4d, 0xb2, 0x33, 0x11,
	0xaa, 0x0e, 0x8b, 0xb6, 0x37, 0xea, 0xc6, 0x3c, 0x54, 0x25, 0x36, 0x9e, 0xc2, 0x52, 0xca, 0x79,
	0xd7, 0x8b, 0xf3, 0x17, 0x0d, 0x96, 0xcd, 0xfb, 0x98, 0xb7, 0xbf, 0x42, 0xcc, 0xa4, 0x89, 0x9a,
	0x30, 0xd7, 0x17, 0x0c, 0x61, 0x09, 0xc3, 0x53, 0xb4, 0x90, 0x78, 0x41, 0x9f, 0xdd, 0x8a, 0x6c,
	0x49, 0x89, 0xa0, 0xc9, 0xf7, 0x60, 0x41, 0xea, 0xb8, 0xe1, 0x90, 0x45, 0x2c, 0x4e, 0x33, 0xd3,
	0x90, 0xec, 0x4b, 0xc1, 0x25, 0xbb, 0x50, 0x8f, 0xfd, 0x3b, 0xc6, 0xef, 0xe5, 0x1d, 0x29, 0x8b,
	0x16, 0x00, 0xc5, 0xea, 0xb2, 0xfe, 0xf1, 0x1a, 0xac, 0x28, 0x3b, 0x3c, 0xc4, 0x84, 0xa8, 0x34,
	0xfc, 0x1a, 0x48, 0xde, 0x4f, 0x15, 0xf7, 0x53, 0x20, 0x4a, 0x79, 0x32, 0xfc, 0xed, 0x7c, 0xf8,
	0xf2, 0x5c, 0x2e, 0x09, 0x7a, 0x7f, 0x8c, 0x63, 0x5c, 0xc1, 0x02, 0xc5, 0x57, 0x33, 0xcd, 0xc2,
	0x3a, 0x54, 0xbc, 0xe0, 0xe6, 0x56, 0xda, 0xab, 0x9c, 0xcd, 0x50, 0x49, 0x92, 0x6d, 0xa8, 0x0e,
	0xf9, 0xed, 0xed, 0x97, 0x5e, 0xff, 0xb7, 0x69, 0x16, 0x52, 0x0e, 0xd6, 0x6f, 0x28, 0xcc, 0x28,
	0xc7, 0x3b, 0xb0, 0x98, 0x98, 0x7d, 0xd7, 0x62, 0x6d, 0xc2, 0x86, 0x13, 0xd8, 0xde, 0xc8, 0x1a,
	0xb1, 0x20, 0x6e, 0x7f, 0xe5, 0x05, 0x69, 0xc5, 0x8c, 0x13, 0xa8, 0xe1, 0x4b, 0x2a, 0x24, 0x6f,
	0x0f, 0xf0, 0x12, 0xaa, 0x89, 0xf9, 0xb7, 0xbf, 0x50, 0x9f, 0x00, 0x8e, 0x25, 0xf7, 0x35, 0x2e,
	0x15, 0xc5, 0x51, 0x26, 0x3f, 0x8d, 0x5f, 0xc2, 0x52, 0x56, 0x5f, 0xe9, 0xc1, 0x77, 0x59, 0xdc,
	0x27, 0x50, 0x97, 0x55, 0x78, 0xc7, 0x0c, 0x7d, 0x53, 0x82, 0xe6, 0x64, 0x0d, 0x54, 0x61, 0x3f,
	0x07, 0x1c, 0x07, 0x2e, 0x43, 0x51, 0x7e, 0x7a, 0x34, 0xc7, 0xa2, 0x17, 0x67, 0xc5, 0xf8, 0x68,
	0x04, 0x39, 0x8a, 0xfc, 0x10, 0xe0, 0x8e, 0x8f, 0x98, 0x34, 0x30, 0x2d, 0x73, 0x69, 0x89, 0xf1,
	0xc1, 0xb9, 0x4b, 0xeb, 0xfd, 0xb1, 0xd8, 0x09, 0xd4, 0x31, 0xf9, 0x88, 0xaf, 0x4e, 0x83, 0xc4,
	0x3e, 0x4d, 0x00, 0xf1, 0x95, 0x52, 0x7d, 0x2a, 0xcf, 0x4d, 0x79, 0xa5, 0x72, 0x19, 0xc3, 0x57,
	0x6a, 0x98, 0x4b, 0x60, 0x07, 0x96, 0xbd, 0xfb, 0x98, 0xbb, 0xaa, 0x40, 0xd2, 0x84, 0x1c, 0x03,
	0x5b, 0x79, 0x13, 0x63, 0x35, 0x3d, 0x9b, 0xa1, 0x4b, 0x5e, 0x91, 0x85, 0x17, 0xa6, 0x2f, 0xf2,
	0xa8, 0x2e, 0xcc, 0x1f, 0x35, 0xa8, 0x50, 0x7e, 0x1f, 0x33, 0xb2, 0x08, 0x25, 0x7f, 0xa0, 0xa6,
	0x78, 0xc9, 0x1f, 0x4c, 0x1b, 0xe1, 0x38, 0x36, 0xfc, 0xc8, 0xf5, 0xfa, 0xb1, 0x3f, 0x62, 0xf2,
	0xc9, 0xa1, 0x55, 0x3f, 0x32, 0x05, 0x4d, 0x7e, 0x8c, 0x31, 0xde, 0xc7, 0xcc, 0x0d, 0xb9, 0x1f,
	0xc4, 0x51, 0xb3, 0xbc, 0x37, 0x3b, 0x3e, 0xe0, 0x04, 0xd2, 0x25, 0x8a, 0x31, 0xc0, 0xe4, 0x3b,
	0x32, 0x7e, 0x04, 0x90, 0x89, 0x52, 0x64, 0x2d, 0x87, 0x8c, 0x1b, 0x92, 0xc8, 0x48, 0xba, 0x21,
	0x09, 0xca, 0xf8, 0x0c, 0x96, 0x6c, 0xf6, 0x42, 0x1c, 0x4e, 0x5e, 0x92, 0x0f, 0xa1, 0x22, 0x6c,
	0xab, 0x99, 0xbc, 0x3c, 0xe1, 0x00, 0x95, 0x72, 0xe3, 0x27, 0xa0, 0x67, 0x67, 0x55, 0x57, 0xbd,
	0xf6, 0xe1, 0x15, 0x58, 0x3e, 0xf7, 0xa3, 0x58, 0xf0, 0xa2, 0xe4, 0x61, 0xf8, 0x39, 0x90, 0x3c,
	0x53, 0xd9, 0xfc, 0x3e, 0xfa, 0x8e, 0x9c, 0xa6, 0x26, 0x52, 0x32, 0xc5, 0xa8, 0x52, 0x30, 0xde,
	0x83, 0xa5, 0x53, 0x16, 0x17, 0xc2, 0x19, 0xab, 0x0b, 0x7a, 0x9d, 0xa9, 0xbc, 0xa9, 0xd7, 0x3f,
	0x03, 0x72, 0x15, 0x0e, 0xf0, 0x7d, 0x7c, 0xab, 0x8c, 0x7d, 0x0e, 0x2b, 0x85, 0xe3, 0x6f, 0x0a,
	0x7f, 0x04, 0x2b, 0x27, 0xec, 0x96, 0xa9, 0xf3, 0x49, 0xda, 0xb0, 0xad, 0x64, 0xfc, 0xae, 0x88,
	0x14, 0xf7, 0xb3, 0xaa, 0x64, 0x74, 0x06, 0xc6, 0x3a, 0xac, 0x16, 0xcf, 0x48, 0xd0, 0x83, 0xff,
	0x68, 0x00, 0xd9, 0xbb, 0x41, 0xea, 0x30, 0x7f, 0x65, 0x7f, 0x61, 0x3b, 0xcf, 0x6c, 0x7d, 0x06,
	0x89, 0x6e, 0xcf, 0xb9, 0xbc, 0xb4, 0x4e, 0x74, 0x8d, 0x00, 0xcc, 0x5d, 0x38, 0xd7, 0x1d, 0xfb,
	0x54, 0x2f, 0x91, 0x05, 0xa8, 0x5d, 0x52, 0xeb, 0xd2, 0xa4, 0x48, 0xce, 0xa2, 0xa8, 0x6d, 0xda,
	0x6d, 0xeb, 0x5c, 0x2f, 0x93, 0x06, 0x54, 0xa9, 0x75, 0x6e, 0x99, 0x5d, 0xeb, 0x44, 0xaf, 0x10,
	0x1d, 0x1a, 0x16, 0xa5, 0xae, 0x73, 0xdc, 0xed, 0x99, 0xed, 0x73, 0x4b, 0x07, 0xb2, 0x0c, 0x0b,
	0xc8, 0xb1, 0x9d, 0x9e, 0x4b, 0x2d, 0xf3, 0xe4, 0xb9, 0x5e, 0x27, 0x04, 0x16, 0x91, 0x75, 0xe1,
	0xf4, 0x1c, 0xea, 0x3e, 0x31, 0x3b, 0xe7, 0x7a, 0x83, 0xac, 0x82, 0x8e, 0xbc, 0x67, 0xd4, 0xb1,
	0x4f, 0xdd, 0x9e, 0x49, 0x4f, 0xad, 0x9e, 0xbe, 0x40, 0x16, 0x01, 0xa8, 0xf5, 0xd4, 0x55, 0x7e,
	0xac, 0x26, 0xb4, 0x6d, 0x0a, 0x7a, 0x0d, 0xe1, 0x90, 0x6e, 0x9f, 0x99, 0xf4, 0x14, 0x39, 0xeb,
	0x09, 0x87, 0x3a, 0x3d, 0xb3, 0x87, 0x9c, 0x8d, 0x83, 0x3f, 0x6b, 0xb0, 0x50, 0x58, 0xf8, 0x31,
	0x4c, 0xe5, 0xb2, 0x8c, 0xf9, 0x89, 0x43, 0x9f, 0x99, 0x14, 0x63, 0x6e, 0x40, 0xf5, 0xd8, 0x6c,
	0x7f, 0x21, 0xa8, 0x12, 0xa9, 0x42, 0xf9, 0xdc, 0x7a, 0xd2, 0xd3, 0x67, 0x49, 0x0d, 0x2a, 0xb4,
	0x73, 0x7a, 0xd6, 0xd3, 0xcb, 0x08, 0x80, 0x4c, 0x37, 0x39, 0x54, 0xc1, 0x08, 0x85, 0x30, 0x65,
	0xcd, 0x21, 0x4b, 0x28, 0xa5, 0xc6, 0xe6, 0x31, 0x68, 0xa9, 0x95, 0xf2, 0xaa, 0x07, 0xcf, 0xf1,
	0xc1, 0xcf, 0xef, 0xe5, 0x6b, 0xd4, 0x31, 0x2f, 0x3a, 0x98, 0x81, 0xe7, 0x97, 0x96, 0xdb, 0x76,
	0xec, 0x5e, 0xc7, 0xbe, 0x42, 0x2f, 0xd7, 0x81, 0x14, 0x44, 0x0e, 0x3d, 0xb1, 0xa8, 0xae, 0x91,
	0x0d, 0x58, 0x29, 0xf0, 0xa9, 0x69, 0x9f, 0x38, 0x17, 0x7a, 0xe9, 0xe0, 0x7f, 0x1a, 0xe8, 0xe3,
	0x23, 0x07, 0x01, 0x44, 0xaa, 0x2c, 0xb7, 0xdb, 0x33, 0x7b, 0x57, 0x5d, 0x37, 0x2b, 0xfd, 0x16,
	0x6c, 0x14, 0x45, 0x59, 0xbd, 0x35, 0xd2, 0x82, 0xf5, 0xa2, 0x30, 0xad, 0x78, 0x89, 0x6c, 0x43,
	0xb3, 0x28, 0x6b, 0x3b, 0xb6, 0x6d, 0xb5, 0x7b, 0xb2, 0x53, 0x26, 0x4e, 0xa6, 0xa5, 0x2a, 0x93,
	0x5d, 0xd8, 0x2a, 0xca, 0x4e, 0x3a, 0xdd, 0xdc, 0xe1, 0x0a, 0x06, 0xa7, 0x14, 0x14, 0x5b, 0x36,
	0xcb, 0x1c, 0xd9, 0x81, 0x56, 0xf1, 0xa4, 0x6d, 0x5e, 0x67, 0x3d, 0x37, 0x7f, 0x10, 0x88, 0xdf,
	0x1b, 0xd9, 0xcc, 0x5a, 0x07, 0x82, 0x1a, 0xd6, 0xb5, 0x65, 0x63, 0x17, 0x5e, 0x5b, 0x14, 0x7d,
	0x9f, 0xc1, 0x76, 0xba, 0x70, 0xae, 0x2d, 0x29, 0xd0, 0x35, 0x6c, 0xf3, 0x54, 0x4f, 0x2f, 0x91,
	0x35, 0x58, 0x36, 0xaf, 0x7a, 0x8e, 0xab, 0xb0, 0x24, 0x7b, 0x56, 0xb4, 0x18, 0xb6, 0x57, 0xc2,
	0x29, 0x1f, 0xfd, 0xbd, 0x2a, 0x36, 0xfd, 0x36, 0x0f, 0x62, 0x5c, 0xb1, 0xd8, 0x90, 0x3c, 0x83,
	0x32, 0xf6, 0x1c, 0xd9, 0x18, 0x9f, 0x8c, 0xea, 0xee, 0xb6, 0x9a, 0x93, 0x02, 0x79, 0x41, 0x8d,
	0xe6, 0x1f, 0xfe, 0xf9, 0xaf, 0x3f, 0x95, 0x08, 0xd1, 0xc5, 0xaf, 0xe4, 0xd1, 0xd1, 0x61, 0xe0,
	0x8d, 0x0e, 0x71, 0x8e, 0xee, 0x6b, 0x1f, 0x69, 0xe4, 0x17, 0x50, 0x11, 0xbf, 0x29, 0xc8, 0xf8,
	0xbc, 0x4e, 0x7f, 0x5d, 0xb5, 0x36, 0xa7, 0x48, 0x94, 0xed, 0x47, 0xc2, 0xf6, 0x86, 0x41, 0xf2,
	0xb6, 0xc5, 0x22, 0xc4, 0x3f, 0xd3, 0x0e, 0x48, 0x1f, 0xe6, 0xd5, 0xd2, 0x4e, 0x5a, 0x63, 0x46,
	0x72, 0xbb, 0x7d, 0x6b, 0x6b, 0xaa, 0x4c, 0x41, 0xec, 0x0a, 0x88, 0x4d, 0x63, 0x75, 0x1c, 0x22,
	0x8a, 0x79, 0x88, 0x20, 0x1c, 0x20, 0x1b, 0xb8, 0xe4, 0xd1, 0xf4, 0x41, 0x9c, 0x40, 0xed, 0x3c,
	0x24, 0x56, 0x68, 0x86, 0x40, 0xdb, 0x36, 0x36, 0xf2, 0x68, 0xb9, 0xa1, 0x8f, 0x80, 0xbf, 0x82,
	0x39, 0xb9, 0x24, 0x90, 0xcd, 0xc9, 0xc5, 0x21, 0x01, 0x6a, 0x4d, 0x13, 0x7d, 0x5b, 0xd6, 0xe4,
	0x20, 0x45, 0xfb, 0x5f, 0x6b, 0xa0, 0x8f, 0xaf, 0x5b, 0xe4, 0xfd, 0xbc, 0xbd, 0x07, 0x16, 0xe2,
	0xd6, 0x07, 0xdf, 0xae, 0xa4, 0xe0, 0x3f, 0x14, 0xf0, 0xef, 0x91, 0xdd, 0x3c, 0x3c, 0x0f, 0xdc,
	0x6c, 0x8d, 0x93, 0xab, 0xc9, 0x47, 0x1a, 0xb9, 0x81, 0x6a, 0x32, 0x9a, 0x49, 0xb1, 0x4a, 0xc5,
	0x61, 0xdf, 0xda, 0x9e, 0x2e, 0x54, 0x88, 0x7b, 0x02, 0xb1, 0x65, 0xac, 0x15, 0x6a, 0xc8, 0x5e,
	0xb8, 0x62, 0xba, 0xa8, 0x22, 0x66, 0x13, 0xbb, 0x58, 0xc4, 0x89, 0xf1, 0x5e, 0x2c, 0xe2, 0xe4,
	0xa0, 0x9f, 0x5e, 0xc4, 0x5b, 0x3f, 0x8a, 0x25, 0x5e, 0x84, 0x80, 0x11, 0xd4, 0x73, 0x23, 0x94,
	0x14, 0x4c, 0x4e, 0x8e, 0xe6, 0xd6, 0xee, 0x83, 0x72, 0x85, 0xf9, 0xbe, 0xc0, 0x7c, 0x64, 0x34,
	0xf3, 0x98, 0xf7, 0x42, 0x31, 0x8b, 0xf2, 0x05, 0x34, 0xf2, 0x33, 0x94, 0x14, 0xac, 0x4e, 0x99,
	0xc8, 0xad, 0xbd, 0x87, 0x15, 0x14, 0xee, 0x07, 0x02, 0x77, 0xc7, 0xd8, 0xcc, 0xe3, 0x0e, 0x84,
	0x66, 0x16, 0xed, 0x71, 0xe3, 0x6f, 0xaf, 0x76, 0xb4, 0x7f, 0xbc, 0xda, 0xd1, 0xbe, 0x79, 0xb5,
	0xa3, 0x7d, 0x39, 0x27, 0xfe, 0x13, 0xfb, 0xf8, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x60, 0x70,
	0x8d, 0xf5, 0x55, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// NavControllerClient is the client API for NavController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NavControllerClient interface {
	// 遥控移动
	// 当机器人处于非空闲及遥控移动状态时， 当前链接将被强制关闭, 错误描述为: "[naving|charging|rotating] reject"
	// 当机器人处于 *其它用户* 的遥控移动状态时， *你* 将收到MoveStatusResponse状态码REJ_MOVING
	// 当机器人处于 *你* 的遥控移动状态时, 请在500ms内持续发送遥控指令， 超时将自动停止移动
	// 当机器人处于 *你* 的遥控移动状态时, 若5秒后无遥控指令的更新, *你* 将接收到MoveStatusResponse状态码RELEASED，
	// 此时遥控移动控制权交由抢占的 *其它用户* 或其它类型目标的操作
	Move(ctx context.Context, opts ...grpc.CallOption) (NavController_MoveClient, error)
	// 导航
	// 当机器人处理遥控移动中|充电中|旋转中时, 错误描述为: "[moving|charging|rotating] reject"
	// 当机器人处理空闲或导航状态时, 将收到导航的目标NavTarget与导航或失败状态
	// 使用目标导航时支持同步异步模式, 参考NavToRequest.sync_mode的参数描述
	NavTo(ctx context.Context, in *NavToRequest, opts ...grpc.CallOption) (*NavToResponse, error)
	// 停止
	// 静止: 立即返回STOPPED
	// 旋转中: 返回旋转状态, STOPPED或CANCEL, 超时3秒
	// 其它: 错误描述为: "[moving|charging] reject"
	NavStop(ctx context.Context, in *NavStopRequest, opts ...grpc.CallOption) (*NavStopResponse, error)
	// 自动充电
	// 当前为充电中|充电连接中: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING|CHARGE_STATUS_CONNECTING|CHARGE_STATUS_RELEASED后返回
	// 当前为充电中|充电连接中: 请求类型为cancel等待状态为CHARGE_STATUS_RELEASED后返回
	// 当前为已释放: 请求类型为cancel将直接返回CHARGE_STATUS_RELEASED
	// 当前为已释放: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING后返回
	// 超时错误: 发送请求后默认60秒后未收到状态更新返回错误描述, 超时时间可在AutoChargeRequest中自定义配置
	AutoCharge(ctx context.Context, in *AutoChargeRequest, opts ...grpc.CallOption) (*AutoChargeResponse, error)
	// 原地旋转
	// 当旋转完成后返回STOPPED
	// 当用户使用NavStop中止时将返回CANCEL
	// 若超时30秒未执行完毕将返回超时错误
	Rotate(ctx context.Context, in *RotateRequest, opts ...grpc.CallOption) (*RotateResponse, error)
	// 导航事件监听
	// 监听导航模块中各类事件的变动更新
	OnNavEventChange(ctx context.Context, in *OnNavEventChangeRequest, opts ...grpc.CallOption) (NavController_OnNavEventChangeClient, error)
	// 新建线路
	NewRoute(ctx context.Context, in *NewRouteRequest, opts ...grpc.CallOption) (*NewRouteResponse, error)
	// 获取线路
	ListRoutes(ctx context.Context, in *ListRoutesRequest, opts ...grpc.CallOption) (*ListRoutesResponse, error)
	// 更新线路信息
	UpdateRoute(ctx context.Context, in *UpdateRouteRequest, opts ...grpc.CallOption) (*UpdateRouteResponse, error)
	// 删除线路
	DeleteRoutes(ctx context.Context, in *DeleteRoutesRequest, opts ...grpc.CallOption) (*DeleteRoutesResponse, error)
}

type navControllerClient struct {
	cc *grpc.ClientConn
}

func NewNavControllerClient(cc *grpc.ClientConn) NavControllerClient {
	return &navControllerClient{cc}
}

func (c *navControllerClient) Move(ctx context.Context, opts ...grpc.CallOption) (NavController_MoveClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NavController_serviceDesc.Streams[0], "/navService.NavController/Move", opts...)
	if err != nil {
		return nil, err
	}
	x := &navControllerMoveClient{stream}
	return x, nil
}

type NavController_MoveClient interface {
	Send(*MoveRequest) error
	Recv() (*MoveResponse, error)
	grpc.ClientStream
}

type navControllerMoveClient struct {
	grpc.ClientStream
}

func (x *navControllerMoveClient) Send(m *MoveRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *navControllerMoveClient) Recv() (*MoveResponse, error) {
	m := new(MoveResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *navControllerClient) NavTo(ctx context.Context, in *NavToRequest, opts ...grpc.CallOption) (*NavToResponse, error) {
	out := new(NavToResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/NavTo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *navControllerClient) NavStop(ctx context.Context, in *NavStopRequest, opts ...grpc.CallOption) (*NavStopResponse, error) {
	out := new(NavStopResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/NavStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *navControllerClient) AutoCharge(ctx context.Context, in *AutoChargeRequest, opts ...grpc.CallOption) (*AutoChargeResponse, error) {
	out := new(AutoChargeResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/AutoCharge", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *navControllerClient) Rotate(ctx context.Context, in *RotateRequest, opts ...grpc.CallOption) (*RotateResponse, error) {
	out := new(RotateResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/Rotate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *navControllerClient) OnNavEventChange(ctx context.Context, in *OnNavEventChangeRequest, opts ...grpc.CallOption) (NavController_OnNavEventChangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_NavController_serviceDesc.Streams[1], "/navService.NavController/OnNavEventChange", opts...)
	if err != nil {
		return nil, err
	}
	x := &navControllerOnNavEventChangeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NavController_OnNavEventChangeClient interface {
	Recv() (*OnNavEventChangeResponse, error)
	grpc.ClientStream
}

type navControllerOnNavEventChangeClient struct {
	grpc.ClientStream
}

func (x *navControllerOnNavEventChangeClient) Recv() (*OnNavEventChangeResponse, error) {
	m := new(OnNavEventChangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *navControllerClient) NewRoute(ctx context.Context, in *NewRouteRequest, opts ...grpc.CallOption) (*NewRouteResponse, error) {
	out := new(NewRouteResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/NewRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *navControllerClient) ListRoutes(ctx context.Context, in *ListRoutesRequest, opts ...grpc.CallOption) (*ListRoutesResponse, error) {
	out := new(ListRoutesResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/ListRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *navControllerClient) UpdateRoute(ctx context.Context, in *UpdateRouteRequest, opts ...grpc.CallOption) (*UpdateRouteResponse, error) {
	out := new(UpdateRouteResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/UpdateRoute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *navControllerClient) DeleteRoutes(ctx context.Context, in *DeleteRoutesRequest, opts ...grpc.CallOption) (*DeleteRoutesResponse, error) {
	out := new(DeleteRoutesResponse)
	err := c.cc.Invoke(ctx, "/navService.NavController/DeleteRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NavControllerServer is the server API for NavController service.
type NavControllerServer interface {
	// 遥控移动
	// 当机器人处于非空闲及遥控移动状态时， 当前链接将被强制关闭, 错误描述为: "[naving|charging|rotating] reject"
	// 当机器人处于 *其它用户* 的遥控移动状态时， *你* 将收到MoveStatusResponse状态码REJ_MOVING
	// 当机器人处于 *你* 的遥控移动状态时, 请在500ms内持续发送遥控指令， 超时将自动停止移动
	// 当机器人处于 *你* 的遥控移动状态时, 若5秒后无遥控指令的更新, *你* 将接收到MoveStatusResponse状态码RELEASED，
	// 此时遥控移动控制权交由抢占的 *其它用户* 或其它类型目标的操作
	Move(NavController_MoveServer) error
	// 导航
	// 当机器人处理遥控移动中|充电中|旋转中时, 错误描述为: "[moving|charging|rotating] reject"
	// 当机器人处理空闲或导航状态时, 将收到导航的目标NavTarget与导航或失败状态
	// 使用目标导航时支持同步异步模式, 参考NavToRequest.sync_mode的参数描述
	NavTo(context.Context, *NavToRequest) (*NavToResponse, error)
	// 停止
	// 静止: 立即返回STOPPED
	// 旋转中: 返回旋转状态, STOPPED或CANCEL, 超时3秒
	// 其它: 错误描述为: "[moving|charging] reject"
	NavStop(context.Context, *NavStopRequest) (*NavStopResponse, error)
	// 自动充电
	// 当前为充电中|充电连接中: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING|CHARGE_STATUS_CONNECTING|CHARGE_STATUS_RELEASED后返回
	// 当前为充电中|充电连接中: 请求类型为cancel等待状态为CHARGE_STATUS_RELEASED后返回
	// 当前为已释放: 请求类型为cancel将直接返回CHARGE_STATUS_RELEASED
	// 当前为已释放: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING后返回
	// 超时错误: 发送请求后默认60秒后未收到状态更新返回错误描述, 超时时间可在AutoChargeRequest中自定义配置
	AutoCharge(context.Context, *AutoChargeRequest) (*AutoChargeResponse, error)
	// 原地旋转
	// 当旋转完成后返回STOPPED
	// 当用户使用NavStop中止时将返回CANCEL
	// 若超时30秒未执行完毕将返回超时错误
	Rotate(context.Context, *RotateRequest) (*RotateResponse, error)
	// 导航事件监听
	// 监听导航模块中各类事件的变动更新
	OnNavEventChange(*OnNavEventChangeRequest, NavController_OnNavEventChangeServer) error
	// 新建线路
	NewRoute(context.Context, *NewRouteRequest) (*NewRouteResponse, error)
	// 获取线路
	ListRoutes(context.Context, *ListRoutesRequest) (*ListRoutesResponse, error)
	// 更新线路信息
	UpdateRoute(context.Context, *UpdateRouteRequest) (*UpdateRouteResponse, error)
	// 删除线路
	DeleteRoutes(context.Context, *DeleteRoutesRequest) (*DeleteRoutesResponse, error)
}

// UnimplementedNavControllerServer can be embedded to have forward compatible implementations.
type UnimplementedNavControllerServer struct {
}

func (*UnimplementedNavControllerServer) Move(srv NavController_MoveServer) error {
	return status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (*UnimplementedNavControllerServer) NavTo(ctx context.Context, req *NavToRequest) (*NavToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavTo not implemented")
}
func (*UnimplementedNavControllerServer) NavStop(ctx context.Context, req *NavStopRequest) (*NavStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavStop not implemented")
}
func (*UnimplementedNavControllerServer) AutoCharge(ctx context.Context, req *AutoChargeRequest) (*AutoChargeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutoCharge not implemented")
}
func (*UnimplementedNavControllerServer) Rotate(ctx context.Context, req *RotateRequest) (*RotateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rotate not implemented")
}
func (*UnimplementedNavControllerServer) OnNavEventChange(req *OnNavEventChangeRequest, srv NavController_OnNavEventChangeServer) error {
	return status.Errorf(codes.Unimplemented, "method OnNavEventChange not implemented")
}
func (*UnimplementedNavControllerServer) NewRoute(ctx context.Context, req *NewRouteRequest) (*NewRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewRoute not implemented")
}
func (*UnimplementedNavControllerServer) ListRoutes(ctx context.Context, req *ListRoutesRequest) (*ListRoutesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRoutes not implemented")
}
func (*UnimplementedNavControllerServer) UpdateRoute(ctx context.Context, req *UpdateRouteRequest) (*UpdateRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoute not implemented")
}
func (*UnimplementedNavControllerServer) DeleteRoutes(ctx context.Context, req *DeleteRoutesRequest) (*DeleteRoutesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoutes not implemented")
}

func RegisterNavControllerServer(s *grpc.Server, srv NavControllerServer) {
	s.RegisterService(&_NavController_serviceDesc, srv)
}

func _NavController_Move_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NavControllerServer).Move(&navControllerMoveServer{stream})
}

type NavController_MoveServer interface {
	Send(*MoveResponse) error
	Recv() (*MoveRequest, error)
	grpc.ServerStream
}

type navControllerMoveServer struct {
	grpc.ServerStream
}

func (x *navControllerMoveServer) Send(m *MoveResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *navControllerMoveServer) Recv() (*MoveRequest, error) {
	m := new(MoveRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NavController_NavTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).NavTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/NavTo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).NavTo(ctx, req.(*NavToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NavController_NavStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).NavStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/NavStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).NavStop(ctx, req.(*NavStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NavController_AutoCharge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutoChargeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).AutoCharge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/AutoCharge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).AutoCharge(ctx, req.(*AutoChargeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NavController_Rotate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).Rotate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/Rotate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).Rotate(ctx, req.(*RotateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NavController_OnNavEventChange_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OnNavEventChangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NavControllerServer).OnNavEventChange(m, &navControllerOnNavEventChangeServer{stream})
}

type NavController_OnNavEventChangeServer interface {
	Send(*OnNavEventChangeResponse) error
	grpc.ServerStream
}

type navControllerOnNavEventChangeServer struct {
	grpc.ServerStream
}

func (x *navControllerOnNavEventChangeServer) Send(m *OnNavEventChangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NavController_NewRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).NewRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/NewRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).NewRoute(ctx, req.(*NewRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NavController_ListRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).ListRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/ListRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).ListRoutes(ctx, req.(*ListRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NavController_UpdateRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).UpdateRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/UpdateRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).UpdateRoute(ctx, req.(*UpdateRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NavController_DeleteRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NavControllerServer).DeleteRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/navService.NavController/DeleteRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NavControllerServer).DeleteRoutes(ctx, req.(*DeleteRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NavController_serviceDesc = grpc.ServiceDesc{
	ServiceName: "navService.NavController",
	HandlerType: (*NavControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NavTo",
			Handler:    _NavController_NavTo_Handler,
		},
		{
			MethodName: "NavStop",
			Handler:    _NavController_NavStop_Handler,
		},
		{
			MethodName: "AutoCharge",
			Handler:    _NavController_AutoCharge_Handler,
		},
		{
			MethodName: "Rotate",
			Handler:    _NavController_Rotate_Handler,
		},
		{
			MethodName: "NewRoute",
			Handler:    _NavController_NewRoute_Handler,
		},
		{
			MethodName: "ListRoutes",
			Handler:    _NavController_ListRoutes_Handler,
		},
		{
			MethodName: "UpdateRoute",
			Handler:    _NavController_UpdateRoute_Handler,
		},
		{
			MethodName: "DeleteRoutes",
			Handler:    _NavController_DeleteRoutes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Move",
			Handler:       _NavController_Move_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "OnNavEventChange",
			Handler:       _NavController_OnNavEventChange_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nav.proto",
}

func (m *MoveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintNav(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x22
	}
	if m.Direction != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x18
	}
	if m.Rspeed != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.Rspeed))
		i--
		dAtA[i] = 0x10
	}
	if m.Speed != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MoveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NavTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NavTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NavTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNav(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Index) > 0 {
		i -= len(m.Index)
		copy(dAtA[i:], m.Index)
		i = encodeVarintNav(dAtA, i, uint64(len(m.Index)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NavRoaming) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NavRoaming) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NavRoaming) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OrderLoop {
		i--
		if m.OrderLoop {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.RoamingTargetIndexes) > 0 {
		for iNdEx := len(m.RoamingTargetIndexes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RoamingTargetIndexes[iNdEx])
			copy(dAtA[i:], m.RoamingTargetIndexes[iNdEx])
			i = encodeVarintNav(dAtA, i, uint64(len(m.RoamingTargetIndexes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.WaitSec != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.WaitSec))
		i--
		dAtA[i] = 0x10
	}
	if m.NavRoamingType != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.NavRoamingType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NavToRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NavToRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NavToRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetOneof != nil {
		{
			size := m.TargetOneof.Size()
			i -= size
			if _, err := m.TargetOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SyncMode {
		i--
		if m.SyncMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Speed != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *NavToRequest_Target) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NavToRequest_Target) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *NavToRequest_Roaming) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NavToRequest_Roaming) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Roaming != nil {
		{
			size, err := m.Roaming.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NavToRequest_MapPosition) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NavToRequest_MapPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MapPosition != nil {
		{
			size, err := m.MapPosition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *NavToResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NavToResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NavToResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetOneof != nil {
		{
			size := m.TargetOneof.Size()
			i -= size
			if _, err := m.TargetOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NavToResponse_Target) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NavToResponse_Target) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Target != nil {
		{
			size, err := m.Target.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NavToResponse_IsRoaming) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NavToResponse_IsRoaming) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.IsRoaming {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *NavToResponse_MapPosition) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *NavToResponse_MapPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MapPosition != nil {
		{
			size, err := m.MapPosition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *NavStopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NavStopRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NavStopRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *NavStopResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NavStopResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NavStopResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutoChargeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoChargeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoChargeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TimeoutSec != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.TimeoutSec))
		i--
		dAtA[i] = 0x20
	}
	if m.ChargeOptionOneof != nil {
		{
			size := m.ChargeOptionOneof.Size()
			i -= size
			if _, err := m.ChargeOptionOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AutoChargeRequest_Charge) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *AutoChargeRequest_Charge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Charge {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *AutoChargeRequest_Cancel) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *AutoChargeRequest_Cancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Cancel {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *AutoChargeRequest_ChargePreset) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *AutoChargeRequest_ChargePreset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.ChargePreset {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *AutoChargeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoChargeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoChargeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChargeStatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.ChargeStatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RotateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RotateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RotateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RotateOneof != nil {
		{
			size := m.RotateOneof.Size()
			i -= size
			if _, err := m.RotateOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RotateRequest_Angle) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RotateRequest_Angle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintNav(dAtA, i, uint64(m.Angle))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *RotateRequest_Rollback) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *RotateRequest_Rollback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Rollback {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *RotateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RotateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RotateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnNavEventChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnNavEventChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnNavEventChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MoveEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MoveEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NavEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NavEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NavEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NavTarget != nil {
		{
			size, err := m.NavTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AutoChargeEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoChargeEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AutoChargeEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChargeStatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.ChargeStatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RotateEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RotateEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RotateEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StatusCode != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnNavEventChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnNavEventChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnNavEventChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangeOneof != nil {
		{
			size := m.ChangeOneof.Size()
			i -= size
			if _, err := m.ChangeOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NavEventType != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.NavEventType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OnNavEventChangeResponse_MoveEvent) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *OnNavEventChangeResponse_MoveEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MoveEvent != nil {
		{
			size, err := m.MoveEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OnNavEventChangeResponse_NavEvent) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *OnNavEventChangeResponse_NavEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NavEvent != nil {
		{
			size, err := m.NavEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *OnNavEventChangeResponse_RotateEvent) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *OnNavEventChangeResponse_RotateEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RotateEvent != nil {
		{
			size, err := m.RotateEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *OnNavEventChangeResponse_AutoChargeEvent) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *OnNavEventChangeResponse_AutoChargeEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutoChargeEvent != nil {
		{
			size, err := m.AutoChargeEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoutePoints) > 0 {
		for iNdEx := len(m.RoutePoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoutePoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNav(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNav(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNav(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoutePoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoutePoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoutePoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rotate != 0 {
		i = encodeVarintNav(dAtA, i, uint64(m.Rotate))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNav(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewRouteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRoutesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRoutesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRoutesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ListRoutesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRoutesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRoutesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Routes) > 0 {
		for iNdEx := len(m.Routes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Routes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNav(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRouteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintNav(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateRouteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateRouteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNav(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRoutesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRoutesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRoutesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoutesId) > 0 {
		for iNdEx := len(m.RoutesId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RoutesId[iNdEx])
			copy(dAtA[i:], m.RoutesId[iNdEx])
			i = encodeVarintNav(dAtA, i, uint64(len(m.RoutesId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRoutesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRoutesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRoutesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintNav(dAtA []byte, offset int, v uint64) int {
	offset -= sovNav(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MoveRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Speed != 0 {
		n += 1 + sovNav(uint64(m.Speed))
	}
	if m.Rspeed != 0 {
		n += 1 + sovNav(uint64(m.Rspeed))
	}
	if m.Direction != 0 {
		n += 1 + sovNav(uint64(m.Direction))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovNav(uint64(m.StatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NavTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Index)
	if l > 0 {
		n += 1 + l + sovNav(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NavRoaming) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NavRoamingType != 0 {
		n += 1 + sovNav(uint64(m.NavRoamingType))
	}
	if m.WaitSec != 0 {
		n += 1 + sovNav(uint64(m.WaitSec))
	}
	if len(m.RoamingTargetIndexes) > 0 {
		for _, s := range m.RoamingTargetIndexes {
			l = len(s)
			n += 1 + l + sovNav(uint64(l))
		}
	}
	if m.OrderLoop {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NavToRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetOneof != nil {
		n += m.TargetOneof.Size()
	}
	if m.Speed != 0 {
		n += 1 + sovNav(uint64(m.Speed))
	}
	if m.SyncMode {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NavToRequest_Target) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *NavToRequest_Roaming) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Roaming != nil {
		l = m.Roaming.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *NavToRequest_MapPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapPosition != nil {
		l = m.MapPosition.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *NavToResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovNav(uint64(m.StatusCode))
	}
	if m.TargetOneof != nil {
		n += m.TargetOneof.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NavToResponse_Target) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *NavToResponse_IsRoaming) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *NavToResponse_MapPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapPosition != nil {
		l = m.MapPosition.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *NavStopRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NavStopResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovNav(uint64(m.StatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoChargeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChargeOptionOneof != nil {
		n += m.ChargeOptionOneof.Size()
	}
	if m.TimeoutSec != 0 {
		n += 1 + sovNav(uint64(m.TimeoutSec))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoChargeRequest_Charge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *AutoChargeRequest_Cancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *AutoChargeRequest_ChargePreset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *AutoChargeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChargeStatusCode != 0 {
		n += 1 + sovNav(uint64(m.ChargeStatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RotateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RotateOneof != nil {
		n += m.RotateOneof.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RotateRequest_Angle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovNav(uint64(m.Angle))
	return n
}
func (m *RotateRequest_Rollback) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RotateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovNav(uint64(m.StatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnNavEventChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MoveEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovNav(uint64(m.StatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NavEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovNav(uint64(m.StatusCode))
	}
	if m.NavTarget != nil {
		l = m.NavTarget.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AutoChargeEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChargeStatusCode != 0 {
		n += 1 + sovNav(uint64(m.ChargeStatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RotateEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovNav(uint64(m.StatusCode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnNavEventChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NavEventType != 0 {
		n += 1 + sovNav(uint64(m.NavEventType))
	}
	if m.ChangeOneof != nil {
		n += m.ChangeOneof.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OnNavEventChangeResponse_MoveEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MoveEvent != nil {
		l = m.MoveEvent.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *OnNavEventChangeResponse_NavEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NavEvent != nil {
		l = m.NavEvent.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *OnNavEventChangeResponse_RotateEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RotateEvent != nil {
		l = m.RotateEvent.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *OnNavEventChangeResponse_AutoChargeEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoChargeEvent != nil {
		l = m.AutoChargeEvent.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	return n
}
func (m *Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNav(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNav(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	if len(m.RoutePoints) > 0 {
		for _, e := range m.RoutePoints {
			l = e.Size()
			n += 1 + l + sovNav(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoutePoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNav(uint64(l))
	}
	if m.Rotate != 0 {
		n += 1 + sovNav(uint64(m.Rotate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewRouteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRoutesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRoutesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovNav(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRouteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateRouteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateRouteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovNav(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteRoutesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoutesId) > 0 {
		for _, s := range m.RoutesId {
			l = len(s)
			n += 1 + l + sovNav(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteRoutesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNav(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNav(x uint64) (n int) {
	return sovNav(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MoveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rspeed", wireType)
			}
			m.Rspeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rspeed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= MoveDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NavTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NavTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NavTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NavRoaming) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NavRoaming: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NavRoaming: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavRoamingType", wireType)
			}
			m.NavRoamingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NavRoamingType |= RoamingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitSec", wireType)
			}
			m.WaitSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitSec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoamingTargetIndexes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoamingTargetIndexes = append(m.RoamingTargetIndexes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderLoop", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrderLoop = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NavToRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NavToRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NavToRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NavTarget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TargetOneof = &NavToRequest_Target{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roaming", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NavRoaming{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TargetOneof = &NavToRequest_Roaming{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncMode = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MapPosition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TargetOneof = &NavToRequest_MapPosition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NavToResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NavToResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NavToResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NavTarget{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TargetOneof = &NavToResponse_Target{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRoaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.TargetOneof = &NavToResponse_IsRoaming{b}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MapPosition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TargetOneof = &NavToResponse_MapPosition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NavStopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NavStopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NavStopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NavStopResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NavStopResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NavStopResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoChargeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoChargeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoChargeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ChargeOptionOneof = &AutoChargeRequest_Charge{b}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cancel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ChargeOptionOneof = &AutoChargeRequest_Cancel{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargePreset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ChargeOptionOneof = &AutoChargeRequest_ChargePreset{b}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutSec", wireType)
			}
			m.TimeoutSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutSec |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoChargeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoChargeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoChargeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeStatusCode", wireType)
			}
			m.ChargeStatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeStatusCode |= ChargeStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RotateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RotateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RotateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Angle", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RotateOneof = &RotateRequest_Angle{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rollback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.RotateOneof = &RotateRequest_Rollback{b}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RotateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RotateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RotateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnNavEventChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnNavEventChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnNavEventChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NavEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NavEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NavEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NavTarget == nil {
				m.NavTarget = &NavTarget{}
			}
			if err := m.NavTarget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoChargeEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoChargeEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoChargeEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeStatusCode", wireType)
			}
			m.ChargeStatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeStatusCode |= ChargeStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RotateEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RotateEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RotateEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= StatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnNavEventChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnNavEventChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnNavEventChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavEventType", wireType)
			}
			m.NavEventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NavEventType |= NavEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MoveEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChangeOneof = &OnNavEventChangeResponse_MoveEvent{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NavEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NavEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChangeOneof = &OnNavEventChangeResponse_NavEvent{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RotateEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RotateEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChangeOneof = &OnNavEventChangeResponse_RotateEvent{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoChargeEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AutoChargeEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ChangeOneof = &OnNavEventChangeResponse_AutoChargeEvent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutePoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutePoints = append(m.RoutePoints, &RoutePoint{})
			if err := m.RoutePoints[len(m.RoutePoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoutePoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoutePoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoutePoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate", wireType)
			}
			m.Rotate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRoutesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRoutesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRoutesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRoutesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRoutesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRoutesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Route == nil {
				m.Route = &Route{}
			}
			if err := m.Route.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRoutesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRoutesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRoutesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutesId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNav
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNav
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNav
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutesId = append(m.RoutesId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRoutesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNav
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRoutesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRoutesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNav(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNav
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNav(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNav
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNav
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNav
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNav
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthNav
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNav
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNav(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthNav
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNav = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNav   = fmt.Errorf("proto: integer overflow")
)
