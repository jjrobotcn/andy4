// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: nav.proto
#ifndef GRPC_nav_2eproto__INCLUDED
#define GRPC_nav_2eproto__INCLUDED

#include "nav.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class Channel;
class CompletionQueue;
class ServerCompletionQueue;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc_impl

namespace grpc {
class ServerContext;
}  // namespace grpc

namespace navService {

class NavController final {
 public:
  static constexpr char const* service_full_name() {
    return "navService.NavController";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 遥控移动
    // 当机器人处于非空闲及遥控移动状态时， 当前链接将被强制关闭, 错误描述为: "[naving|charging|rotating] reject"
    // 当机器人处于 *其它用户* 的遥控移动状态时， *你* 将收到MoveStatusResponse状态码REJ_MOVING
    // 当机器人处于 *你* 的遥控移动状态时, 请在500ms内持续发送遥控指令， 超时将自动停止移动
    // 当机器人处于 *你* 的遥控移动状态时, 若5秒后无遥控指令的更新, *你* 将接收到MoveStatusResponse状态码RELEASED，
    // 此时遥控移动控制权交由抢占的 *其它用户* 或其它类型目标的操作
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>> Move(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>>(MoveRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>> AsyncMove(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>>(AsyncMoveRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>> PrepareAsyncMove(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>>(PrepareAsyncMoveRaw(context, cq));
    }
    // 导航
    // 当机器人处理遥控移动中|充电中|旋转中时, 错误描述为: "[moving|charging|rotating] reject"
    // 当机器人处理空闲或导航状态时, 将收到导航的目标NavTarget与导航或失败状态
    // 使用目标导航时支持同步异步模式, 参考NavToRequest.sync_mode的参数描述
    virtual ::grpc::Status NavTo(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::navService::NavToResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavToResponse>> AsyncNavTo(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavToResponse>>(AsyncNavToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavToResponse>> PrepareAsyncNavTo(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavToResponse>>(PrepareAsyncNavToRaw(context, request, cq));
    }
    // 停止
    // 静止: 立即返回STOPPED
    // 旋转中: 返回旋转状态, STOPPED或CANCEL, 超时3秒
    // 其它: 错误描述为: "[moving|charging] reject"
    virtual ::grpc::Status NavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::navService::NavStopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavStopResponse>> AsyncNavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavStopResponse>>(AsyncNavStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavStopResponse>> PrepareAsyncNavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavStopResponse>>(PrepareAsyncNavStopRaw(context, request, cq));
    }
    // 自动充电
    // 当前为充电中|充电连接中: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING|CHARGE_STATUS_CONNECTING|CHARGE_STATUS_RELEASED后返回
    // 当前为充电中|充电连接中: 请求类型为cancel等待状态为CHARGE_STATUS_RELEASED后返回
    // 当前为已释放: 请求类型为cancel将直接返回CHARGE_STATUS_RELEASED
    // 当前为已释放: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING后返回
    // 超时错误: 发送请求后默认60秒后未收到状态更新返回错误描述, 超时时间可在AutoChargeRequest中自定义配置
    virtual ::grpc::Status AutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::navService::AutoChargeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::AutoChargeResponse>> AsyncAutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::AutoChargeResponse>>(AsyncAutoChargeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::AutoChargeResponse>> PrepareAsyncAutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::AutoChargeResponse>>(PrepareAsyncAutoChargeRaw(context, request, cq));
    }
    // 原地旋转
    // 当旋转完成后返回STOPPED
    // 当用户使用NavStop中止时将返回CANCEL
    // 若超时30秒未执行完毕将返回超时错误
    virtual ::grpc::Status Rotate(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::navService::RotateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::RotateResponse>> AsyncRotate(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::RotateResponse>>(AsyncRotateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::RotateResponse>> PrepareAsyncRotate(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::RotateResponse>>(PrepareAsyncRotateRaw(context, request, cq));
    }
    // 导航事件监听
    // 监听导航模块中各类事件的变动更新
    std::unique_ptr< ::grpc::ClientReaderInterface< ::navService::OnNavEventChangeResponse>> OnNavEventChange(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::navService::OnNavEventChangeResponse>>(OnNavEventChangeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::navService::OnNavEventChangeResponse>> AsyncOnNavEventChange(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::navService::OnNavEventChangeResponse>>(AsyncOnNavEventChangeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::navService::OnNavEventChangeResponse>> PrepareAsyncOnNavEventChange(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::navService::OnNavEventChangeResponse>>(PrepareAsyncOnNavEventChangeRaw(context, request, cq));
    }
    // >=2.2.0
    // 重置当前定位
    // 用于发生定位异常/错误状态，重新初始化导航定位
    // 重定位错误：定位状态超时|无地图|UWB错误
    // 重定位超时判断: 默认3s，仅在非错误状态下重置
    // *目前仅支持无线导航版本，磁导航版本中将直接返回成功状态
    virtual ::grpc::Status LocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::navService::LocationResetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::LocationResetResponse>> AsyncLocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::LocationResetResponse>>(AsyncLocationResetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::LocationResetResponse>> PrepareAsyncLocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::LocationResetResponse>>(PrepareAsyncLocationResetRaw(context, request, cq));
    }
    // 新建线路
    virtual ::grpc::Status NewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::navService::NewRouteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NewRouteResponse>> AsyncNewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NewRouteResponse>>(AsyncNewRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NewRouteResponse>> PrepareAsyncNewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::NewRouteResponse>>(PrepareAsyncNewRouteRaw(context, request, cq));
    }
    // 获取线路
    virtual ::grpc::Status ListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::navService::ListRoutesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::ListRoutesResponse>> AsyncListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::ListRoutesResponse>>(AsyncListRoutesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::ListRoutesResponse>> PrepareAsyncListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::ListRoutesResponse>>(PrepareAsyncListRoutesRaw(context, request, cq));
    }
    // 更新线路信息
    virtual ::grpc::Status UpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::navService::UpdateRouteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::UpdateRouteResponse>> AsyncUpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::UpdateRouteResponse>>(AsyncUpdateRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::UpdateRouteResponse>> PrepareAsyncUpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::UpdateRouteResponse>>(PrepareAsyncUpdateRouteRaw(context, request, cq));
    }
    // 删除线路
    virtual ::grpc::Status DeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::navService::DeleteRoutesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::DeleteRoutesResponse>> AsyncDeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::DeleteRoutesResponse>>(AsyncDeleteRoutesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::DeleteRoutesResponse>> PrepareAsyncDeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::navService::DeleteRoutesResponse>>(PrepareAsyncDeleteRoutesRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // 遥控移动
      // 当机器人处于非空闲及遥控移动状态时， 当前链接将被强制关闭, 错误描述为: "[naving|charging|rotating] reject"
      // 当机器人处于 *其它用户* 的遥控移动状态时， *你* 将收到MoveStatusResponse状态码REJ_MOVING
      // 当机器人处于 *你* 的遥控移动状态时, 请在500ms内持续发送遥控指令， 超时将自动停止移动
      // 当机器人处于 *你* 的遥控移动状态时, 若5秒后无遥控指令的更新, *你* 将接收到MoveStatusResponse状态码RELEASED，
      // 此时遥控移动控制权交由抢占的 *其它用户* 或其它类型目标的操作
      virtual void Move(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::navService::MoveRequest,::navService::MoveResponse>* reactor) = 0;
      // 导航
      // 当机器人处理遥控移动中|充电中|旋转中时, 错误描述为: "[moving|charging|rotating] reject"
      // 当机器人处理空闲或导航状态时, 将收到导航的目标NavTarget与导航或失败状态
      // 使用目标导航时支持同步异步模式, 参考NavToRequest.sync_mode的参数描述
      virtual void NavTo(::grpc::ClientContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NavTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavToResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NavTo(::grpc::ClientContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NavTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 停止
      // 静止: 立即返回STOPPED
      // 旋转中: 返回旋转状态, STOPPED或CANCEL, 超时3秒
      // 其它: 错误描述为: "[moving|charging] reject"
      virtual void NavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NavStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavStopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NavStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 自动充电
      // 当前为充电中|充电连接中: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING|CHARGE_STATUS_CONNECTING|CHARGE_STATUS_RELEASED后返回
      // 当前为充电中|充电连接中: 请求类型为cancel等待状态为CHARGE_STATUS_RELEASED后返回
      // 当前为已释放: 请求类型为cancel将直接返回CHARGE_STATUS_RELEASED
      // 当前为已释放: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING后返回
      // 超时错误: 发送请求后默认60秒后未收到状态更新返回错误描述, 超时时间可在AutoChargeRequest中自定义配置
      virtual void AutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AutoCharge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::AutoChargeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AutoCharge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::AutoChargeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 原地旋转
      // 当旋转完成后返回STOPPED
      // 当用户使用NavStop中止时将返回CANCEL
      // 若超时30秒未执行完毕将返回超时错误
      virtual void Rotate(::grpc::ClientContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rotate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::RotateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rotate(::grpc::ClientContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Rotate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::RotateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 导航事件监听
      // 监听导航模块中各类事件的变动更新
      virtual void OnNavEventChange(::grpc::ClientContext* context, ::navService::OnNavEventChangeRequest* request, ::grpc::experimental::ClientReadReactor< ::navService::OnNavEventChangeResponse>* reactor) = 0;
      // >=2.2.0
      // 重置当前定位
      // 用于发生定位异常/错误状态，重新初始化导航定位
      // 重定位错误：定位状态超时|无地图|UWB错误
      // 重定位超时判断: 默认3s，仅在非错误状态下重置
      // *目前仅支持无线导航版本，磁导航版本中将直接返回成功状态
      virtual void LocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LocationReset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::LocationResetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void LocationReset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::LocationResetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 新建线路
      virtual void NewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NewRouteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NewRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NewRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 获取线路
      virtual void ListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::ListRoutesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::ListRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 更新线路信息
      virtual void UpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::UpdateRouteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::UpdateRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 删除线路
      virtual void DeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::DeleteRoutesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::DeleteRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>* MoveRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>* AsyncMoveRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::navService::MoveRequest, ::navService::MoveResponse>* PrepareAsyncMoveRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavToResponse>* AsyncNavToRaw(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavToResponse>* PrepareAsyncNavToRaw(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavStopResponse>* AsyncNavStopRaw(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::NavStopResponse>* PrepareAsyncNavStopRaw(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::AutoChargeResponse>* AsyncAutoChargeRaw(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::AutoChargeResponse>* PrepareAsyncAutoChargeRaw(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::RotateResponse>* AsyncRotateRaw(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::RotateResponse>* PrepareAsyncRotateRaw(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::navService::OnNavEventChangeResponse>* OnNavEventChangeRaw(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::navService::OnNavEventChangeResponse>* AsyncOnNavEventChangeRaw(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::navService::OnNavEventChangeResponse>* PrepareAsyncOnNavEventChangeRaw(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::LocationResetResponse>* AsyncLocationResetRaw(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::LocationResetResponse>* PrepareAsyncLocationResetRaw(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::NewRouteResponse>* AsyncNewRouteRaw(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::NewRouteResponse>* PrepareAsyncNewRouteRaw(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::ListRoutesResponse>* AsyncListRoutesRaw(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::ListRoutesResponse>* PrepareAsyncListRoutesRaw(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::UpdateRouteResponse>* AsyncUpdateRouteRaw(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::UpdateRouteResponse>* PrepareAsyncUpdateRouteRaw(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::DeleteRoutesResponse>* AsyncDeleteRoutesRaw(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::navService::DeleteRoutesResponse>* PrepareAsyncDeleteRoutesRaw(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>> Move(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>>(MoveRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>> AsyncMove(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>>(AsyncMoveRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>> PrepareAsyncMove(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>>(PrepareAsyncMoveRaw(context, cq));
    }
    ::grpc::Status NavTo(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::navService::NavToResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavToResponse>> AsyncNavTo(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavToResponse>>(AsyncNavToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavToResponse>> PrepareAsyncNavTo(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavToResponse>>(PrepareAsyncNavToRaw(context, request, cq));
    }
    ::grpc::Status NavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::navService::NavStopResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavStopResponse>> AsyncNavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavStopResponse>>(AsyncNavStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavStopResponse>> PrepareAsyncNavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NavStopResponse>>(PrepareAsyncNavStopRaw(context, request, cq));
    }
    ::grpc::Status AutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::navService::AutoChargeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::AutoChargeResponse>> AsyncAutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::AutoChargeResponse>>(AsyncAutoChargeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::AutoChargeResponse>> PrepareAsyncAutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::AutoChargeResponse>>(PrepareAsyncAutoChargeRaw(context, request, cq));
    }
    ::grpc::Status Rotate(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::navService::RotateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::RotateResponse>> AsyncRotate(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::RotateResponse>>(AsyncRotateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::RotateResponse>> PrepareAsyncRotate(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::RotateResponse>>(PrepareAsyncRotateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::navService::OnNavEventChangeResponse>> OnNavEventChange(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::navService::OnNavEventChangeResponse>>(OnNavEventChangeRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::navService::OnNavEventChangeResponse>> AsyncOnNavEventChange(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::navService::OnNavEventChangeResponse>>(AsyncOnNavEventChangeRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::navService::OnNavEventChangeResponse>> PrepareAsyncOnNavEventChange(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::navService::OnNavEventChangeResponse>>(PrepareAsyncOnNavEventChangeRaw(context, request, cq));
    }
    ::grpc::Status LocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::navService::LocationResetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::LocationResetResponse>> AsyncLocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::LocationResetResponse>>(AsyncLocationResetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::LocationResetResponse>> PrepareAsyncLocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::LocationResetResponse>>(PrepareAsyncLocationResetRaw(context, request, cq));
    }
    ::grpc::Status NewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::navService::NewRouteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NewRouteResponse>> AsyncNewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NewRouteResponse>>(AsyncNewRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NewRouteResponse>> PrepareAsyncNewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::NewRouteResponse>>(PrepareAsyncNewRouteRaw(context, request, cq));
    }
    ::grpc::Status ListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::navService::ListRoutesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::ListRoutesResponse>> AsyncListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::ListRoutesResponse>>(AsyncListRoutesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::ListRoutesResponse>> PrepareAsyncListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::ListRoutesResponse>>(PrepareAsyncListRoutesRaw(context, request, cq));
    }
    ::grpc::Status UpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::navService::UpdateRouteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::UpdateRouteResponse>> AsyncUpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::UpdateRouteResponse>>(AsyncUpdateRouteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::UpdateRouteResponse>> PrepareAsyncUpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::UpdateRouteResponse>>(PrepareAsyncUpdateRouteRaw(context, request, cq));
    }
    ::grpc::Status DeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::navService::DeleteRoutesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::DeleteRoutesResponse>> AsyncDeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::DeleteRoutesResponse>>(AsyncDeleteRoutesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::DeleteRoutesResponse>> PrepareAsyncDeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::navService::DeleteRoutesResponse>>(PrepareAsyncDeleteRoutesRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Move(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::navService::MoveRequest,::navService::MoveResponse>* reactor) override;
      void NavTo(::grpc::ClientContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response, std::function<void(::grpc::Status)>) override;
      void NavTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavToResponse* response, std::function<void(::grpc::Status)>) override;
      void NavTo(::grpc::ClientContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NavTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response, std::function<void(::grpc::Status)>) override;
      void NavStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavStopResponse* response, std::function<void(::grpc::Status)>) override;
      void NavStop(::grpc::ClientContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NavStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NavStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response, std::function<void(::grpc::Status)>) override;
      void AutoCharge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::AutoChargeResponse* response, std::function<void(::grpc::Status)>) override;
      void AutoCharge(::grpc::ClientContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AutoCharge(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::AutoChargeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Rotate(::grpc::ClientContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response, std::function<void(::grpc::Status)>) override;
      void Rotate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::RotateResponse* response, std::function<void(::grpc::Status)>) override;
      void Rotate(::grpc::ClientContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Rotate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::RotateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void OnNavEventChange(::grpc::ClientContext* context, ::navService::OnNavEventChangeRequest* request, ::grpc::experimental::ClientReadReactor< ::navService::OnNavEventChangeResponse>* reactor) override;
      void LocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response, std::function<void(::grpc::Status)>) override;
      void LocationReset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::LocationResetResponse* response, std::function<void(::grpc::Status)>) override;
      void LocationReset(::grpc::ClientContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void LocationReset(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::LocationResetResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response, std::function<void(::grpc::Status)>) override;
      void NewRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NewRouteResponse* response, std::function<void(::grpc::Status)>) override;
      void NewRoute(::grpc::ClientContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NewRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::NewRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::ListRoutesResponse* response, std::function<void(::grpc::Status)>) override;
      void ListRoutes(::grpc::ClientContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::ListRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::UpdateRouteResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateRoute(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateRoute(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::UpdateRouteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::DeleteRoutesResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteRoutes(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteRoutes(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::navService::DeleteRoutesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>* MoveRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>* AsyncMoveRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::navService::MoveRequest, ::navService::MoveResponse>* PrepareAsyncMoveRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::NavToResponse>* AsyncNavToRaw(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::NavToResponse>* PrepareAsyncNavToRaw(::grpc::ClientContext* context, const ::navService::NavToRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::NavStopResponse>* AsyncNavStopRaw(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::NavStopResponse>* PrepareAsyncNavStopRaw(::grpc::ClientContext* context, const ::navService::NavStopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::AutoChargeResponse>* AsyncAutoChargeRaw(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::AutoChargeResponse>* PrepareAsyncAutoChargeRaw(::grpc::ClientContext* context, const ::navService::AutoChargeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::RotateResponse>* AsyncRotateRaw(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::RotateResponse>* PrepareAsyncRotateRaw(::grpc::ClientContext* context, const ::navService::RotateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::navService::OnNavEventChangeResponse>* OnNavEventChangeRaw(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request) override;
    ::grpc::ClientAsyncReader< ::navService::OnNavEventChangeResponse>* AsyncOnNavEventChangeRaw(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::navService::OnNavEventChangeResponse>* PrepareAsyncOnNavEventChangeRaw(::grpc::ClientContext* context, const ::navService::OnNavEventChangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::LocationResetResponse>* AsyncLocationResetRaw(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::LocationResetResponse>* PrepareAsyncLocationResetRaw(::grpc::ClientContext* context, const ::navService::LocationResetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::NewRouteResponse>* AsyncNewRouteRaw(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::NewRouteResponse>* PrepareAsyncNewRouteRaw(::grpc::ClientContext* context, const ::navService::NewRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::ListRoutesResponse>* AsyncListRoutesRaw(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::ListRoutesResponse>* PrepareAsyncListRoutesRaw(::grpc::ClientContext* context, const ::navService::ListRoutesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::UpdateRouteResponse>* AsyncUpdateRouteRaw(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::UpdateRouteResponse>* PrepareAsyncUpdateRouteRaw(::grpc::ClientContext* context, const ::navService::UpdateRouteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::DeleteRoutesResponse>* AsyncDeleteRoutesRaw(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::navService::DeleteRoutesResponse>* PrepareAsyncDeleteRoutesRaw(::grpc::ClientContext* context, const ::navService::DeleteRoutesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Move_;
    const ::grpc::internal::RpcMethod rpcmethod_NavTo_;
    const ::grpc::internal::RpcMethod rpcmethod_NavStop_;
    const ::grpc::internal::RpcMethod rpcmethod_AutoCharge_;
    const ::grpc::internal::RpcMethod rpcmethod_Rotate_;
    const ::grpc::internal::RpcMethod rpcmethod_OnNavEventChange_;
    const ::grpc::internal::RpcMethod rpcmethod_LocationReset_;
    const ::grpc::internal::RpcMethod rpcmethod_NewRoute_;
    const ::grpc::internal::RpcMethod rpcmethod_ListRoutes_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateRoute_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteRoutes_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 遥控移动
    // 当机器人处于非空闲及遥控移动状态时， 当前链接将被强制关闭, 错误描述为: "[naving|charging|rotating] reject"
    // 当机器人处于 *其它用户* 的遥控移动状态时， *你* 将收到MoveStatusResponse状态码REJ_MOVING
    // 当机器人处于 *你* 的遥控移动状态时, 请在500ms内持续发送遥控指令， 超时将自动停止移动
    // 当机器人处于 *你* 的遥控移动状态时, 若5秒后无遥控指令的更新, *你* 将接收到MoveStatusResponse状态码RELEASED，
    // 此时遥控移动控制权交由抢占的 *其它用户* 或其它类型目标的操作
    virtual ::grpc::Status Move(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::navService::MoveResponse, ::navService::MoveRequest>* stream);
    // 导航
    // 当机器人处理遥控移动中|充电中|旋转中时, 错误描述为: "[moving|charging|rotating] reject"
    // 当机器人处理空闲或导航状态时, 将收到导航的目标NavTarget与导航或失败状态
    // 使用目标导航时支持同步异步模式, 参考NavToRequest.sync_mode的参数描述
    virtual ::grpc::Status NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response);
    // 停止
    // 静止: 立即返回STOPPED
    // 旋转中: 返回旋转状态, STOPPED或CANCEL, 超时3秒
    // 其它: 错误描述为: "[moving|charging] reject"
    virtual ::grpc::Status NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response);
    // 自动充电
    // 当前为充电中|充电连接中: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING|CHARGE_STATUS_CONNECTING|CHARGE_STATUS_RELEASED后返回
    // 当前为充电中|充电连接中: 请求类型为cancel等待状态为CHARGE_STATUS_RELEASED后返回
    // 当前为已释放: 请求类型为cancel将直接返回CHARGE_STATUS_RELEASED
    // 当前为已释放: 请求类型为charge|charge_preset等待状态为CHARGE_STATUS_CHARGING后返回
    // 超时错误: 发送请求后默认60秒后未收到状态更新返回错误描述, 超时时间可在AutoChargeRequest中自定义配置
    virtual ::grpc::Status AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response);
    // 原地旋转
    // 当旋转完成后返回STOPPED
    // 当用户使用NavStop中止时将返回CANCEL
    // 若超时30秒未执行完毕将返回超时错误
    virtual ::grpc::Status Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response);
    // 导航事件监听
    // 监听导航模块中各类事件的变动更新
    virtual ::grpc::Status OnNavEventChange(::grpc::ServerContext* context, const ::navService::OnNavEventChangeRequest* request, ::grpc::ServerWriter< ::navService::OnNavEventChangeResponse>* writer);
    // >=2.2.0
    // 重置当前定位
    // 用于发生定位异常/错误状态，重新初始化导航定位
    // 重定位错误：定位状态超时|无地图|UWB错误
    // 重定位超时判断: 默认3s，仅在非错误状态下重置
    // *目前仅支持无线导航版本，磁导航版本中将直接返回成功状态
    virtual ::grpc::Status LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response);
    // 新建线路
    virtual ::grpc::Status NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response);
    // 获取线路
    virtual ::grpc::Status ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response);
    // 更新线路信息
    virtual ::grpc::Status UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response);
    // 删除线路
    virtual ::grpc::Status DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Move : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Move() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Move() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Move(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::navService::MoveResponse, ::navService::MoveRequest>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMove(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::navService::MoveResponse, ::navService::MoveRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NavTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NavTo() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_NavTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNavTo(::grpc::ServerContext* context, ::navService::NavToRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::NavToResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NavStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NavStop() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_NavStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNavStop(::grpc::ServerContext* context, ::navService::NavStopRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::NavStopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AutoCharge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_AutoCharge() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_AutoCharge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAutoCharge(::grpc::ServerContext* context, ::navService::AutoChargeRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::AutoChargeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Rotate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Rotate() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Rotate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRotate(::grpc::ServerContext* context, ::navService::RotateRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::RotateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnNavEventChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_OnNavEventChange() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_OnNavEventChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnNavEventChange(::grpc::ServerContext* context, const ::navService::OnNavEventChangeRequest* request, ::grpc::ServerWriter< ::navService::OnNavEventChangeResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnNavEventChange(::grpc::ServerContext* context, ::navService::OnNavEventChangeRequest* request, ::grpc::ServerAsyncWriter< ::navService::OnNavEventChangeResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LocationReset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_LocationReset() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_LocationReset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLocationReset(::grpc::ServerContext* context, ::navService::LocationResetRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::LocationResetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NewRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NewRoute() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_NewRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewRoute(::grpc::ServerContext* context, ::navService::NewRouteRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::NewRouteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListRoutes() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ListRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRoutes(::grpc::ServerContext* context, ::navService::ListRoutesRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::ListRoutesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateRoute() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_UpdateRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateRoute(::grpc::ServerContext* context, ::navService::UpdateRouteRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::UpdateRouteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteRoutes() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_DeleteRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteRoutes(::grpc::ServerContext* context, ::navService::DeleteRoutesRequest* request, ::grpc::ServerAsyncResponseWriter< ::navService::DeleteRoutesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Move<WithAsyncMethod_NavTo<WithAsyncMethod_NavStop<WithAsyncMethod_AutoCharge<WithAsyncMethod_Rotate<WithAsyncMethod_OnNavEventChange<WithAsyncMethod_LocationReset<WithAsyncMethod_NewRoute<WithAsyncMethod_ListRoutes<WithAsyncMethod_UpdateRoute<WithAsyncMethod_DeleteRoutes<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Move : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Move() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackBidiHandler< ::navService::MoveRequest, ::navService::MoveResponse>(
          [this] { return this->Move(); }));
    }
    ~ExperimentalWithCallbackMethod_Move() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Move(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::navService::MoveResponse, ::navService::MoveRequest>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::navService::MoveRequest, ::navService::MoveResponse>* Move() {
      return new ::grpc::internal::UnimplementedBidiReactor<
        ::navService::MoveRequest, ::navService::MoveResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NavTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_NavTo() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::NavToRequest, ::navService::NavToResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::NavToRequest* request,
                 ::navService::NavToResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->NavTo(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_NavTo(
        ::grpc::experimental::MessageAllocator< ::navService::NavToRequest, ::navService::NavToResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::NavToRequest, ::navService::NavToResponse>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NavTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NavStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_NavStop() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::NavStopRequest, ::navService::NavStopResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::NavStopRequest* request,
                 ::navService::NavStopResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->NavStop(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_NavStop(
        ::grpc::experimental::MessageAllocator< ::navService::NavStopRequest, ::navService::NavStopResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::NavStopRequest, ::navService::NavStopResponse>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NavStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AutoCharge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_AutoCharge() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::AutoChargeRequest, ::navService::AutoChargeResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::AutoChargeRequest* request,
                 ::navService::AutoChargeResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AutoCharge(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AutoCharge(
        ::grpc::experimental::MessageAllocator< ::navService::AutoChargeRequest, ::navService::AutoChargeResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::AutoChargeRequest, ::navService::AutoChargeResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AutoCharge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Rotate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Rotate() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::RotateRequest, ::navService::RotateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::RotateRequest* request,
                 ::navService::RotateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Rotate(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Rotate(
        ::grpc::experimental::MessageAllocator< ::navService::RotateRequest, ::navService::RotateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::RotateRequest, ::navService::RotateResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Rotate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_OnNavEventChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_OnNavEventChange() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackServerStreamingHandler< ::navService::OnNavEventChangeRequest, ::navService::OnNavEventChangeResponse>(
          [this] { return this->OnNavEventChange(); }));
    }
    ~ExperimentalWithCallbackMethod_OnNavEventChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnNavEventChange(::grpc::ServerContext* context, const ::navService::OnNavEventChangeRequest* request, ::grpc::ServerWriter< ::navService::OnNavEventChangeResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::navService::OnNavEventChangeRequest, ::navService::OnNavEventChangeResponse>* OnNavEventChange() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::navService::OnNavEventChangeRequest, ::navService::OnNavEventChangeResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LocationReset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_LocationReset() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::LocationResetRequest, ::navService::LocationResetResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::LocationResetRequest* request,
                 ::navService::LocationResetResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->LocationReset(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_LocationReset(
        ::grpc::experimental::MessageAllocator< ::navService::LocationResetRequest, ::navService::LocationResetResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::LocationResetRequest, ::navService::LocationResetResponse>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LocationReset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NewRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_NewRoute() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::NewRouteRequest, ::navService::NewRouteResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::NewRouteRequest* request,
                 ::navService::NewRouteResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->NewRoute(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_NewRoute(
        ::grpc::experimental::MessageAllocator< ::navService::NewRouteRequest, ::navService::NewRouteResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::NewRouteRequest, ::navService::NewRouteResponse>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NewRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListRoutes() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::ListRoutesRequest, ::navService::ListRoutesResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::ListRoutesRequest* request,
                 ::navService::ListRoutesResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListRoutes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListRoutes(
        ::grpc::experimental::MessageAllocator< ::navService::ListRoutesRequest, ::navService::ListRoutesResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::ListRoutesRequest, ::navService::ListRoutesResponse>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateRoute() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::UpdateRouteRequest, ::navService::UpdateRouteResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::UpdateRouteRequest* request,
                 ::navService::UpdateRouteResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateRoute(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateRoute(
        ::grpc::experimental::MessageAllocator< ::navService::UpdateRouteRequest, ::navService::UpdateRouteResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::UpdateRouteRequest, ::navService::UpdateRouteResponse>*>(
          ::grpc::Service::experimental().GetHandler(9))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteRoutes() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::navService::DeleteRoutesRequest, ::navService::DeleteRoutesResponse>(
          [this](::grpc::ServerContext* context,
                 const ::navService::DeleteRoutesRequest* request,
                 ::navService::DeleteRoutesResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteRoutes(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteRoutes(
        ::grpc::experimental::MessageAllocator< ::navService::DeleteRoutesRequest, ::navService::DeleteRoutesResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::navService::DeleteRoutesRequest, ::navService::DeleteRoutesResponse>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_Move<ExperimentalWithCallbackMethod_NavTo<ExperimentalWithCallbackMethod_NavStop<ExperimentalWithCallbackMethod_AutoCharge<ExperimentalWithCallbackMethod_Rotate<ExperimentalWithCallbackMethod_OnNavEventChange<ExperimentalWithCallbackMethod_LocationReset<ExperimentalWithCallbackMethod_NewRoute<ExperimentalWithCallbackMethod_ListRoutes<ExperimentalWithCallbackMethod_UpdateRoute<ExperimentalWithCallbackMethod_DeleteRoutes<Service > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Move : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Move() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Move() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Move(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::navService::MoveResponse, ::navService::MoveRequest>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NavTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NavTo() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_NavTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NavStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NavStop() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_NavStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AutoCharge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_AutoCharge() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_AutoCharge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Rotate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Rotate() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Rotate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnNavEventChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_OnNavEventChange() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_OnNavEventChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnNavEventChange(::grpc::ServerContext* context, const ::navService::OnNavEventChangeRequest* request, ::grpc::ServerWriter< ::navService::OnNavEventChangeResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LocationReset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_LocationReset() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_LocationReset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NewRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NewRoute() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_NewRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListRoutes() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ListRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateRoute() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_UpdateRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteRoutes() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_DeleteRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Move : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Move() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Move() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Move(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::navService::MoveResponse, ::navService::MoveRequest>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMove(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NavTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_NavTo() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_NavTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNavTo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NavStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_NavStop() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_NavStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNavStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AutoCharge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_AutoCharge() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_AutoCharge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAutoCharge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Rotate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Rotate() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Rotate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRotate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_OnNavEventChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_OnNavEventChange() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_OnNavEventChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnNavEventChange(::grpc::ServerContext* context, const ::navService::OnNavEventChangeRequest* request, ::grpc::ServerWriter< ::navService::OnNavEventChangeResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnNavEventChange(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LocationReset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_LocationReset() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_LocationReset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLocationReset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NewRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_NewRoute() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_NewRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewRoute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListRoutes() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ListRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRoutes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateRoute() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_UpdateRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateRoute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteRoutes() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_DeleteRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteRoutes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Move : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Move() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->Move(); }));
    }
    ~ExperimentalWithRawCallbackMethod_Move() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Move(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::navService::MoveResponse, ::navService::MoveRequest>* stream)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Move() {
      return new ::grpc::internal::UnimplementedBidiReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NavTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_NavTo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->NavTo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_NavTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NavTo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NavStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_NavStop() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->NavStop(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_NavStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NavStop(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AutoCharge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_AutoCharge() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AutoCharge(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AutoCharge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AutoCharge(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Rotate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Rotate() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Rotate(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Rotate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Rotate(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_OnNavEventChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_OnNavEventChange() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->OnNavEventChange(); }));
    }
    ~ExperimentalWithRawCallbackMethod_OnNavEventChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnNavEventChange(::grpc::ServerContext* context, const ::navService::OnNavEventChangeRequest* request, ::grpc::ServerWriter< ::navService::OnNavEventChangeResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* OnNavEventChange() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LocationReset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_LocationReset() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->LocationReset(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_LocationReset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void LocationReset(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NewRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_NewRoute() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->NewRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_NewRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewRoute(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListRoutes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListRoutes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListRoutes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateRoute() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateRoute(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateRoute(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteRoutes() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteRoutes(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteRoutes(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NavTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NavTo() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::NavToRequest, ::navService::NavToResponse>(std::bind(&WithStreamedUnaryMethod_NavTo<BaseClass>::StreamedNavTo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NavTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NavTo(::grpc::ServerContext* context, const ::navService::NavToRequest* request, ::navService::NavToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNavTo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::NavToRequest,::navService::NavToResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NavStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NavStop() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::NavStopRequest, ::navService::NavStopResponse>(std::bind(&WithStreamedUnaryMethod_NavStop<BaseClass>::StreamedNavStop, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NavStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NavStop(::grpc::ServerContext* context, const ::navService::NavStopRequest* request, ::navService::NavStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNavStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::NavStopRequest,::navService::NavStopResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AutoCharge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_AutoCharge() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::AutoChargeRequest, ::navService::AutoChargeResponse>(std::bind(&WithStreamedUnaryMethod_AutoCharge<BaseClass>::StreamedAutoCharge, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AutoCharge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AutoCharge(::grpc::ServerContext* context, const ::navService::AutoChargeRequest* request, ::navService::AutoChargeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAutoCharge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::AutoChargeRequest,::navService::AutoChargeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Rotate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Rotate() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::RotateRequest, ::navService::RotateResponse>(std::bind(&WithStreamedUnaryMethod_Rotate<BaseClass>::StreamedRotate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Rotate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Rotate(::grpc::ServerContext* context, const ::navService::RotateRequest* request, ::navService::RotateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRotate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::RotateRequest,::navService::RotateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LocationReset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_LocationReset() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::LocationResetRequest, ::navService::LocationResetResponse>(std::bind(&WithStreamedUnaryMethod_LocationReset<BaseClass>::StreamedLocationReset, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_LocationReset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LocationReset(::grpc::ServerContext* context, const ::navService::LocationResetRequest* request, ::navService::LocationResetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLocationReset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::LocationResetRequest,::navService::LocationResetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NewRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NewRoute() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::NewRouteRequest, ::navService::NewRouteResponse>(std::bind(&WithStreamedUnaryMethod_NewRoute<BaseClass>::StreamedNewRoute, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NewRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NewRoute(::grpc::ServerContext* context, const ::navService::NewRouteRequest* request, ::navService::NewRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNewRoute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::NewRouteRequest,::navService::NewRouteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListRoutes() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::ListRoutesRequest, ::navService::ListRoutesResponse>(std::bind(&WithStreamedUnaryMethod_ListRoutes<BaseClass>::StreamedListRoutes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListRoutes(::grpc::ServerContext* context, const ::navService::ListRoutesRequest* request, ::navService::ListRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListRoutes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::ListRoutesRequest,::navService::ListRoutesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateRoute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateRoute() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::UpdateRouteRequest, ::navService::UpdateRouteResponse>(std::bind(&WithStreamedUnaryMethod_UpdateRoute<BaseClass>::StreamedUpdateRoute, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateRoute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateRoute(::grpc::ServerContext* context, const ::navService::UpdateRouteRequest* request, ::navService::UpdateRouteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateRoute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::UpdateRouteRequest,::navService::UpdateRouteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteRoutes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteRoutes() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::navService::DeleteRoutesRequest, ::navService::DeleteRoutesResponse>(std::bind(&WithStreamedUnaryMethod_DeleteRoutes<BaseClass>::StreamedDeleteRoutes, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteRoutes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteRoutes(::grpc::ServerContext* context, const ::navService::DeleteRoutesRequest* request, ::navService::DeleteRoutesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteRoutes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::navService::DeleteRoutesRequest,::navService::DeleteRoutesResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_NavTo<WithStreamedUnaryMethod_NavStop<WithStreamedUnaryMethod_AutoCharge<WithStreamedUnaryMethod_Rotate<WithStreamedUnaryMethod_LocationReset<WithStreamedUnaryMethod_NewRoute<WithStreamedUnaryMethod_ListRoutes<WithStreamedUnaryMethod_UpdateRoute<WithStreamedUnaryMethod_DeleteRoutes<Service > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_OnNavEventChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_OnNavEventChange() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler< ::navService::OnNavEventChangeRequest, ::navService::OnNavEventChangeResponse>(std::bind(&WithSplitStreamingMethod_OnNavEventChange<BaseClass>::StreamedOnNavEventChange, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_OnNavEventChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnNavEventChange(::grpc::ServerContext* context, const ::navService::OnNavEventChangeRequest* request, ::grpc::ServerWriter< ::navService::OnNavEventChangeResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOnNavEventChange(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::navService::OnNavEventChangeRequest,::navService::OnNavEventChangeResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_OnNavEventChange<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_NavTo<WithStreamedUnaryMethod_NavStop<WithStreamedUnaryMethod_AutoCharge<WithStreamedUnaryMethod_Rotate<WithSplitStreamingMethod_OnNavEventChange<WithStreamedUnaryMethod_LocationReset<WithStreamedUnaryMethod_NewRoute<WithStreamedUnaryMethod_ListRoutes<WithStreamedUnaryMethod_UpdateRoute<WithStreamedUnaryMethod_DeleteRoutes<Service > > > > > > > > > > StreamedService;
};

}  // namespace navService


#endif  // GRPC_nav_2eproto__INCLUDED
