// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nav.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Nav.pbobjc.h"
#import "google/api/Annotations.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - NavRoot

@implementation NavRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[GAPIAnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - NavRoot_FileDescriptor

static GPBFileDescriptor *NavRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"navService"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum StatusCode

GPBEnumDescriptor *StatusCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Stopped\000Moving\000Preparing\000Cancel\000"
        "Released\000ErrObstacle\000ErrNotReady\000ErrMoto"
        "rFail\000ErrWrongTarget\000RejMoving\000RejNaving"
        "\000RejCharging\000RejRotating\000";
    static const int32_t values[] = {
        StatusCode_Unknown,
        StatusCode_Stopped,
        StatusCode_Moving,
        StatusCode_Preparing,
        StatusCode_Cancel,
        StatusCode_Released,
        StatusCode_ErrObstacle,
        StatusCode_ErrNotReady,
        StatusCode_ErrMotorFail,
        StatusCode_ErrWrongTarget,
        StatusCode_RejMoving,
        StatusCode_RejNaving,
        StatusCode_RejCharging,
        StatusCode_RejRotating,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(StatusCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:StatusCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL StatusCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case StatusCode_Unknown:
    case StatusCode_Stopped:
    case StatusCode_Moving:
    case StatusCode_Preparing:
    case StatusCode_Cancel:
    case StatusCode_Released:
    case StatusCode_ErrObstacle:
    case StatusCode_ErrNotReady:
    case StatusCode_ErrMotorFail:
    case StatusCode_ErrWrongTarget:
    case StatusCode_RejMoving:
    case StatusCode_RejNaving:
    case StatusCode_RejCharging:
    case StatusCode_RejRotating:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MoveDirection

GPBEnumDescriptor *MoveDirection_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Release\000Forward\000Backward\000Left\000Right\000Left"
        "Forward\000RightForward\000LeftBackward\000RightB"
        "ackward\000";
    static const int32_t values[] = {
        MoveDirection_Release,
        MoveDirection_Forward,
        MoveDirection_Backward,
        MoveDirection_Left,
        MoveDirection_Right,
        MoveDirection_LeftForward,
        MoveDirection_RightForward,
        MoveDirection_LeftBackward,
        MoveDirection_RightBackward,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MoveDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MoveDirection_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MoveDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case MoveDirection_Release:
    case MoveDirection_Forward:
    case MoveDirection_Backward:
    case MoveDirection_Left:
    case MoveDirection_Right:
    case MoveDirection_LeftForward:
    case MoveDirection_RightForward:
    case MoveDirection_LeftBackward:
    case MoveDirection_RightBackward:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RoamingType

GPBEnumDescriptor *RoamingType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RoamingTypeContinue\000RoamingTypeOrder\000Roa"
        "mingTypeRandom\000";
    static const int32_t values[] = {
        RoamingType_RoamingTypeContinue,
        RoamingType_RoamingTypeOrder,
        RoamingType_RoamingTypeRandom,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RoamingType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RoamingType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RoamingType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RoamingType_RoamingTypeContinue:
    case RoamingType_RoamingTypeOrder:
    case RoamingType_RoamingTypeRandom:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChargeStatusCode

GPBEnumDescriptor *ChargeStatusCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ChargeStatusUnknown\000ChargeStatusPreparin"
        "g\000ChargeStatusReleased\000ChargeStatusConne"
        "cting\000ChargeStatusCharging\000ChargeStatusD"
        "isconnecting\000ChargeConnectFail\000ChargeSta"
        "tusNavObstacle\000";
    static const int32_t values[] = {
        ChargeStatusCode_ChargeStatusUnknown,
        ChargeStatusCode_ChargeStatusPreparing,
        ChargeStatusCode_ChargeStatusReleased,
        ChargeStatusCode_ChargeStatusConnecting,
        ChargeStatusCode_ChargeStatusCharging,
        ChargeStatusCode_ChargeStatusDisconnecting,
        ChargeStatusCode_ChargeConnectFail,
        ChargeStatusCode_ChargeStatusNavObstacle,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChargeStatusCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChargeStatusCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChargeStatusCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChargeStatusCode_ChargeStatusUnknown:
    case ChargeStatusCode_ChargeStatusPreparing:
    case ChargeStatusCode_ChargeStatusReleased:
    case ChargeStatusCode_ChargeStatusConnecting:
    case ChargeStatusCode_ChargeStatusCharging:
    case ChargeStatusCode_ChargeStatusDisconnecting:
    case ChargeStatusCode_ChargeConnectFail:
    case ChargeStatusCode_ChargeStatusNavObstacle:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum NavEventType

GPBEnumDescriptor *NavEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NavEventReversed\000MoveEvent\000NavEvent\000Auto"
        "ChargeEvent\000RotateEvent\000";
    static const int32_t values[] = {
        NavEventType_NavEventReversed,
        NavEventType_MoveEvent,
        NavEventType_NavEvent,
        NavEventType_AutoChargeEvent,
        NavEventType_RotateEvent,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NavEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NavEventType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NavEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case NavEventType_NavEventReversed:
    case NavEventType_MoveEvent:
    case NavEventType_NavEvent:
    case NavEventType_AutoChargeEvent:
    case NavEventType_RotateEvent:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MoveRequest

@implementation MoveRequest

@dynamic speed;
@dynamic rspeed;
@dynamic direction;
@dynamic mode;

typedef struct MoveRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t speed;
  uint32_t rspeed;
  MoveDirection direction;
  NSString *mode;
} MoveRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = MoveRequest_FieldNumber_Speed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MoveRequest__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "rspeed",
        .dataTypeSpecific.className = NULL,
        .number = MoveRequest_FieldNumber_Rspeed,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MoveRequest__storage_, rspeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "direction",
        .dataTypeSpecific.enumDescFunc = MoveDirection_EnumDescriptor,
        .number = MoveRequest_FieldNumber_Direction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MoveRequest__storage_, direction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mode",
        .dataTypeSpecific.className = NULL,
        .number = MoveRequest_FieldNumber_Mode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MoveRequest__storage_, mode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MoveRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MoveRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MoveRequest_Direction_RawValue(MoveRequest *message) {
  GPBDescriptor *descriptor = [MoveRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MoveRequest_FieldNumber_Direction];
  return GPBGetMessageInt32Field(message, field);
}

void SetMoveRequest_Direction_RawValue(MoveRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [MoveRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MoveRequest_FieldNumber_Direction];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - MoveResponse

@implementation MoveResponse

@dynamic statusCode;

typedef struct MoveResponse__storage_ {
  uint32_t _has_storage_[1];
  StatusCode statusCode;
} MoveResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = StatusCode_EnumDescriptor,
        .number = MoveResponse_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MoveResponse__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MoveResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MoveResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MoveResponse_StatusCode_RawValue(MoveResponse *message) {
  GPBDescriptor *descriptor = [MoveResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MoveResponse_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetMoveResponse_StatusCode_RawValue(MoveResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [MoveResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MoveResponse_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - NavTarget

@implementation NavTarget

@dynamic index;
@dynamic name;

typedef struct NavTarget__storage_ {
  uint32_t _has_storage_[1];
  NSString *index;
  NSString *name;
} NavTarget__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = NavTarget_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NavTarget__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = NavTarget_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NavTarget__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NavTarget class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NavTarget__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NavRoaming

@implementation NavRoaming

@dynamic navRoamingType;
@dynamic waitSec;
@dynamic roamingTargetIndexesArray, roamingTargetIndexesArray_Count;
@dynamic orderLoop;

typedef struct NavRoaming__storage_ {
  uint32_t _has_storage_[1];
  RoamingType navRoamingType;
  int32_t waitSec;
  NSMutableArray *roamingTargetIndexesArray;
} NavRoaming__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "navRoamingType",
        .dataTypeSpecific.enumDescFunc = RoamingType_EnumDescriptor,
        .number = NavRoaming_FieldNumber_NavRoamingType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NavRoaming__storage_, navRoamingType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "waitSec",
        .dataTypeSpecific.className = NULL,
        .number = NavRoaming_FieldNumber_WaitSec,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NavRoaming__storage_, waitSec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roamingTargetIndexesArray",
        .dataTypeSpecific.className = NULL,
        .number = NavRoaming_FieldNumber_RoamingTargetIndexesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NavRoaming__storage_, roamingTargetIndexesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "orderLoop",
        .dataTypeSpecific.className = NULL,
        .number = NavRoaming_FieldNumber_OrderLoop,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NavRoaming class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NavRoaming__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NavRoaming_NavRoamingType_RawValue(NavRoaming *message) {
  GPBDescriptor *descriptor = [NavRoaming descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavRoaming_FieldNumber_NavRoamingType];
  return GPBGetMessageInt32Field(message, field);
}

void SetNavRoaming_NavRoamingType_RawValue(NavRoaming *message, int32_t value) {
  GPBDescriptor *descriptor = [NavRoaming descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavRoaming_FieldNumber_NavRoamingType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - NavToRequest

@implementation NavToRequest

@dynamic targetOneofOneOfCase;
@dynamic target;
@dynamic roaming;
@dynamic speed;
@dynamic syncMode;

typedef struct NavToRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t speed;
  NavTarget *target;
  NavRoaming *roaming;
} NavToRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "target",
        .dataTypeSpecific.className = GPBStringifySymbol(NavTarget),
        .number = NavToRequest_FieldNumber_Target,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NavToRequest__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = NavToRequest_FieldNumber_Speed,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NavToRequest__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "roaming",
        .dataTypeSpecific.className = GPBStringifySymbol(NavRoaming),
        .number = NavToRequest_FieldNumber_Roaming,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NavToRequest__storage_, roaming),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncMode",
        .dataTypeSpecific.className = NULL,
        .number = NavToRequest_FieldNumber_SyncMode,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NavToRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NavToRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "targetOneof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void NavToRequest_ClearTargetOneofOneOfCase(NavToRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - NavToResponse

@implementation NavToResponse

@dynamic targetOneofOneOfCase;
@dynamic statusCode;
@dynamic target;
@dynamic isRoaming;

typedef struct NavToResponse__storage_ {
  uint32_t _has_storage_[2];
  StatusCode statusCode;
  NavTarget *target;
} NavToResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = StatusCode_EnumDescriptor,
        .number = NavToResponse_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NavToResponse__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "target",
        .dataTypeSpecific.className = GPBStringifySymbol(NavTarget),
        .number = NavToResponse_FieldNumber_Target,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(NavToResponse__storage_, target),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "isRoaming",
        .dataTypeSpecific.className = NULL,
        .number = NavToResponse_FieldNumber_IsRoaming,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NavToResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NavToResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "targetOneof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NavToResponse_StatusCode_RawValue(NavToResponse *message) {
  GPBDescriptor *descriptor = [NavToResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavToResponse_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetNavToResponse_StatusCode_RawValue(NavToResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [NavToResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavToResponse_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void NavToResponse_ClearTargetOneofOneOfCase(NavToResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - NavStopRequest

@implementation NavStopRequest


typedef struct NavStopRequest__storage_ {
  uint32_t _has_storage_[1];
} NavStopRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NavStopRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NavStopRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NavStopResponse

@implementation NavStopResponse

@dynamic statusCode;

typedef struct NavStopResponse__storage_ {
  uint32_t _has_storage_[1];
  StatusCode statusCode;
} NavStopResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = StatusCode_EnumDescriptor,
        .number = NavStopResponse_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NavStopResponse__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NavStopResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NavStopResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NavStopResponse_StatusCode_RawValue(NavStopResponse *message) {
  GPBDescriptor *descriptor = [NavStopResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavStopResponse_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetNavStopResponse_StatusCode_RawValue(NavStopResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [NavStopResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavStopResponse_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AutoChargeRequest

@implementation AutoChargeRequest

@dynamic chargeOptionOneofOneOfCase;
@dynamic charge;
@dynamic cancel;
@dynamic chargePreset;
@dynamic timeoutSec;

typedef struct AutoChargeRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t timeoutSec;
} AutoChargeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "charge",
        .dataTypeSpecific.className = NULL,
        .number = AutoChargeRequest_FieldNumber_Charge,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cancel",
        .dataTypeSpecific.className = NULL,
        .number = AutoChargeRequest_FieldNumber_Cancel,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "chargePreset",
        .dataTypeSpecific.className = NULL,
        .number = AutoChargeRequest_FieldNumber_ChargePreset,
        .hasIndex = -1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timeoutSec",
        .dataTypeSpecific.className = NULL,
        .number = AutoChargeRequest_FieldNumber_TimeoutSec,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AutoChargeRequest__storage_, timeoutSec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoChargeRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoChargeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "chargeOptionOneof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void AutoChargeRequest_ClearChargeOptionOneofOneOfCase(AutoChargeRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - AutoChargeResponse

@implementation AutoChargeResponse

@dynamic chargeStatusCode;

typedef struct AutoChargeResponse__storage_ {
  uint32_t _has_storage_[1];
  ChargeStatusCode chargeStatusCode;
} AutoChargeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chargeStatusCode",
        .dataTypeSpecific.enumDescFunc = ChargeStatusCode_EnumDescriptor,
        .number = AutoChargeResponse_FieldNumber_ChargeStatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoChargeResponse__storage_, chargeStatusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoChargeResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoChargeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AutoChargeResponse_ChargeStatusCode_RawValue(AutoChargeResponse *message) {
  GPBDescriptor *descriptor = [AutoChargeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutoChargeResponse_FieldNumber_ChargeStatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetAutoChargeResponse_ChargeStatusCode_RawValue(AutoChargeResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [AutoChargeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutoChargeResponse_FieldNumber_ChargeStatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RotateRequest

@implementation RotateRequest

@dynamic rotateOneofOneOfCase;
@dynamic angle;
@dynamic rollback;

typedef struct RotateRequest__storage_ {
  uint32_t _has_storage_[2];
  int32_t angle;
} RotateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "angle",
        .dataTypeSpecific.className = NULL,
        .number = RotateRequest_FieldNumber_Angle,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RotateRequest__storage_, angle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "rollback",
        .dataTypeSpecific.className = NULL,
        .number = RotateRequest_FieldNumber_Rollback,
        .hasIndex = -1,
        .offset = 0,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RotateRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RotateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "rotateOneof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void RotateRequest_ClearRotateOneofOneOfCase(RotateRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - RotateResponse

@implementation RotateResponse

@dynamic statusCode;

typedef struct RotateResponse__storage_ {
  uint32_t _has_storage_[1];
  StatusCode statusCode;
} RotateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = StatusCode_EnumDescriptor,
        .number = RotateResponse_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RotateResponse__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RotateResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RotateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RotateResponse_StatusCode_RawValue(RotateResponse *message) {
  GPBDescriptor *descriptor = [RotateResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RotateResponse_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetRotateResponse_StatusCode_RawValue(RotateResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RotateResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RotateResponse_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - OnNavEventChangeRequest

@implementation OnNavEventChangeRequest


typedef struct OnNavEventChangeRequest__storage_ {
  uint32_t _has_storage_[1];
} OnNavEventChangeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OnNavEventChangeRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(OnNavEventChangeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MoveEvent

@implementation MoveEvent

@dynamic statusCode;

typedef struct MoveEvent__storage_ {
  uint32_t _has_storage_[1];
  StatusCode statusCode;
} MoveEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = StatusCode_EnumDescriptor,
        .number = MoveEvent_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MoveEvent__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MoveEvent class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MoveEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t MoveEvent_StatusCode_RawValue(MoveEvent *message) {
  GPBDescriptor *descriptor = [MoveEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MoveEvent_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetMoveEvent_StatusCode_RawValue(MoveEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [MoveEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:MoveEvent_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - NavEvent

@implementation NavEvent

@dynamic statusCode;
@dynamic hasNavTarget, navTarget;

typedef struct NavEvent__storage_ {
  uint32_t _has_storage_[1];
  StatusCode statusCode;
  NavTarget *navTarget;
} NavEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = StatusCode_EnumDescriptor,
        .number = NavEvent_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NavEvent__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "navTarget",
        .dataTypeSpecific.className = GPBStringifySymbol(NavTarget),
        .number = NavEvent_FieldNumber_NavTarget,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NavEvent__storage_, navTarget),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NavEvent class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NavEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NavEvent_StatusCode_RawValue(NavEvent *message) {
  GPBDescriptor *descriptor = [NavEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavEvent_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetNavEvent_StatusCode_RawValue(NavEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [NavEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NavEvent_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AutoChargeEvent

@implementation AutoChargeEvent

@dynamic chargeStatusCode;

typedef struct AutoChargeEvent__storage_ {
  uint32_t _has_storage_[1];
  ChargeStatusCode chargeStatusCode;
} AutoChargeEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chargeStatusCode",
        .dataTypeSpecific.enumDescFunc = ChargeStatusCode_EnumDescriptor,
        .number = AutoChargeEvent_FieldNumber_ChargeStatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoChargeEvent__storage_, chargeStatusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoChargeEvent class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoChargeEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AutoChargeEvent_ChargeStatusCode_RawValue(AutoChargeEvent *message) {
  GPBDescriptor *descriptor = [AutoChargeEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutoChargeEvent_FieldNumber_ChargeStatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetAutoChargeEvent_ChargeStatusCode_RawValue(AutoChargeEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [AutoChargeEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AutoChargeEvent_FieldNumber_ChargeStatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RotateEvent

@implementation RotateEvent

@dynamic statusCode;

typedef struct RotateEvent__storage_ {
  uint32_t _has_storage_[1];
  StatusCode statusCode;
} RotateEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "statusCode",
        .dataTypeSpecific.enumDescFunc = StatusCode_EnumDescriptor,
        .number = RotateEvent_FieldNumber_StatusCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RotateEvent__storage_, statusCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RotateEvent class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RotateEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RotateEvent_StatusCode_RawValue(RotateEvent *message) {
  GPBDescriptor *descriptor = [RotateEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RotateEvent_FieldNumber_StatusCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetRotateEvent_StatusCode_RawValue(RotateEvent *message, int32_t value) {
  GPBDescriptor *descriptor = [RotateEvent descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RotateEvent_FieldNumber_StatusCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - OnNavEventChangeResponse

@implementation OnNavEventChangeResponse

@dynamic changeOneofOneOfCase;
@dynamic navEventType;
@dynamic moveEvent;
@dynamic navEvent;
@dynamic rotateEvent;
@dynamic autoChargeEvent;

typedef struct OnNavEventChangeResponse__storage_ {
  uint32_t _has_storage_[2];
  NavEventType navEventType;
  MoveEvent *moveEvent;
  NavEvent *navEvent;
  RotateEvent *rotateEvent;
  AutoChargeEvent *autoChargeEvent;
} OnNavEventChangeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "navEventType",
        .dataTypeSpecific.enumDescFunc = NavEventType_EnumDescriptor,
        .number = OnNavEventChangeResponse_FieldNumber_NavEventType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OnNavEventChangeResponse__storage_, navEventType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "moveEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(MoveEvent),
        .number = OnNavEventChangeResponse_FieldNumber_MoveEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OnNavEventChangeResponse__storage_, moveEvent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "navEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(NavEvent),
        .number = OnNavEventChangeResponse_FieldNumber_NavEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OnNavEventChangeResponse__storage_, navEvent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rotateEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(RotateEvent),
        .number = OnNavEventChangeResponse_FieldNumber_RotateEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OnNavEventChangeResponse__storage_, rotateEvent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoChargeEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(AutoChargeEvent),
        .number = OnNavEventChangeResponse_FieldNumber_AutoChargeEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(OnNavEventChangeResponse__storage_, autoChargeEvent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OnNavEventChangeResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OnNavEventChangeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "changeOneof",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OnNavEventChangeResponse_NavEventType_RawValue(OnNavEventChangeResponse *message) {
  GPBDescriptor *descriptor = [OnNavEventChangeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnNavEventChangeResponse_FieldNumber_NavEventType];
  return GPBGetMessageInt32Field(message, field);
}

void SetOnNavEventChangeResponse_NavEventType_RawValue(OnNavEventChangeResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [OnNavEventChangeResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OnNavEventChangeResponse_FieldNumber_NavEventType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void OnNavEventChangeResponse_ClearChangeOneofOneOfCase(OnNavEventChangeResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - LocationResetRequest

@implementation LocationResetRequest


typedef struct LocationResetRequest__storage_ {
  uint32_t _has_storage_[1];
} LocationResetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocationResetRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LocationResetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LocationResetResponse

@implementation LocationResetResponse


typedef struct LocationResetResponse__storage_ {
  uint32_t _has_storage_[1];
} LocationResetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocationResetResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LocationResetResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Route

@implementation Route

@dynamic id_p;
@dynamic name;
@dynamic isActive;
@dynamic routePointsArray, routePointsArray_Count;

typedef struct Route__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  NSMutableArray *routePointsArray;
} Route__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Route__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Route__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = Route_FieldNumber_IsActive,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "routePointsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RoutePoint),
        .number = Route_FieldNumber_RoutePointsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Route__storage_, routePointsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Route class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Route__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RoutePoint

@implementation RoutePoint

@dynamic name;
@dynamic rotate;

typedef struct RoutePoint__storage_ {
  uint32_t _has_storage_[1];
  uint32_t rotate;
  NSString *name;
} RoutePoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RoutePoint_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RoutePoint__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rotate",
        .dataTypeSpecific.className = NULL,
        .number = RoutePoint_FieldNumber_Rotate,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RoutePoint__storage_, rotate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RoutePoint class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RoutePoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewRouteRequest

@implementation NewRouteRequest

@dynamic hasRoute, route;

typedef struct NewRouteRequest__storage_ {
  uint32_t _has_storage_[1];
  Route *route;
} NewRouteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "route",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = NewRouteRequest_FieldNumber_Route,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewRouteRequest__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewRouteRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewRouteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewRouteResponse

@implementation NewRouteResponse

@dynamic hasRoute, route;

typedef struct NewRouteResponse__storage_ {
  uint32_t _has_storage_[1];
  Route *route;
} NewRouteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "route",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = NewRouteResponse_FieldNumber_Route,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewRouteResponse__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewRouteResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewRouteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListRoutesRequest

@implementation ListRoutesRequest


typedef struct ListRoutesRequest__storage_ {
  uint32_t _has_storage_[1];
} ListRoutesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListRoutesRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ListRoutesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListRoutesResponse

@implementation ListRoutesResponse

@dynamic routesArray, routesArray_Count;

typedef struct ListRoutesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *routesArray;
} ListRoutesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "routesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = ListRoutesResponse_FieldNumber_RoutesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ListRoutesResponse__storage_, routesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListRoutesResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListRoutesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRouteRequest

@implementation GetRouteRequest

@dynamic id_p;

typedef struct GetRouteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} GetRouteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GetRouteRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRouteRequest__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRouteRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRouteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRouteResponse

@implementation GetRouteResponse

@dynamic hasRoute, route;

typedef struct GetRouteResponse__storage_ {
  uint32_t _has_storage_[1];
  Route *route;
} GetRouteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "route",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = GetRouteResponse_FieldNumber_Route,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRouteResponse__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRouteResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRouteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateRouteRequest

@implementation UpdateRouteRequest

@dynamic hasRoute, route;

typedef struct UpdateRouteRequest__storage_ {
  uint32_t _has_storage_[1];
  Route *route;
} UpdateRouteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "route",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = UpdateRouteRequest_FieldNumber_Route,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateRouteRequest__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateRouteRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateRouteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateRouteResponse

@implementation UpdateRouteResponse

@dynamic hasRoute, route;

typedef struct UpdateRouteResponse__storage_ {
  uint32_t _has_storage_[1];
  Route *route;
} UpdateRouteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "route",
        .dataTypeSpecific.className = GPBStringifySymbol(Route),
        .number = UpdateRouteResponse_FieldNumber_Route,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateRouteResponse__storage_, route),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateRouteResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateRouteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteRoutesRequest

@implementation DeleteRoutesRequest

@dynamic routesIdArray, routesIdArray_Count;

typedef struct DeleteRoutesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *routesIdArray;
} DeleteRoutesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "routesIdArray",
        .dataTypeSpecific.className = NULL,
        .number = DeleteRoutesRequest_FieldNumber_RoutesIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeleteRoutesRequest__storage_, routesIdArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteRoutesRequest class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteRoutesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteRoutesResponse

@implementation DeleteRoutesResponse


typedef struct DeleteRoutesResponse__storage_ {
  uint32_t _has_storage_[1];
} DeleteRoutesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteRoutesResponse class]
                                     rootClass:[NavRoot class]
                                          file:NavRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeleteRoutesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
