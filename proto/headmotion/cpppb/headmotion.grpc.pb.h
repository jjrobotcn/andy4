// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: headmotion.proto
#ifndef GRPC_headmotion_2eproto__INCLUDED
#define GRPC_headmotion_2eproto__INCLUDED

#include "headmotion.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class Channel;
class CompletionQueue;
class ServerCompletionQueue;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc_impl

namespace grpc {
class ServerContext;
}  // namespace grpc

namespace motionService {

class MotionService final {
 public:
  static constexpr char const* service_full_name() {
    return "motionService.MotionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 移动功能
    virtual ::grpc::Status MoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::motionService::MoveToResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::MoveToResponse>> AsyncMoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::MoveToResponse>>(AsyncMoveToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::MoveToResponse>> PrepareAsyncMoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::MoveToResponse>>(PrepareAsyncMoveToRaw(context, request, cq));
    }
    // 持续监听位置消息
    std::unique_ptr< ::grpc::ClientReaderInterface< ::motionService::PositioningDataResponse>> PositioningData(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::motionService::PositioningDataResponse>>(PositioningDataRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::motionService::PositioningDataResponse>> AsyncPositioningData(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::motionService::PositioningDataResponse>>(AsyncPositioningDataRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::motionService::PositioningDataResponse>> PrepareAsyncPositioningData(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::motionService::PositioningDataResponse>>(PrepareAsyncPositioningDataRaw(context, request, cq));
    }
    // 获取当前位置信息
    virtual ::grpc::Status GetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::motionService::GetPositionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::GetPositionResponse>> AsyncGetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::GetPositionResponse>>(AsyncGetPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::GetPositionResponse>> PrepareAsyncGetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::GetPositionResponse>>(PrepareAsyncGetPositionRaw(context, request, cq));
    }
    // 创建组
    virtual ::grpc::Status NewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::motionService::NewGroupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::NewGroupResponse>> AsyncNewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::NewGroupResponse>>(AsyncNewGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::NewGroupResponse>> PrepareAsyncNewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::NewGroupResponse>>(PrepareAsyncNewGroupRaw(context, request, cq));
    }
    // 获取组列表
    virtual ::grpc::Status ListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::motionService::ListGroupsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupsResponse>> AsyncListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupsResponse>>(AsyncListGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupsResponse>> PrepareAsyncListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupsResponse>>(PrepareAsyncListGroupsRaw(context, request, cq));
    }
    // 更新组信息
    virtual ::grpc::Status UpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::motionService::UpdateGroupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupResponse>> AsyncUpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupResponse>>(AsyncUpdateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupResponse>> PrepareAsyncUpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupResponse>>(PrepareAsyncUpdateGroupRaw(context, request, cq));
    }
    // 删除组列表
    virtual ::grpc::Status DeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::motionService::DeleteGroupsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::DeleteGroupsResponse>> AsyncDeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::DeleteGroupsResponse>>(AsyncDeleteGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::DeleteGroupsResponse>> PrepareAsyncDeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::DeleteGroupsResponse>>(PrepareAsyncDeleteGroupsRaw(context, request, cq));
    }
    // 获取组动作点列表
    virtual ::grpc::Status ListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::motionService::ListGroupTargetsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupTargetsResponse>> AsyncListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupTargetsResponse>>(AsyncListGroupTargetsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupTargetsResponse>> PrepareAsyncListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupTargetsResponse>>(PrepareAsyncListGroupTargetsRaw(context, request, cq));
    }
    // 更新组动作点列表
    virtual ::grpc::Status UpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::motionService::UpdateGroupTargetsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupTargetsResponse>> AsyncUpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupTargetsResponse>>(AsyncUpdateGroupTargetsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupTargetsResponse>> PrepareAsyncUpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupTargetsResponse>>(PrepareAsyncUpdateGroupTargetsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // 移动功能
      virtual void MoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::MoveToResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void MoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void MoveTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::MoveToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 持续监听位置消息
      virtual void PositioningData(::grpc::ClientContext* context, ::motionService::PositioningDataRequest* request, ::grpc::experimental::ClientReadReactor< ::motionService::PositioningDataResponse>* reactor) = 0;
      // 获取当前位置信息
      virtual void GetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::GetPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::GetPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 创建组
      virtual void NewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::NewGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NewGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::NewGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 获取组列表
      virtual void ListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 更新组信息
      virtual void UpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 删除组列表
      virtual void DeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::DeleteGroupsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::DeleteGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 获取组动作点列表
      virtual void ListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupTargetsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 更新组动作点列表
      virtual void UpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupTargetsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::MoveToResponse>* AsyncMoveToRaw(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::MoveToResponse>* PrepareAsyncMoveToRaw(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::motionService::PositioningDataResponse>* PositioningDataRaw(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::motionService::PositioningDataResponse>* AsyncPositioningDataRaw(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::motionService::PositioningDataResponse>* PrepareAsyncPositioningDataRaw(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::GetPositionResponse>* AsyncGetPositionRaw(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::GetPositionResponse>* PrepareAsyncGetPositionRaw(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::NewGroupResponse>* AsyncNewGroupRaw(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::NewGroupResponse>* PrepareAsyncNewGroupRaw(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupsResponse>* AsyncListGroupsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupsResponse>* PrepareAsyncListGroupsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupResponse>* AsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupResponse>* PrepareAsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::DeleteGroupsResponse>* AsyncDeleteGroupsRaw(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::DeleteGroupsResponse>* PrepareAsyncDeleteGroupsRaw(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupTargetsResponse>* AsyncListGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::ListGroupTargetsResponse>* PrepareAsyncListGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupTargetsResponse>* AsyncUpdateGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::motionService::UpdateGroupTargetsResponse>* PrepareAsyncUpdateGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status MoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::motionService::MoveToResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::MoveToResponse>> AsyncMoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::MoveToResponse>>(AsyncMoveToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::MoveToResponse>> PrepareAsyncMoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::MoveToResponse>>(PrepareAsyncMoveToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::motionService::PositioningDataResponse>> PositioningData(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::motionService::PositioningDataResponse>>(PositioningDataRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::motionService::PositioningDataResponse>> AsyncPositioningData(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::motionService::PositioningDataResponse>>(AsyncPositioningDataRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::motionService::PositioningDataResponse>> PrepareAsyncPositioningData(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::motionService::PositioningDataResponse>>(PrepareAsyncPositioningDataRaw(context, request, cq));
    }
    ::grpc::Status GetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::motionService::GetPositionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::GetPositionResponse>> AsyncGetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::GetPositionResponse>>(AsyncGetPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::GetPositionResponse>> PrepareAsyncGetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::GetPositionResponse>>(PrepareAsyncGetPositionRaw(context, request, cq));
    }
    ::grpc::Status NewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::motionService::NewGroupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::NewGroupResponse>> AsyncNewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::NewGroupResponse>>(AsyncNewGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::NewGroupResponse>> PrepareAsyncNewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::NewGroupResponse>>(PrepareAsyncNewGroupRaw(context, request, cq));
    }
    ::grpc::Status ListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::motionService::ListGroupsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupsResponse>> AsyncListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupsResponse>>(AsyncListGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupsResponse>> PrepareAsyncListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupsResponse>>(PrepareAsyncListGroupsRaw(context, request, cq));
    }
    ::grpc::Status UpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::motionService::UpdateGroupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupResponse>> AsyncUpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupResponse>>(AsyncUpdateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupResponse>> PrepareAsyncUpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupResponse>>(PrepareAsyncUpdateGroupRaw(context, request, cq));
    }
    ::grpc::Status DeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::motionService::DeleteGroupsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::DeleteGroupsResponse>> AsyncDeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::DeleteGroupsResponse>>(AsyncDeleteGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::DeleteGroupsResponse>> PrepareAsyncDeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::DeleteGroupsResponse>>(PrepareAsyncDeleteGroupsRaw(context, request, cq));
    }
    ::grpc::Status ListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::motionService::ListGroupTargetsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupTargetsResponse>> AsyncListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupTargetsResponse>>(AsyncListGroupTargetsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupTargetsResponse>> PrepareAsyncListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupTargetsResponse>>(PrepareAsyncListGroupTargetsRaw(context, request, cq));
    }
    ::grpc::Status UpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::motionService::UpdateGroupTargetsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupTargetsResponse>> AsyncUpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupTargetsResponse>>(AsyncUpdateGroupTargetsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupTargetsResponse>> PrepareAsyncUpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupTargetsResponse>>(PrepareAsyncUpdateGroupTargetsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void MoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response, std::function<void(::grpc::Status)>) override;
      void MoveTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::MoveToResponse* response, std::function<void(::grpc::Status)>) override;
      void MoveTo(::grpc::ClientContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void MoveTo(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::MoveToResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PositioningData(::grpc::ClientContext* context, ::motionService::PositioningDataRequest* request, ::grpc::experimental::ClientReadReactor< ::motionService::PositioningDataResponse>* reactor) override;
      void GetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::GetPositionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPosition(::grpc::ClientContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPosition(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::GetPositionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void NewGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::NewGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void NewGroup(::grpc::ClientContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NewGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::NewGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListGroups(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGroup(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::DeleteGroupsResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteGroups(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::DeleteGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupTargetsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListGroupTargets(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::ListGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupTargetsResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGroupTargets(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateGroupTargets(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::motionService::UpdateGroupTargetsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::motionService::MoveToResponse>* AsyncMoveToRaw(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::MoveToResponse>* PrepareAsyncMoveToRaw(::grpc::ClientContext* context, const ::motionService::MoveToRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::motionService::PositioningDataResponse>* PositioningDataRaw(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request) override;
    ::grpc::ClientAsyncReader< ::motionService::PositioningDataResponse>* AsyncPositioningDataRaw(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::motionService::PositioningDataResponse>* PrepareAsyncPositioningDataRaw(::grpc::ClientContext* context, const ::motionService::PositioningDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::GetPositionResponse>* AsyncGetPositionRaw(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::GetPositionResponse>* PrepareAsyncGetPositionRaw(::grpc::ClientContext* context, const ::motionService::GetPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::NewGroupResponse>* AsyncNewGroupRaw(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::NewGroupResponse>* PrepareAsyncNewGroupRaw(::grpc::ClientContext* context, const ::motionService::NewGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupsResponse>* AsyncListGroupsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupsResponse>* PrepareAsyncListGroupsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupResponse>* AsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupResponse>* PrepareAsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::DeleteGroupsResponse>* AsyncDeleteGroupsRaw(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::DeleteGroupsResponse>* PrepareAsyncDeleteGroupsRaw(::grpc::ClientContext* context, const ::motionService::DeleteGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupTargetsResponse>* AsyncListGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::ListGroupTargetsResponse>* PrepareAsyncListGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::ListGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupTargetsResponse>* AsyncUpdateGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::motionService::UpdateGroupTargetsResponse>* PrepareAsyncUpdateGroupTargetsRaw(::grpc::ClientContext* context, const ::motionService::UpdateGroupTargetsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_MoveTo_;
    const ::grpc::internal::RpcMethod rpcmethod_PositioningData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPosition_;
    const ::grpc::internal::RpcMethod rpcmethod_NewGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_ListGroups_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteGroups_;
    const ::grpc::internal::RpcMethod rpcmethod_ListGroupTargets_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateGroupTargets_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 移动功能
    virtual ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response);
    // 持续监听位置消息
    virtual ::grpc::Status PositioningData(::grpc::ServerContext* context, const ::motionService::PositioningDataRequest* request, ::grpc::ServerWriter< ::motionService::PositioningDataResponse>* writer);
    // 获取当前位置信息
    virtual ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response);
    // 创建组
    virtual ::grpc::Status NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response);
    // 获取组列表
    virtual ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response);
    // 更新组信息
    virtual ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response);
    // 删除组列表
    virtual ::grpc::Status DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response);
    // 获取组动作点列表
    virtual ::grpc::Status ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response);
    // 更新组动作点列表
    virtual ::grpc::Status UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MoveTo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTo(::grpc::ServerContext* context, ::motionService::MoveToRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::MoveToResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PositioningData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_PositioningData() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_PositioningData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositioningData(::grpc::ServerContext* context, const ::motionService::PositioningDataRequest* request, ::grpc::ServerWriter< ::motionService::PositioningDataResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositioningData(::grpc::ServerContext* context, ::motionService::PositioningDataRequest* request, ::grpc::ServerAsyncWriter< ::motionService::PositioningDataResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetPosition() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosition(::grpc::ServerContext* context, ::motionService::GetPositionRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::GetPositionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NewGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NewGroup() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_NewGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewGroup(::grpc::ServerContext* context, ::motionService::NewGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::NewGroupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListGroups() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroups(::grpc::ServerContext* context, ::motionService::ListGroupsRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::ListGroupsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGroup(::grpc::ServerContext* context, ::motionService::UpdateGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::UpdateGroupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteGroups() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DeleteGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGroups(::grpc::ServerContext* context, ::motionService::DeleteGroupsRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::DeleteGroupsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListGroupTargets() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ListGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroupTargets(::grpc::ServerContext* context, ::motionService::ListGroupTargetsRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::ListGroupTargetsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateGroupTargets() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_UpdateGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGroupTargets(::grpc::ServerContext* context, ::motionService::UpdateGroupTargetsRequest* request, ::grpc::ServerAsyncResponseWriter< ::motionService::UpdateGroupTargetsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_MoveTo<WithAsyncMethod_PositioningData<WithAsyncMethod_GetPosition<WithAsyncMethod_NewGroup<WithAsyncMethod_ListGroups<WithAsyncMethod_UpdateGroup<WithAsyncMethod_DeleteGroups<WithAsyncMethod_ListGroupTargets<WithAsyncMethod_UpdateGroupTargets<Service > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_MoveTo() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::MoveToRequest, ::motionService::MoveToResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::MoveToRequest* request,
                 ::motionService::MoveToResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->MoveTo(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_MoveTo(
        ::grpc::experimental::MessageAllocator< ::motionService::MoveToRequest, ::motionService::MoveToResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::MoveToRequest, ::motionService::MoveToResponse>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PositioningData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_PositioningData() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackServerStreamingHandler< ::motionService::PositioningDataRequest, ::motionService::PositioningDataResponse>(
          [this] { return this->PositioningData(); }));
    }
    ~ExperimentalWithCallbackMethod_PositioningData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositioningData(::grpc::ServerContext* context, const ::motionService::PositioningDataRequest* request, ::grpc::ServerWriter< ::motionService::PositioningDataResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::motionService::PositioningDataRequest, ::motionService::PositioningDataResponse>* PositioningData() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::motionService::PositioningDataRequest, ::motionService::PositioningDataResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetPosition() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::GetPositionRequest, ::motionService::GetPositionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::GetPositionRequest* request,
                 ::motionService::GetPositionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPosition(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPosition(
        ::grpc::experimental::MessageAllocator< ::motionService::GetPositionRequest, ::motionService::GetPositionResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::GetPositionRequest, ::motionService::GetPositionResponse>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NewGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_NewGroup() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::NewGroupRequest, ::motionService::NewGroupResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::NewGroupRequest* request,
                 ::motionService::NewGroupResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->NewGroup(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_NewGroup(
        ::grpc::experimental::MessageAllocator< ::motionService::NewGroupRequest, ::motionService::NewGroupResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::NewGroupRequest, ::motionService::NewGroupResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NewGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListGroups() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::ListGroupsRequest, ::motionService::ListGroupsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::ListGroupsRequest* request,
                 ::motionService::ListGroupsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListGroups(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListGroups(
        ::grpc::experimental::MessageAllocator< ::motionService::ListGroupsRequest, ::motionService::ListGroupsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::ListGroupsRequest, ::motionService::ListGroupsResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateGroup() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::UpdateGroupRequest, ::motionService::UpdateGroupResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::UpdateGroupRequest* request,
                 ::motionService::UpdateGroupResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateGroup(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateGroup(
        ::grpc::experimental::MessageAllocator< ::motionService::UpdateGroupRequest, ::motionService::UpdateGroupResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::UpdateGroupRequest, ::motionService::UpdateGroupResponse>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteGroups() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::DeleteGroupsRequest, ::motionService::DeleteGroupsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::DeleteGroupsRequest* request,
                 ::motionService::DeleteGroupsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteGroups(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteGroups(
        ::grpc::experimental::MessageAllocator< ::motionService::DeleteGroupsRequest, ::motionService::DeleteGroupsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::DeleteGroupsRequest, ::motionService::DeleteGroupsResponse>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListGroupTargets() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::ListGroupTargetsRequest, ::motionService::ListGroupTargetsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::ListGroupTargetsRequest* request,
                 ::motionService::ListGroupTargetsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListGroupTargets(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListGroupTargets(
        ::grpc::experimental::MessageAllocator< ::motionService::ListGroupTargetsRequest, ::motionService::ListGroupTargetsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::ListGroupTargetsRequest, ::motionService::ListGroupTargetsResponse>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateGroupTargets() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::motionService::UpdateGroupTargetsRequest, ::motionService::UpdateGroupTargetsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::motionService::UpdateGroupTargetsRequest* request,
                 ::motionService::UpdateGroupTargetsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateGroupTargets(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateGroupTargets(
        ::grpc::experimental::MessageAllocator< ::motionService::UpdateGroupTargetsRequest, ::motionService::UpdateGroupTargetsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::motionService::UpdateGroupTargetsRequest, ::motionService::UpdateGroupTargetsResponse>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_MoveTo<ExperimentalWithCallbackMethod_PositioningData<ExperimentalWithCallbackMethod_GetPosition<ExperimentalWithCallbackMethod_NewGroup<ExperimentalWithCallbackMethod_ListGroups<ExperimentalWithCallbackMethod_UpdateGroup<ExperimentalWithCallbackMethod_DeleteGroups<ExperimentalWithCallbackMethod_ListGroupTargets<ExperimentalWithCallbackMethod_UpdateGroupTargets<Service > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MoveTo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PositioningData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_PositioningData() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_PositioningData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositioningData(::grpc::ServerContext* context, const ::motionService::PositioningDataRequest* request, ::grpc::ServerWriter< ::motionService::PositioningDataResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetPosition() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NewGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NewGroup() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_NewGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListGroups() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteGroups() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DeleteGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListGroupTargets() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ListGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateGroupTargets() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_UpdateGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_MoveTo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PositioningData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_PositioningData() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_PositioningData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositioningData(::grpc::ServerContext* context, const ::motionService::PositioningDataRequest* request, ::grpc::ServerWriter< ::motionService::PositioningDataResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPositioningData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetPosition() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NewGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_NewGroup() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_NewGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListGroups() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteGroups() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DeleteGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGroups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListGroupTargets() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ListGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroupTargets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateGroupTargets() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_UpdateGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGroupTargets(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_MoveTo() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->MoveTo(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void MoveTo(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PositioningData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_PositioningData() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->PositioningData(); }));
    }
    ~ExperimentalWithRawCallbackMethod_PositioningData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PositioningData(::grpc::ServerContext* context, const ::motionService::PositioningDataRequest* request, ::grpc::ServerWriter< ::motionService::PositioningDataResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* PositioningData() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPosition() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPosition(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPosition(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NewGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_NewGroup() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->NewGroup(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_NewGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewGroup(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListGroups() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListGroups(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListGroups(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateGroup() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateGroup(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGroup(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteGroups() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteGroups(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteGroups(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListGroupTargets() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListGroupTargets(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListGroupTargets(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateGroupTargets() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateGroupTargets(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGroupTargets(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MoveTo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::MoveToRequest, ::motionService::MoveToResponse>(std::bind(&WithStreamedUnaryMethod_MoveTo<BaseClass>::StreamedMoveTo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::motionService::MoveToRequest* request, ::motionService::MoveToResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveTo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::MoveToRequest,::motionService::MoveToResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetPosition() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::GetPositionRequest, ::motionService::GetPositionResponse>(std::bind(&WithStreamedUnaryMethod_GetPosition<BaseClass>::StreamedGetPosition, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPosition(::grpc::ServerContext* context, const ::motionService::GetPositionRequest* request, ::motionService::GetPositionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::GetPositionRequest,::motionService::GetPositionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NewGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NewGroup() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::NewGroupRequest, ::motionService::NewGroupResponse>(std::bind(&WithStreamedUnaryMethod_NewGroup<BaseClass>::StreamedNewGroup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NewGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NewGroup(::grpc::ServerContext* context, const ::motionService::NewGroupRequest* request, ::motionService::NewGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNewGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::NewGroupRequest,::motionService::NewGroupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListGroups() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::ListGroupsRequest, ::motionService::ListGroupsResponse>(std::bind(&WithStreamedUnaryMethod_ListGroups<BaseClass>::StreamedListGroups, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::motionService::ListGroupsRequest* request, ::motionService::ListGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListGroups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::ListGroupsRequest,::motionService::ListGroupsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::UpdateGroupRequest, ::motionService::UpdateGroupResponse>(std::bind(&WithStreamedUnaryMethod_UpdateGroup<BaseClass>::StreamedUpdateGroup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::motionService::UpdateGroupRequest* request, ::motionService::UpdateGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::UpdateGroupRequest,::motionService::UpdateGroupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteGroups() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::DeleteGroupsRequest, ::motionService::DeleteGroupsResponse>(std::bind(&WithStreamedUnaryMethod_DeleteGroups<BaseClass>::StreamedDeleteGroups, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteGroups(::grpc::ServerContext* context, const ::motionService::DeleteGroupsRequest* request, ::motionService::DeleteGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteGroups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::DeleteGroupsRequest,::motionService::DeleteGroupsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListGroupTargets() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::ListGroupTargetsRequest, ::motionService::ListGroupTargetsResponse>(std::bind(&WithStreamedUnaryMethod_ListGroupTargets<BaseClass>::StreamedListGroupTargets, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListGroupTargets(::grpc::ServerContext* context, const ::motionService::ListGroupTargetsRequest* request, ::motionService::ListGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListGroupTargets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::ListGroupTargetsRequest,::motionService::ListGroupTargetsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateGroupTargets : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateGroupTargets() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::motionService::UpdateGroupTargetsRequest, ::motionService::UpdateGroupTargetsResponse>(std::bind(&WithStreamedUnaryMethod_UpdateGroupTargets<BaseClass>::StreamedUpdateGroupTargets, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateGroupTargets() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateGroupTargets(::grpc::ServerContext* context, const ::motionService::UpdateGroupTargetsRequest* request, ::motionService::UpdateGroupTargetsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateGroupTargets(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::motionService::UpdateGroupTargetsRequest,::motionService::UpdateGroupTargetsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_MoveTo<WithStreamedUnaryMethod_GetPosition<WithStreamedUnaryMethod_NewGroup<WithStreamedUnaryMethod_ListGroups<WithStreamedUnaryMethod_UpdateGroup<WithStreamedUnaryMethod_DeleteGroups<WithStreamedUnaryMethod_ListGroupTargets<WithStreamedUnaryMethod_UpdateGroupTargets<Service > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_PositioningData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_PositioningData() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler< ::motionService::PositioningDataRequest, ::motionService::PositioningDataResponse>(std::bind(&WithSplitStreamingMethod_PositioningData<BaseClass>::StreamedPositioningData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_PositioningData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PositioningData(::grpc::ServerContext* context, const ::motionService::PositioningDataRequest* request, ::grpc::ServerWriter< ::motionService::PositioningDataResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedPositioningData(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::motionService::PositioningDataRequest,::motionService::PositioningDataResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_PositioningData<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_MoveTo<WithSplitStreamingMethod_PositioningData<WithStreamedUnaryMethod_GetPosition<WithStreamedUnaryMethod_NewGroup<WithStreamedUnaryMethod_ListGroups<WithStreamedUnaryMethod_UpdateGroup<WithStreamedUnaryMethod_DeleteGroups<WithStreamedUnaryMethod_ListGroupTargets<WithStreamedUnaryMethod_UpdateGroupTargets<Service > > > > > > > > > StreamedService;
};

}  // namespace motionService


#endif  // GRPC_headmotion_2eproto__INCLUDED
