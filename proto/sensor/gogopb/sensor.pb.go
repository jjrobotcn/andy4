// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sensor.proto

package sensorService

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 检测方向
type DetectDirection int32

const (
	DetectDirection__ZERO_DIR   DetectDirection = 0
	DetectDirection_RELEASE_DIR DetectDirection = 1
	DetectDirection_LEFT        DetectDirection = 2
	DetectDirection_CENTER      DetectDirection = 3
	DetectDirection_RIGHT       DetectDirection = 4
)

var DetectDirection_name = map[int32]string{
	0: "_ZERO_DIR",
	1: "RELEASE_DIR",
	2: "LEFT",
	3: "CENTER",
	4: "RIGHT",
}

var DetectDirection_value = map[string]int32{
	"_ZERO_DIR":   0,
	"RELEASE_DIR": 1,
	"LEFT":        2,
	"CENTER":      3,
	"RIGHT":       4,
}

func (x DetectDirection) String() string {
	return proto.EnumName(DetectDirection_name, int32(x))
}

func (DetectDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{0}
}

// 检测距离
type DetectDistance int32

const (
	DetectDistance__ZERO_DIS   DetectDistance = 0
	DetectDistance_RELEASE_DIS DetectDistance = 1
	DetectDistance_CLOSE       DetectDistance = 2
	DetectDistance_MEDIUM      DetectDistance = 3
	DetectDistance_LONG        DetectDistance = 4
)

var DetectDistance_name = map[int32]string{
	0: "_ZERO_DIS",
	1: "RELEASE_DIS",
	2: "CLOSE",
	3: "MEDIUM",
	4: "LONG",
}

var DetectDistance_value = map[string]int32{
	"_ZERO_DIS":   0,
	"RELEASE_DIS": 1,
	"CLOSE":       2,
	"MEDIUM":      3,
	"LONG":        4,
}

func (x DetectDistance) String() string {
	return proto.EnumName(DetectDistance_name, int32(x))
}

func (DetectDistance) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{1}
}

type DataType int32

const (
	DataType_UNKNOWN DataType = 0
	DataType_OBS     DataType = 1
	DataType_AGV     DataType = 2
	DataType_TOUCH   DataType = 4
)

var DataType_name = map[int32]string{
	0: "UNKNOWN",
	1: "OBS",
	2: "AGV",
	4: "TOUCH",
}

var DataType_value = map[string]int32{
	"UNKNOWN": 0,
	"OBS":     1,
	"AGV":     2,
	"TOUCH":   4,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}

func (DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{2}
}

type GetDetectRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDetectRequest) Reset()         { *m = GetDetectRequest{} }
func (m *GetDetectRequest) String() string { return proto.CompactTextString(m) }
func (*GetDetectRequest) ProtoMessage()    {}
func (*GetDetectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{0}
}
func (m *GetDetectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDetectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDetectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDetectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDetectRequest.Merge(m, src)
}
func (m *GetDetectRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetDetectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDetectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetDetectRequest proto.InternalMessageInfo

// 传感器状态流数据
// stype: 数据类型
type GetDetectResponse struct {
	Direction            DetectDirection `protobuf:"varint,1,opt,name=direction,proto3,enum=sensorService.DetectDirection" json:"direction,omitempty"`
	Distance             DetectDistance  `protobuf:"varint,2,opt,name=distance,proto3,enum=sensorService.DetectDistance" json:"distance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetDetectResponse) Reset()         { *m = GetDetectResponse{} }
func (m *GetDetectResponse) String() string { return proto.CompactTextString(m) }
func (*GetDetectResponse) ProtoMessage()    {}
func (*GetDetectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{1}
}
func (m *GetDetectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDetectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDetectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDetectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDetectResponse.Merge(m, src)
}
func (m *GetDetectResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetDetectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDetectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetDetectResponse proto.InternalMessageInfo

func (m *GetDetectResponse) GetDirection() DetectDirection {
	if m != nil {
		return m.Direction
	}
	return DetectDirection__ZERO_DIR
}

func (m *GetDetectResponse) GetDistance() DetectDistance {
	if m != nil {
		return m.Distance
	}
	return DetectDistance__ZERO_DIS
}

type GetMotionInductionRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMotionInductionRequest) Reset()         { *m = GetMotionInductionRequest{} }
func (m *GetMotionInductionRequest) String() string { return proto.CompactTextString(m) }
func (*GetMotionInductionRequest) ProtoMessage()    {}
func (*GetMotionInductionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{2}
}
func (m *GetMotionInductionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMotionInductionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMotionInductionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMotionInductionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMotionInductionRequest.Merge(m, src)
}
func (m *GetMotionInductionRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetMotionInductionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMotionInductionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMotionInductionRequest proto.InternalMessageInfo

type GetMotionInductionResponse struct {
	Left                 bool     `protobuf:"varint,1,opt,name=left,proto3" json:"left,omitempty"`
	Right                bool     `protobuf:"varint,2,opt,name=right,proto3" json:"right,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMotionInductionResponse) Reset()         { *m = GetMotionInductionResponse{} }
func (m *GetMotionInductionResponse) String() string { return proto.CompactTextString(m) }
func (*GetMotionInductionResponse) ProtoMessage()    {}
func (*GetMotionInductionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{3}
}
func (m *GetMotionInductionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMotionInductionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMotionInductionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMotionInductionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMotionInductionResponse.Merge(m, src)
}
func (m *GetMotionInductionResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetMotionInductionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMotionInductionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMotionInductionResponse proto.InternalMessageInfo

func (m *GetMotionInductionResponse) GetLeft() bool {
	if m != nil {
		return m.Left
	}
	return false
}

func (m *GetMotionInductionResponse) GetRight() bool {
	if m != nil {
		return m.Right
	}
	return false
}

type GetTouchRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTouchRequest) Reset()         { *m = GetTouchRequest{} }
func (m *GetTouchRequest) String() string { return proto.CompactTextString(m) }
func (*GetTouchRequest) ProtoMessage()    {}
func (*GetTouchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{4}
}
func (m *GetTouchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTouchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTouchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTouchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTouchRequest.Merge(m, src)
}
func (m *GetTouchRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTouchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTouchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTouchRequest proto.InternalMessageInfo

// 触摸状态流数据
type GetTouchResponse struct {
	HandLeft             bool     `protobuf:"varint,1,opt,name=hand_left,json=handLeft,proto3" json:"hand_left,omitempty"`
	HandRight            bool     `protobuf:"varint,2,opt,name=hand_right,json=handRight,proto3" json:"hand_right,omitempty"`
	Head                 bool     `protobuf:"varint,3,opt,name=head,proto3" json:"head,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTouchResponse) Reset()         { *m = GetTouchResponse{} }
func (m *GetTouchResponse) String() string { return proto.CompactTextString(m) }
func (*GetTouchResponse) ProtoMessage()    {}
func (*GetTouchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{5}
}
func (m *GetTouchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTouchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTouchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTouchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTouchResponse.Merge(m, src)
}
func (m *GetTouchResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTouchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTouchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTouchResponse proto.InternalMessageInfo

func (m *GetTouchResponse) GetHandLeft() bool {
	if m != nil {
		return m.HandLeft
	}
	return false
}

func (m *GetTouchResponse) GetHandRight() bool {
	if m != nil {
		return m.HandRight
	}
	return false
}

func (m *GetTouchResponse) GetHead() bool {
	if m != nil {
		return m.Head
	}
	return false
}

// 避障传感器数据
// e.g. {"topRight: 30", "bottomMiddle": 10}
// *topRight等key非最终使用, 仅作为示例
type DataObs struct {
	Data                 map[string]int32 `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DataObs) Reset()         { *m = DataObs{} }
func (m *DataObs) String() string { return proto.CompactTextString(m) }
func (*DataObs) ProtoMessage()    {}
func (*DataObs) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{6}
}
func (m *DataObs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataObs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataObs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataObs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataObs.Merge(m, src)
}
func (m *DataObs) XXX_Size() int {
	return m.Size()
}
func (m *DataObs) XXX_DiscardUnknown() {
	xxx_messageInfo_DataObs.DiscardUnknown(m)
}

var xxx_messageInfo_DataObs proto.InternalMessageInfo

func (m *DataObs) GetData() map[string]int32 {
	if m != nil {
		return m.Data
	}
	return nil
}

// agv数据
// card_id: 感应卡点id
// data: 是否为激活状态列表
type DataAgv struct {
	CardId               string   `protobuf:"bytes,1,opt,name=card_id,json=cardId,proto3" json:"card_id,omitempty"`
	Data                 []bool   `protobuf:"varint,2,rep,packed,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DataAgv) Reset()         { *m = DataAgv{} }
func (m *DataAgv) String() string { return proto.CompactTextString(m) }
func (*DataAgv) ProtoMessage()    {}
func (*DataAgv) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{7}
}
func (m *DataAgv) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataAgv) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataAgv.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataAgv) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataAgv.Merge(m, src)
}
func (m *DataAgv) XXX_Size() int {
	return m.Size()
}
func (m *DataAgv) XXX_DiscardUnknown() {
	xxx_messageInfo_DataAgv.DiscardUnknown(m)
}

var xxx_messageInfo_DataAgv proto.InternalMessageInfo

func (m *DataAgv) GetCardId() string {
	if m != nil {
		return m.CardId
	}
	return ""
}

func (m *DataAgv) GetData() []bool {
	if m != nil {
		return m.Data
	}
	return nil
}

// 触摸数据
// e.g. {hand_left: false, hand_right: true, head: true}
type DataTouch struct {
	Touched              map[string]bool `protobuf:"bytes,1,rep,name=touched,proto3" json:"touched,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DataTouch) Reset()         { *m = DataTouch{} }
func (m *DataTouch) String() string { return proto.CompactTextString(m) }
func (*DataTouch) ProtoMessage()    {}
func (*DataTouch) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{8}
}
func (m *DataTouch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataTouch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataTouch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataTouch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataTouch.Merge(m, src)
}
func (m *DataTouch) XXX_Size() int {
	return m.Size()
}
func (m *DataTouch) XXX_DiscardUnknown() {
	xxx_messageInfo_DataTouch.DiscardUnknown(m)
}

var xxx_messageInfo_DataTouch proto.InternalMessageInfo

func (m *DataTouch) GetTouched() map[string]bool {
	if m != nil {
		return m.Touched
	}
	return nil
}

// 使用器数据更新请求
// dtype: 传感器更新数据类型
type UpdateReq struct {
	Dtype                DataType   `protobuf:"varint,1,opt,name=dtype,proto3,enum=sensorService.DataType" json:"dtype,omitempty"`
	Obs                  *DataObs   `protobuf:"bytes,2,opt,name=obs,proto3" json:"obs,omitempty"`
	Agv                  *DataAgv   `protobuf:"bytes,3,opt,name=agv,proto3" json:"agv,omitempty"`
	Touch                *DataTouch `protobuf:"bytes,5,opt,name=touch,proto3" json:"touch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *UpdateReq) Reset()         { *m = UpdateReq{} }
func (m *UpdateReq) String() string { return proto.CompactTextString(m) }
func (*UpdateReq) ProtoMessage()    {}
func (*UpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{9}
}
func (m *UpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateReq.Merge(m, src)
}
func (m *UpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateReq proto.InternalMessageInfo

func (m *UpdateReq) GetDtype() DataType {
	if m != nil {
		return m.Dtype
	}
	return DataType_UNKNOWN
}

func (m *UpdateReq) GetObs() *DataObs {
	if m != nil {
		return m.Obs
	}
	return nil
}

func (m *UpdateReq) GetAgv() *DataAgv {
	if m != nil {
		return m.Agv
	}
	return nil
}

func (m *UpdateReq) GetTouch() *DataTouch {
	if m != nil {
		return m.Touch
	}
	return nil
}

type RawRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawRequest) Reset()         { *m = RawRequest{} }
func (m *RawRequest) String() string { return proto.CompactTextString(m) }
func (*RawRequest) ProtoMessage()    {}
func (*RawRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{10}
}
func (m *RawRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawRequest.Merge(m, src)
}
func (m *RawRequest) XXX_Size() int {
	return m.Size()
}
func (m *RawRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RawRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RawRequest proto.InternalMessageInfo

// 原始数据返回
// dtype: 传感器更新数据类型
type RawResponse struct {
	Dtype                DataType   `protobuf:"varint,1,opt,name=dtype,proto3,enum=sensorService.DataType" json:"dtype,omitempty"`
	Obs                  *DataObs   `protobuf:"bytes,2,opt,name=obs,proto3" json:"obs,omitempty"`
	Agv                  *DataAgv   `protobuf:"bytes,3,opt,name=agv,proto3" json:"agv,omitempty"`
	Touch                *DataTouch `protobuf:"bytes,5,opt,name=touch,proto3" json:"touch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RawResponse) Reset()         { *m = RawResponse{} }
func (m *RawResponse) String() string { return proto.CompactTextString(m) }
func (*RawResponse) ProtoMessage()    {}
func (*RawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c749425f02243e2d, []int{11}
}
func (m *RawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawResponse.Merge(m, src)
}
func (m *RawResponse) XXX_Size() int {
	return m.Size()
}
func (m *RawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RawResponse proto.InternalMessageInfo

func (m *RawResponse) GetDtype() DataType {
	if m != nil {
		return m.Dtype
	}
	return DataType_UNKNOWN
}

func (m *RawResponse) GetObs() *DataObs {
	if m != nil {
		return m.Obs
	}
	return nil
}

func (m *RawResponse) GetAgv() *DataAgv {
	if m != nil {
		return m.Agv
	}
	return nil
}

func (m *RawResponse) GetTouch() *DataTouch {
	if m != nil {
		return m.Touch
	}
	return nil
}

func init() {
	proto.RegisterEnum("sensorService.DetectDirection", DetectDirection_name, DetectDirection_value)
	proto.RegisterEnum("sensorService.DetectDistance", DetectDistance_name, DetectDistance_value)
	proto.RegisterEnum("sensorService.DataType", DataType_name, DataType_value)
	proto.RegisterType((*GetDetectRequest)(nil), "sensorService.GetDetectRequest")
	proto.RegisterType((*GetDetectResponse)(nil), "sensorService.GetDetectResponse")
	proto.RegisterType((*GetMotionInductionRequest)(nil), "sensorService.GetMotionInductionRequest")
	proto.RegisterType((*GetMotionInductionResponse)(nil), "sensorService.GetMotionInductionResponse")
	proto.RegisterType((*GetTouchRequest)(nil), "sensorService.GetTouchRequest")
	proto.RegisterType((*GetTouchResponse)(nil), "sensorService.GetTouchResponse")
	proto.RegisterType((*DataObs)(nil), "sensorService.DataObs")
	proto.RegisterMapType((map[string]int32)(nil), "sensorService.DataObs.DataEntry")
	proto.RegisterType((*DataAgv)(nil), "sensorService.DataAgv")
	proto.RegisterType((*DataTouch)(nil), "sensorService.DataTouch")
	proto.RegisterMapType((map[string]bool)(nil), "sensorService.DataTouch.TouchedEntry")
	proto.RegisterType((*UpdateReq)(nil), "sensorService.UpdateReq")
	proto.RegisterType((*RawRequest)(nil), "sensorService.RawRequest")
	proto.RegisterType((*RawResponse)(nil), "sensorService.RawResponse")
}

func init() { proto.RegisterFile("sensor.proto", fileDescriptor_c749425f02243e2d) }

var fileDescriptor_c749425f02243e2d = []byte{
	// 723 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0xdf, 0x6e, 0x12, 0x4f,
	0x14, 0xee, 0xb0, 0x50, 0x76, 0x0f, 0xb4, 0xdd, 0x4e, 0x7e, 0xf9, 0x95, 0x6e, 0x53, 0x4a, 0x36,
	0x31, 0xc1, 0x26, 0x12, 0x83, 0x8d, 0x7f, 0x1a, 0x13, 0xa5, 0x65, 0x4b, 0x89, 0x94, 0x8d, 0x03,
	0x68, 0xe2, 0x0d, 0x59, 0xd8, 0x11, 0x88, 0x95, 0xa5, 0xec, 0x40, 0xe5, 0x0d, 0xbc, 0xf0, 0x99,
	0x8c, 0x97, 0x5e, 0xfa, 0x08, 0xa6, 0x89, 0xef, 0x61, 0x66, 0x66, 0x69, 0xb7, 0x74, 0x89, 0xde,
	0x7a, 0xc5, 0x9c, 0x73, 0xbe, 0xef, 0x9b, 0xef, 0x9c, 0x9d, 0x1c, 0x20, 0xed, 0xd3, 0xa1, 0xef,
	0x8d, 0x0b, 0xa3, 0xb1, 0xc7, 0x3c, 0xbc, 0x26, 0xa3, 0x06, 0x1d, 0x4f, 0x07, 0x5d, 0x6a, 0x62,
	0xd0, 0x2b, 0x94, 0x95, 0x29, 0xa3, 0x5d, 0x46, 0xe8, 0xc5, 0x84, 0xfa, 0xcc, 0xfc, 0x82, 0x60,
	0x33, 0x94, 0xf4, 0x47, 0xde, 0xd0, 0xa7, 0xf8, 0x39, 0x68, 0xee, 0x60, 0x4c, 0xbb, 0x6c, 0xe0,
	0x0d, 0x33, 0x28, 0x87, 0xf2, 0xeb, 0xc5, 0x6c, 0xe1, 0x96, 0x58, 0x41, 0x32, 0xca, 0x73, 0x14,
	0xb9, 0x21, 0xe0, 0x67, 0xa0, 0xba, 0x03, 0x9f, 0x39, 0xc3, 0x2e, 0xcd, 0xc4, 0x04, 0x79, 0x77,
	0x09, 0x59, 0x82, 0xc8, 0x35, 0xdc, 0xdc, 0x81, 0xed, 0x0a, 0x65, 0x67, 0x1e, 0xd7, 0xa9, 0x0e,
	0xdd, 0x89, 0xd4, 0x0e, 0xbc, 0x9e, 0x80, 0x11, 0x55, 0x0c, 0x3c, 0x63, 0x88, 0x9f, 0xd3, 0xf7,
	0x4c, 0xd8, 0x55, 0x89, 0x38, 0xe3, 0xff, 0x20, 0x31, 0x1e, 0xf4, 0xfa, 0x4c, 0xd8, 0x50, 0x89,
	0x0c, 0xcc, 0x4d, 0xd8, 0xa8, 0x50, 0xd6, 0xf4, 0x26, 0xdd, 0xfe, 0x5c, 0xba, 0x23, 0x46, 0x13,
	0xa4, 0x02, 0xc1, 0x1d, 0xd0, 0xfa, 0xce, 0xd0, 0x6d, 0x87, 0x54, 0x55, 0x9e, 0xa8, 0x71, 0xe5,
	0x5d, 0x00, 0x51, 0x0c, 0xcb, 0x0b, 0x38, 0xe1, 0x09, 0x6e, 0xa6, 0x4f, 0x1d, 0x37, 0xa3, 0x48,
	0x33, 0xfc, 0x6c, 0x7e, 0x82, 0x64, 0xd9, 0x61, 0x8e, 0xdd, 0xf1, 0xf1, 0x01, 0xc4, 0x5d, 0x87,
	0x39, 0x19, 0x94, 0x53, 0xf2, 0xa9, 0x62, 0x6e, 0x71, 0x3a, 0x12, 0x25, 0x7e, 0xad, 0x21, 0x1b,
	0xcf, 0x88, 0x40, 0x1b, 0x4f, 0x40, 0xbb, 0x4e, 0x61, 0x1d, 0x94, 0x0f, 0x74, 0x26, 0x7c, 0x69,
	0x84, 0x1f, 0x79, 0xb3, 0x53, 0xe7, 0x7c, 0x22, 0x67, 0x9e, 0x20, 0x32, 0x38, 0x8c, 0x3d, 0x45,
	0xe6, 0x63, 0x79, 0x73, 0xa9, 0x37, 0xc5, 0x5b, 0x90, 0xec, 0x3a, 0x63, 0xb7, 0x3d, 0x70, 0x03,
	0xea, 0x2a, 0x0f, 0xab, 0x2e, 0x77, 0x2c, 0x2c, 0xc5, 0x72, 0x0a, 0x77, 0xcc, 0xcf, 0xe6, 0x67,
	0x24, 0x6f, 0x14, 0x73, 0xc1, 0x2f, 0x20, 0xc9, 0xf8, 0x81, 0xba, 0x81, 0xef, 0x7b, 0x11, 0xbe,
	0x05, 0xb4, 0xd0, 0x94, 0x38, 0x69, 0x7e, 0xce, 0x32, 0x0e, 0x21, 0x1d, 0x2e, 0xfc, 0xa9, 0x05,
	0x35, 0xdc, 0xc2, 0x57, 0x04, 0x5a, 0x6b, 0xe4, 0x3a, 0x8c, 0x12, 0x7a, 0x81, 0x1f, 0x40, 0xc2,
	0x65, 0xb3, 0x11, 0x0d, 0xde, 0xe6, 0x56, 0x94, 0x91, 0xd9, 0x88, 0x12, 0x89, 0xc2, 0x79, 0x50,
	0xbc, 0x8e, 0x2f, 0x44, 0x53, 0xc5, 0xff, 0xa3, 0xa7, 0x4d, 0x38, 0x84, 0x23, 0x9d, 0xde, 0x54,
	0x7c, 0xb6, 0x68, 0x64, 0xa9, 0x37, 0x25, 0x1c, 0x82, 0x0b, 0x90, 0x10, 0x7d, 0x65, 0x12, 0x02,
	0x9b, 0x59, 0x36, 0x0b, 0x22, 0x61, 0x66, 0x1a, 0x80, 0x38, 0x97, 0xf3, 0xf7, 0xf6, 0x0d, 0x41,
	0x4a, 0x84, 0xc1, 0x5b, 0xfb, 0xf7, 0x1a, 0xda, 0x27, 0xb0, 0xb1, 0xb0, 0x03, 0xf0, 0x1a, 0x68,
	0xed, 0x77, 0x16, 0xb1, 0xdb, 0xe5, 0x2a, 0xd1, 0x57, 0xf0, 0x06, 0xa4, 0x88, 0x55, 0xb3, 0x4a,
	0x0d, 0x4b, 0x24, 0x10, 0x56, 0x21, 0x5e, 0xb3, 0x4e, 0x9a, 0x7a, 0x0c, 0x03, 0xac, 0x1e, 0x5b,
	0xf5, 0xa6, 0x45, 0x74, 0x05, 0x6b, 0x90, 0x20, 0xd5, 0xca, 0x69, 0x53, 0x8f, 0xef, 0xbf, 0x86,
	0xf5, 0xdb, 0xab, 0x21, 0x2c, 0xd9, 0x58, 0x94, 0x6c, 0xe8, 0x88, 0x93, 0x8f, 0x6b, 0x76, 0xc3,
	0x92, 0x9a, 0x67, 0x56, 0xb9, 0xda, 0x3a, 0xd3, 0x15, 0x71, 0x93, 0x5d, 0xaf, 0xe8, 0xf1, 0xfd,
	0x03, 0x50, 0xe7, 0xd3, 0xc3, 0x29, 0x48, 0xb6, 0xea, 0xaf, 0xea, 0xf6, 0xdb, 0xba, 0xbe, 0x82,
	0x93, 0xa0, 0xd8, 0x47, 0x5c, 0x22, 0x09, 0x4a, 0xa9, 0xf2, 0x46, 0x8f, 0x71, 0xad, 0xa6, 0xdd,
	0x3a, 0x3e, 0xd5, 0xe3, 0xc5, 0x5f, 0x31, 0x58, 0x6b, 0x84, 0xfb, 0xc7, 0x04, 0xb4, 0xeb, 0x3d,
	0x89, 0xf7, 0x16, 0x86, 0xb3, 0xb8, 0x56, 0x8d, 0xdc, 0x72, 0x80, 0xfc, 0xe2, 0xe6, 0xca, 0x43,
	0x84, 0x3f, 0x02, 0xbe, 0xbb, 0xd0, 0x70, 0xfe, 0x2e, 0x37, 0x7a, 0x21, 0x1a, 0xf7, 0xff, 0x02,
	0x19, 0xba, 0xce, 0x06, 0x75, 0xbe, 0xe4, 0x70, 0xf6, 0x2e, 0x35, 0xbc, 0x10, 0x8d, 0xbd, 0xa5,
	0xf5, 0x90, 0xe0, 0x4b, 0x50, 0x88, 0x73, 0x89, 0xb7, 0x17, 0xb0, 0x37, 0xef, 0xdc, 0x30, 0xa2,
	0x4a, 0x37, 0x0a, 0x47, 0xe9, 0xef, 0x57, 0x59, 0xf4, 0xe3, 0x2a, 0x8b, 0x7e, 0x5e, 0x65, 0x51,
	0x67, 0x55, 0xfc, 0x6d, 0x3d, 0xfa, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x25, 0x99, 0xda, 0xc6,
	0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SensorServiceClient is the client API for SensorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SensorServiceClient interface {
	// 获取感应数据流
	GetDetect(ctx context.Context, in *GetDetectRequest, opts ...grpc.CallOption) (SensorService_GetDetectClient, error)
	// 获取动态感应数据
	// 场景示例： 迎宾感应
	GetMotionInduction(ctx context.Context, in *GetMotionInductionRequest, opts ...grpc.CallOption) (SensorService_GetMotionInductionClient, error)
	// 获取触摸数据流
	GetTouch(ctx context.Context, in *GetTouchRequest, opts ...grpc.CallOption) (SensorService_GetTouchClient, error)
	// 获取传感器原始数据调试接口
	Raw(ctx context.Context, in *RawRequest, opts ...grpc.CallOption) (SensorService_RawClient, error)
}

type sensorServiceClient struct {
	cc *grpc.ClientConn
}

func NewSensorServiceClient(cc *grpc.ClientConn) SensorServiceClient {
	return &sensorServiceClient{cc}
}

func (c *sensorServiceClient) GetDetect(ctx context.Context, in *GetDetectRequest, opts ...grpc.CallOption) (SensorService_GetDetectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SensorService_serviceDesc.Streams[0], "/sensorService.SensorService/GetDetect", opts...)
	if err != nil {
		return nil, err
	}
	x := &sensorServiceGetDetectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SensorService_GetDetectClient interface {
	Recv() (*GetDetectResponse, error)
	grpc.ClientStream
}

type sensorServiceGetDetectClient struct {
	grpc.ClientStream
}

func (x *sensorServiceGetDetectClient) Recv() (*GetDetectResponse, error) {
	m := new(GetDetectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sensorServiceClient) GetMotionInduction(ctx context.Context, in *GetMotionInductionRequest, opts ...grpc.CallOption) (SensorService_GetMotionInductionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SensorService_serviceDesc.Streams[1], "/sensorService.SensorService/GetMotionInduction", opts...)
	if err != nil {
		return nil, err
	}
	x := &sensorServiceGetMotionInductionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SensorService_GetMotionInductionClient interface {
	Recv() (*GetMotionInductionResponse, error)
	grpc.ClientStream
}

type sensorServiceGetMotionInductionClient struct {
	grpc.ClientStream
}

func (x *sensorServiceGetMotionInductionClient) Recv() (*GetMotionInductionResponse, error) {
	m := new(GetMotionInductionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sensorServiceClient) GetTouch(ctx context.Context, in *GetTouchRequest, opts ...grpc.CallOption) (SensorService_GetTouchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SensorService_serviceDesc.Streams[2], "/sensorService.SensorService/GetTouch", opts...)
	if err != nil {
		return nil, err
	}
	x := &sensorServiceGetTouchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SensorService_GetTouchClient interface {
	Recv() (*GetTouchResponse, error)
	grpc.ClientStream
}

type sensorServiceGetTouchClient struct {
	grpc.ClientStream
}

func (x *sensorServiceGetTouchClient) Recv() (*GetTouchResponse, error) {
	m := new(GetTouchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sensorServiceClient) Raw(ctx context.Context, in *RawRequest, opts ...grpc.CallOption) (SensorService_RawClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SensorService_serviceDesc.Streams[3], "/sensorService.SensorService/Raw", opts...)
	if err != nil {
		return nil, err
	}
	x := &sensorServiceRawClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SensorService_RawClient interface {
	Recv() (*RawResponse, error)
	grpc.ClientStream
}

type sensorServiceRawClient struct {
	grpc.ClientStream
}

func (x *sensorServiceRawClient) Recv() (*RawResponse, error) {
	m := new(RawResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SensorServiceServer is the server API for SensorService service.
type SensorServiceServer interface {
	// 获取感应数据流
	GetDetect(*GetDetectRequest, SensorService_GetDetectServer) error
	// 获取动态感应数据
	// 场景示例： 迎宾感应
	GetMotionInduction(*GetMotionInductionRequest, SensorService_GetMotionInductionServer) error
	// 获取触摸数据流
	GetTouch(*GetTouchRequest, SensorService_GetTouchServer) error
	// 获取传感器原始数据调试接口
	Raw(*RawRequest, SensorService_RawServer) error
}

// UnimplementedSensorServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSensorServiceServer struct {
}

func (*UnimplementedSensorServiceServer) GetDetect(req *GetDetectRequest, srv SensorService_GetDetectServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDetect not implemented")
}
func (*UnimplementedSensorServiceServer) GetMotionInduction(req *GetMotionInductionRequest, srv SensorService_GetMotionInductionServer) error {
	return status.Errorf(codes.Unimplemented, "method GetMotionInduction not implemented")
}
func (*UnimplementedSensorServiceServer) GetTouch(req *GetTouchRequest, srv SensorService_GetTouchServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTouch not implemented")
}
func (*UnimplementedSensorServiceServer) Raw(req *RawRequest, srv SensorService_RawServer) error {
	return status.Errorf(codes.Unimplemented, "method Raw not implemented")
}

func RegisterSensorServiceServer(s *grpc.Server, srv SensorServiceServer) {
	s.RegisterService(&_SensorService_serviceDesc, srv)
}

func _SensorService_GetDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetDetectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SensorServiceServer).GetDetect(m, &sensorServiceGetDetectServer{stream})
}

type SensorService_GetDetectServer interface {
	Send(*GetDetectResponse) error
	grpc.ServerStream
}

type sensorServiceGetDetectServer struct {
	grpc.ServerStream
}

func (x *sensorServiceGetDetectServer) Send(m *GetDetectResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SensorService_GetMotionInduction_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetMotionInductionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SensorServiceServer).GetMotionInduction(m, &sensorServiceGetMotionInductionServer{stream})
}

type SensorService_GetMotionInductionServer interface {
	Send(*GetMotionInductionResponse) error
	grpc.ServerStream
}

type sensorServiceGetMotionInductionServer struct {
	grpc.ServerStream
}

func (x *sensorServiceGetMotionInductionServer) Send(m *GetMotionInductionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SensorService_GetTouch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTouchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SensorServiceServer).GetTouch(m, &sensorServiceGetTouchServer{stream})
}

type SensorService_GetTouchServer interface {
	Send(*GetTouchResponse) error
	grpc.ServerStream
}

type sensorServiceGetTouchServer struct {
	grpc.ServerStream
}

func (x *sensorServiceGetTouchServer) Send(m *GetTouchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SensorService_Raw_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RawRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SensorServiceServer).Raw(m, &sensorServiceRawServer{stream})
}

type SensorService_RawServer interface {
	Send(*RawResponse) error
	grpc.ServerStream
}

type sensorServiceRawServer struct {
	grpc.ServerStream
}

func (x *sensorServiceRawServer) Send(m *RawResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SensorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sensorService.SensorService",
	HandlerType: (*SensorServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetDetect",
			Handler:       _SensorService_GetDetect_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetMotionInduction",
			Handler:       _SensorService_GetMotionInduction_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetTouch",
			Handler:       _SensorService_GetTouch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Raw",
			Handler:       _SensorService_Raw_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "sensor.proto",
}

func (m *GetDetectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDetectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetDetectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDetectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Direction != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Direction))
	}
	if m.Distance != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Distance))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMotionInductionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMotionInductionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetMotionInductionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMotionInductionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Left {
		dAtA[i] = 0x8
		i++
		if m.Left {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Right {
		dAtA[i] = 0x10
		i++
		if m.Right {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTouchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTouchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetTouchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTouchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HandLeft {
		dAtA[i] = 0x8
		i++
		if m.HandLeft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HandRight {
		dAtA[i] = 0x10
		i++
		if m.HandRight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Head {
		dAtA[i] = 0x18
		i++
		if m.Head {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataObs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataObs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			mapSize := 1 + len(k) + sovSensor(uint64(len(k))) + 1 + sovSensor(uint64(v))
			i = encodeVarintSensor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSensor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintSensor(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataAgv) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataAgv) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CardId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSensor(dAtA, i, uint64(len(m.CardId)))
		i += copy(dAtA[i:], m.CardId)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSensor(dAtA, i, uint64(len(m.Data)))
		for _, b := range m.Data {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataTouch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataTouch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Touched) > 0 {
		for k, _ := range m.Touched {
			dAtA[i] = 0xa
			i++
			v := m.Touched[k]
			mapSize := 1 + len(k) + sovSensor(uint64(len(k))) + 1 + 1
			i = encodeVarintSensor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSensor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dtype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Dtype))
	}
	if m.Obs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Obs.Size()))
		n1, err1 := m.Obs.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.Agv != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Agv.Size()))
		n2, err2 := m.Agv.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.Touch != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Touch.Size()))
		n3, err3 := m.Touch.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RawRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dtype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Dtype))
	}
	if m.Obs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Obs.Size()))
		n4, err4 := m.Obs.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.Agv != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Agv.Size()))
		n5, err5 := m.Agv.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.Touch != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSensor(dAtA, i, uint64(m.Touch.Size()))
		n6, err6 := m.Touch.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSensor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetDetectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDetectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovSensor(uint64(m.Direction))
	}
	if m.Distance != 0 {
		n += 1 + sovSensor(uint64(m.Distance))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMotionInductionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMotionInductionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left {
		n += 2
	}
	if m.Right {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTouchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTouchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HandLeft {
		n += 2
	}
	if m.HandRight {
		n += 2
	}
	if m.Head {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataObs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSensor(uint64(len(k))) + 1 + sovSensor(uint64(v))
			n += mapEntrySize + 1 + sovSensor(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataAgv) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CardId)
	if l > 0 {
		n += 1 + l + sovSensor(uint64(l))
	}
	if len(m.Data) > 0 {
		n += 1 + sovSensor(uint64(len(m.Data))) + len(m.Data)*1
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataTouch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Touched) > 0 {
		for k, v := range m.Touched {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSensor(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovSensor(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dtype != 0 {
		n += 1 + sovSensor(uint64(m.Dtype))
	}
	if m.Obs != nil {
		l = m.Obs.Size()
		n += 1 + l + sovSensor(uint64(l))
	}
	if m.Agv != nil {
		l = m.Agv.Size()
		n += 1 + l + sovSensor(uint64(l))
	}
	if m.Touch != nil {
		l = m.Touch.Size()
		n += 1 + l + sovSensor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dtype != 0 {
		n += 1 + sovSensor(uint64(m.Dtype))
	}
	if m.Obs != nil {
		l = m.Obs.Size()
		n += 1 + l + sovSensor(uint64(l))
	}
	if m.Agv != nil {
		l = m.Agv.Size()
		n += 1 + l + sovSensor(uint64(l))
	}
	if m.Touch != nil {
		l = m.Touch.Size()
		n += 1 + l + sovSensor(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSensor(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSensor(x uint64) (n int) {
	return sovSensor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetDetectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDetectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDetectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDetectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDetectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDetectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= DetectDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			m.Distance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Distance |= DetectDistance(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMotionInductionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMotionInductionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMotionInductionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMotionInductionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMotionInductionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMotionInductionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Left = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Right = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTouchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTouchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTouchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTouchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTouchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTouchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandLeft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HandLeft = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandRight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HandRight = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Head = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataObs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataObs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataObs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSensor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSensor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSensor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSensor
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSensor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSensor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSensor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataAgv) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataAgv: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataAgv: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSensor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Data = append(m.Data, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSensor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSensor
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSensor
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.Data) == 0 {
					m.Data = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSensor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Data = append(m.Data, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataTouch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataTouch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataTouch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Touched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Touched == nil {
				m.Touched = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSensor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSensor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSensor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSensor
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSensor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSensor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSensor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Touched[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obs == nil {
				m.Obs = &DataObs{}
			}
			if err := m.Obs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Agv == nil {
				m.Agv = &DataAgv{}
			}
			if err := m.Agv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Touch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Touch == nil {
				m.Touch = &DataTouch{}
			}
			if err := m.Touch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			m.Dtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dtype |= DataType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Obs == nil {
				m.Obs = &DataObs{}
			}
			if err := m.Obs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Agv == nil {
				m.Agv = &DataAgv{}
			}
			if err := m.Agv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Touch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSensor
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSensor
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Touch == nil {
				m.Touch = &DataTouch{}
			}
			if err := m.Touch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSensor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSensor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSensor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSensor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSensor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSensor
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSensor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSensor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSensor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSensor
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSensor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSensor   = fmt.Errorf("proto: integer overflow")
)
