// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: group.proto
#ifndef GRPC_group_2eproto__INCLUDED
#define GRPC_group_2eproto__INCLUDED

#include "group.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace handsmotion {

class GroupManagement final {
 public:
  static constexpr char const* service_full_name() {
    return "handsmotion.GroupManagement";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 新建动作分组
    virtual ::grpc::Status NewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::handsmotion::NewMotionGroupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::NewMotionGroupResponse>> AsyncNewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::NewMotionGroupResponse>>(AsyncNewMotionGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::NewMotionGroupResponse>> PrepareAsyncNewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::NewMotionGroupResponse>>(PrepareAsyncNewMotionGroupRaw(context, request, cq));
    }
    // 获取所有动作分组列表
    virtual ::grpc::Status ListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::handsmotion::ListMotionGroupsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::ListMotionGroupsResponse>> AsyncListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::ListMotionGroupsResponse>>(AsyncListMotionGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::ListMotionGroupsResponse>> PrepareAsyncListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::ListMotionGroupsResponse>>(PrepareAsyncListMotionGroupsRaw(context, request, cq));
    }
    // 删除动作分组
    virtual ::grpc::Status DeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::handsmotion::DeleteMotionGroupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::DeleteMotionGroupResponse>> AsyncDeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::DeleteMotionGroupResponse>>(AsyncDeleteMotionGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::DeleteMotionGroupResponse>> PrepareAsyncDeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::DeleteMotionGroupResponse>>(PrepareAsyncDeleteMotionGroupRaw(context, request, cq));
    }
    // 获取动作分组
    virtual ::grpc::Status GetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::handsmotion::GetMotionGroupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::GetMotionGroupResponse>> AsyncGetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::GetMotionGroupResponse>>(AsyncGetMotionGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::GetMotionGroupResponse>> PrepareAsyncGetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::GetMotionGroupResponse>>(PrepareAsyncGetMotionGroupRaw(context, request, cq));
    }
    // 更新动作分组Meta
    virtual ::grpc::Status UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::handsmotion::UpdateMotionMetaResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionMetaResponse>> AsyncUpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionMetaResponse>>(AsyncUpdateMotionGroupMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionMetaResponse>> PrepareAsyncUpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionMetaResponse>>(PrepareAsyncUpdateMotionGroupMetaRaw(context, request, cq));
    }
    // 更新动作分组Scripts
    virtual ::grpc::Status UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::handsmotion::UpdateMotionScriptsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionScriptsResponse>> AsyncUpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionScriptsResponse>>(AsyncUpdateMotionGroupScriptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionScriptsResponse>> PrepareAsyncUpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionScriptsResponse>>(PrepareAsyncUpdateMotionGroupScriptsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // 新建动作分组
      virtual void NewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::NewMotionGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void NewMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::NewMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 获取所有动作分组列表
      virtual void ListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListMotionGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::ListMotionGroupsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListMotionGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::ListMotionGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 删除动作分组
      virtual void DeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::DeleteMotionGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::DeleteMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 获取动作分组
      virtual void GetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::GetMotionGroupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::GetMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 更新动作分组Meta
      virtual void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionMetaResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionMetaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 更新动作分组Scripts
      virtual void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionScriptsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionScriptsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::NewMotionGroupResponse>* AsyncNewMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::NewMotionGroupResponse>* PrepareAsyncNewMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::ListMotionGroupsResponse>* AsyncListMotionGroupsRaw(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::ListMotionGroupsResponse>* PrepareAsyncListMotionGroupsRaw(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::DeleteMotionGroupResponse>* AsyncDeleteMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::DeleteMotionGroupResponse>* PrepareAsyncDeleteMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::GetMotionGroupResponse>* AsyncGetMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::GetMotionGroupResponse>* PrepareAsyncGetMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionMetaResponse>* AsyncUpdateMotionGroupMetaRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionMetaResponse>* PrepareAsyncUpdateMotionGroupMetaRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionScriptsResponse>* AsyncUpdateMotionGroupScriptsRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::handsmotion::UpdateMotionScriptsResponse>* PrepareAsyncUpdateMotionGroupScriptsRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status NewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::handsmotion::NewMotionGroupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::NewMotionGroupResponse>> AsyncNewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::NewMotionGroupResponse>>(AsyncNewMotionGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::NewMotionGroupResponse>> PrepareAsyncNewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::NewMotionGroupResponse>>(PrepareAsyncNewMotionGroupRaw(context, request, cq));
    }
    ::grpc::Status ListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::handsmotion::ListMotionGroupsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::ListMotionGroupsResponse>> AsyncListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::ListMotionGroupsResponse>>(AsyncListMotionGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::ListMotionGroupsResponse>> PrepareAsyncListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::ListMotionGroupsResponse>>(PrepareAsyncListMotionGroupsRaw(context, request, cq));
    }
    ::grpc::Status DeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::handsmotion::DeleteMotionGroupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::DeleteMotionGroupResponse>> AsyncDeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::DeleteMotionGroupResponse>>(AsyncDeleteMotionGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::DeleteMotionGroupResponse>> PrepareAsyncDeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::DeleteMotionGroupResponse>>(PrepareAsyncDeleteMotionGroupRaw(context, request, cq));
    }
    ::grpc::Status GetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::handsmotion::GetMotionGroupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::GetMotionGroupResponse>> AsyncGetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::GetMotionGroupResponse>>(AsyncGetMotionGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::GetMotionGroupResponse>> PrepareAsyncGetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::GetMotionGroupResponse>>(PrepareAsyncGetMotionGroupRaw(context, request, cq));
    }
    ::grpc::Status UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::handsmotion::UpdateMotionMetaResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionMetaResponse>> AsyncUpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionMetaResponse>>(AsyncUpdateMotionGroupMetaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionMetaResponse>> PrepareAsyncUpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionMetaResponse>>(PrepareAsyncUpdateMotionGroupMetaRaw(context, request, cq));
    }
    ::grpc::Status UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::handsmotion::UpdateMotionScriptsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionScriptsResponse>> AsyncUpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionScriptsResponse>>(AsyncUpdateMotionGroupScriptsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionScriptsResponse>> PrepareAsyncUpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionScriptsResponse>>(PrepareAsyncUpdateMotionGroupScriptsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void NewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void NewMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::NewMotionGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void NewMotionGroup(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void NewMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::NewMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListMotionGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::ListMotionGroupsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListMotionGroups(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListMotionGroups(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::ListMotionGroupsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::DeleteMotionGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteMotionGroup(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::DeleteMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void GetMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::GetMotionGroupResponse* response, std::function<void(::grpc::Status)>) override;
      void GetMotionGroup(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMotionGroup(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::GetMotionGroupResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionMetaResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateMotionGroupMeta(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionMetaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionScriptsResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateMotionGroupScripts(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::handsmotion::UpdateMotionScriptsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::handsmotion::NewMotionGroupResponse>* AsyncNewMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::NewMotionGroupResponse>* PrepareAsyncNewMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::NewMotionGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::ListMotionGroupsResponse>* AsyncListMotionGroupsRaw(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::ListMotionGroupsResponse>* PrepareAsyncListMotionGroupsRaw(::grpc::ClientContext* context, const ::handsmotion::ListMotionGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::DeleteMotionGroupResponse>* AsyncDeleteMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::DeleteMotionGroupResponse>* PrepareAsyncDeleteMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::DeleteMotionGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::GetMotionGroupResponse>* AsyncGetMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::GetMotionGroupResponse>* PrepareAsyncGetMotionGroupRaw(::grpc::ClientContext* context, const ::handsmotion::GetMotionGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionMetaResponse>* AsyncUpdateMotionGroupMetaRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionMetaResponse>* PrepareAsyncUpdateMotionGroupMetaRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionMetaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionScriptsResponse>* AsyncUpdateMotionGroupScriptsRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::handsmotion::UpdateMotionScriptsResponse>* PrepareAsyncUpdateMotionGroupScriptsRaw(::grpc::ClientContext* context, const ::handsmotion::UpdateMotionScriptsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_NewMotionGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_ListMotionGroups_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteMotionGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMotionGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateMotionGroupMeta_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateMotionGroupScripts_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 新建动作分组
    virtual ::grpc::Status NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response);
    // 获取所有动作分组列表
    virtual ::grpc::Status ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response);
    // 删除动作分组
    virtual ::grpc::Status DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response);
    // 获取动作分组
    virtual ::grpc::Status GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response);
    // 更新动作分组Meta
    virtual ::grpc::Status UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response);
    // 更新动作分组Scripts
    virtual ::grpc::Status UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_NewMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_NewMotionGroup() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_NewMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewMotionGroup(::grpc::ServerContext* context, ::handsmotion::NewMotionGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::handsmotion::NewMotionGroupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListMotionGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListMotionGroups() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ListMotionGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMotionGroups(::grpc::ServerContext* context, ::handsmotion::ListMotionGroupsRequest* request, ::grpc::ServerAsyncResponseWriter< ::handsmotion::ListMotionGroupsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteMotionGroup() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMotionGroup(::grpc::ServerContext* context, ::handsmotion::DeleteMotionGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::handsmotion::DeleteMotionGroupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetMotionGroup() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMotionGroup(::grpc::ServerContext* context, ::handsmotion::GetMotionGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::handsmotion::GetMotionGroupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateMotionGroupMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateMotionGroupMeta() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_UpdateMotionGroupMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateMotionGroupMeta(::grpc::ServerContext* context, ::handsmotion::UpdateMotionMetaRequest* request, ::grpc::ServerAsyncResponseWriter< ::handsmotion::UpdateMotionMetaResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateMotionGroupScripts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UpdateMotionGroupScripts() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_UpdateMotionGroupScripts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateMotionGroupScripts(::grpc::ServerContext* context, ::handsmotion::UpdateMotionScriptsRequest* request, ::grpc::ServerAsyncResponseWriter< ::handsmotion::UpdateMotionScriptsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_NewMotionGroup<WithAsyncMethod_ListMotionGroups<WithAsyncMethod_DeleteMotionGroup<WithAsyncMethod_GetMotionGroup<WithAsyncMethod_UpdateMotionGroupMeta<WithAsyncMethod_UpdateMotionGroupScripts<Service > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NewMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_NewMotionGroup() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::handsmotion::NewMotionGroupRequest, ::handsmotion::NewMotionGroupResponse>(
          [this](::grpc::ServerContext* context,
                 const ::handsmotion::NewMotionGroupRequest* request,
                 ::handsmotion::NewMotionGroupResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->NewMotionGroup(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_NewMotionGroup(
        ::grpc::experimental::MessageAllocator< ::handsmotion::NewMotionGroupRequest, ::handsmotion::NewMotionGroupResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handsmotion::NewMotionGroupRequest, ::handsmotion::NewMotionGroupResponse>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NewMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListMotionGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListMotionGroups() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::handsmotion::ListMotionGroupsRequest, ::handsmotion::ListMotionGroupsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::handsmotion::ListMotionGroupsRequest* request,
                 ::handsmotion::ListMotionGroupsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListMotionGroups(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListMotionGroups(
        ::grpc::experimental::MessageAllocator< ::handsmotion::ListMotionGroupsRequest, ::handsmotion::ListMotionGroupsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handsmotion::ListMotionGroupsRequest, ::handsmotion::ListMotionGroupsResponse>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListMotionGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteMotionGroup() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::handsmotion::DeleteMotionGroupRequest, ::handsmotion::DeleteMotionGroupResponse>(
          [this](::grpc::ServerContext* context,
                 const ::handsmotion::DeleteMotionGroupRequest* request,
                 ::handsmotion::DeleteMotionGroupResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteMotionGroup(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteMotionGroup(
        ::grpc::experimental::MessageAllocator< ::handsmotion::DeleteMotionGroupRequest, ::handsmotion::DeleteMotionGroupResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handsmotion::DeleteMotionGroupRequest, ::handsmotion::DeleteMotionGroupResponse>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetMotionGroup() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::handsmotion::GetMotionGroupRequest, ::handsmotion::GetMotionGroupResponse>(
          [this](::grpc::ServerContext* context,
                 const ::handsmotion::GetMotionGroupRequest* request,
                 ::handsmotion::GetMotionGroupResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMotionGroup(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMotionGroup(
        ::grpc::experimental::MessageAllocator< ::handsmotion::GetMotionGroupRequest, ::handsmotion::GetMotionGroupResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handsmotion::GetMotionGroupRequest, ::handsmotion::GetMotionGroupResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateMotionGroupMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateMotionGroupMeta() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::handsmotion::UpdateMotionMetaRequest, ::handsmotion::UpdateMotionMetaResponse>(
          [this](::grpc::ServerContext* context,
                 const ::handsmotion::UpdateMotionMetaRequest* request,
                 ::handsmotion::UpdateMotionMetaResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateMotionGroupMeta(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateMotionGroupMeta(
        ::grpc::experimental::MessageAllocator< ::handsmotion::UpdateMotionMetaRequest, ::handsmotion::UpdateMotionMetaResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handsmotion::UpdateMotionMetaRequest, ::handsmotion::UpdateMotionMetaResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateMotionGroupMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateMotionGroupScripts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UpdateMotionGroupScripts() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::handsmotion::UpdateMotionScriptsRequest, ::handsmotion::UpdateMotionScriptsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::handsmotion::UpdateMotionScriptsRequest* request,
                 ::handsmotion::UpdateMotionScriptsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateMotionGroupScripts(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateMotionGroupScripts(
        ::grpc::experimental::MessageAllocator< ::handsmotion::UpdateMotionScriptsRequest, ::handsmotion::UpdateMotionScriptsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::handsmotion::UpdateMotionScriptsRequest, ::handsmotion::UpdateMotionScriptsResponse>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateMotionGroupScripts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_NewMotionGroup<ExperimentalWithCallbackMethod_ListMotionGroups<ExperimentalWithCallbackMethod_DeleteMotionGroup<ExperimentalWithCallbackMethod_GetMotionGroup<ExperimentalWithCallbackMethod_UpdateMotionGroupMeta<ExperimentalWithCallbackMethod_UpdateMotionGroupScripts<Service > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_NewMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_NewMotionGroup() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_NewMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListMotionGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListMotionGroups() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ListMotionGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteMotionGroup() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetMotionGroup() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateMotionGroupMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateMotionGroupMeta() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_UpdateMotionGroupMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateMotionGroupScripts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UpdateMotionGroupScripts() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_UpdateMotionGroupScripts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_NewMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_NewMotionGroup() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_NewMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNewMotionGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListMotionGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListMotionGroups() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ListMotionGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMotionGroups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteMotionGroup() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteMotionGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetMotionGroup() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMotionGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateMotionGroupMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateMotionGroupMeta() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_UpdateMotionGroupMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateMotionGroupMeta(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateMotionGroupScripts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UpdateMotionGroupScripts() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_UpdateMotionGroupScripts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateMotionGroupScripts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NewMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_NewMotionGroup() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->NewMotionGroup(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_NewMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void NewMotionGroup(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListMotionGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListMotionGroups() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListMotionGroups(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListMotionGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListMotionGroups(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteMotionGroup() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteMotionGroup(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteMotionGroup(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMotionGroup() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMotionGroup(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMotionGroup(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateMotionGroupMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateMotionGroupMeta() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateMotionGroupMeta(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateMotionGroupMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateMotionGroupScripts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateMotionGroupScripts() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateMotionGroupScripts(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateMotionGroupScripts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NewMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_NewMotionGroup() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::handsmotion::NewMotionGroupRequest, ::handsmotion::NewMotionGroupResponse>(std::bind(&WithStreamedUnaryMethod_NewMotionGroup<BaseClass>::StreamedNewMotionGroup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_NewMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NewMotionGroup(::grpc::ServerContext* context, const ::handsmotion::NewMotionGroupRequest* request, ::handsmotion::NewMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNewMotionGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handsmotion::NewMotionGroupRequest,::handsmotion::NewMotionGroupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListMotionGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListMotionGroups() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::handsmotion::ListMotionGroupsRequest, ::handsmotion::ListMotionGroupsResponse>(std::bind(&WithStreamedUnaryMethod_ListMotionGroups<BaseClass>::StreamedListMotionGroups, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListMotionGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListMotionGroups(::grpc::ServerContext* context, const ::handsmotion::ListMotionGroupsRequest* request, ::handsmotion::ListMotionGroupsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListMotionGroups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handsmotion::ListMotionGroupsRequest,::handsmotion::ListMotionGroupsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteMotionGroup() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::handsmotion::DeleteMotionGroupRequest, ::handsmotion::DeleteMotionGroupResponse>(std::bind(&WithStreamedUnaryMethod_DeleteMotionGroup<BaseClass>::StreamedDeleteMotionGroup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteMotionGroup(::grpc::ServerContext* context, const ::handsmotion::DeleteMotionGroupRequest* request, ::handsmotion::DeleteMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteMotionGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handsmotion::DeleteMotionGroupRequest,::handsmotion::DeleteMotionGroupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMotionGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetMotionGroup() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::handsmotion::GetMotionGroupRequest, ::handsmotion::GetMotionGroupResponse>(std::bind(&WithStreamedUnaryMethod_GetMotionGroup<BaseClass>::StreamedGetMotionGroup, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMotionGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMotionGroup(::grpc::ServerContext* context, const ::handsmotion::GetMotionGroupRequest* request, ::handsmotion::GetMotionGroupResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMotionGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handsmotion::GetMotionGroupRequest,::handsmotion::GetMotionGroupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateMotionGroupMeta : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateMotionGroupMeta() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::handsmotion::UpdateMotionMetaRequest, ::handsmotion::UpdateMotionMetaResponse>(std::bind(&WithStreamedUnaryMethod_UpdateMotionGroupMeta<BaseClass>::StreamedUpdateMotionGroupMeta, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateMotionGroupMeta() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateMotionGroupMeta(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionMetaRequest* request, ::handsmotion::UpdateMotionMetaResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateMotionGroupMeta(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handsmotion::UpdateMotionMetaRequest,::handsmotion::UpdateMotionMetaResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateMotionGroupScripts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UpdateMotionGroupScripts() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::handsmotion::UpdateMotionScriptsRequest, ::handsmotion::UpdateMotionScriptsResponse>(std::bind(&WithStreamedUnaryMethod_UpdateMotionGroupScripts<BaseClass>::StreamedUpdateMotionGroupScripts, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateMotionGroupScripts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateMotionGroupScripts(::grpc::ServerContext* context, const ::handsmotion::UpdateMotionScriptsRequest* request, ::handsmotion::UpdateMotionScriptsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateMotionGroupScripts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::handsmotion::UpdateMotionScriptsRequest,::handsmotion::UpdateMotionScriptsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_NewMotionGroup<WithStreamedUnaryMethod_ListMotionGroups<WithStreamedUnaryMethod_DeleteMotionGroup<WithStreamedUnaryMethod_GetMotionGroup<WithStreamedUnaryMethod_UpdateMotionGroupMeta<WithStreamedUnaryMethod_UpdateMotionGroupScripts<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_NewMotionGroup<WithStreamedUnaryMethod_ListMotionGroups<WithStreamedUnaryMethod_DeleteMotionGroup<WithStreamedUnaryMethod_GetMotionGroup<WithStreamedUnaryMethod_UpdateMotionGroupMeta<WithStreamedUnaryMethod_UpdateMotionGroupScripts<Service > > > > > > StreamedService;
};

}  // namespace handsmotion


#endif  // GRPC_group_2eproto__INCLUDED
