// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: speech.proto
#ifndef GRPC_speech_2eproto__INCLUDED
#define GRPC_speech_2eproto__INCLUDED

#include "speech.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class Channel;
class CompletionQueue;
class ServerCompletionQueue;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc_impl

namespace grpc {
class ServerContext;
}  // namespace grpc

namespace speechService {

class SpeechService final {
 public:
  static constexpr char const* service_full_name() {
    return "speechService.SpeechService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // ListenSpeechEvent方法为监听语音事件变更状态流, 具体类型参考: SpeechEvent
    // ListenSpeechEventRequest中可配置相关状态消息过滤,
    std::unique_ptr< ::grpc::ClientReaderInterface< ::speechService::ListenSpeechEventResponse>> ListenSpeechEvent(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::speechService::ListenSpeechEventResponse>>(ListenSpeechEventRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::speechService::ListenSpeechEventResponse>> AsyncListenSpeechEvent(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::speechService::ListenSpeechEventResponse>>(AsyncListenSpeechEventRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::speechService::ListenSpeechEventResponse>> PrepareAsyncListenSpeechEvent(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::speechService::ListenSpeechEventResponse>>(PrepareAsyncListenSpeechEventRaw(context, request, cq));
    }
    // TextToSpeech(TTS)方法实现文本输入语音合成自动音频输出
    virtual ::grpc::Status TextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::speechService::TextToSpeechResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::TextToSpeechResponse>> AsyncTextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::TextToSpeechResponse>>(AsyncTextToSpeechRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::TextToSpeechResponse>> PrepareAsyncTextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::TextToSpeechResponse>>(PrepareAsyncTextToSpeechRaw(context, request, cq));
    }
    // SpeechStop方法实现打断语音功能
    virtual ::grpc::Status SpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::speechService::SpeechStopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SpeechStopResponse>> AsyncSpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SpeechStopResponse>>(AsyncSpeechStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SpeechStopResponse>> PrepareAsyncSpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SpeechStopResponse>>(PrepareAsyncSpeechStopRaw(context, request, cq));
    }
    // 唤醒
    virtual ::grpc::Status WakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::speechService::WakeUpResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::WakeUpResponse>> AsyncWakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::WakeUpResponse>>(AsyncWakeUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::WakeUpResponse>> PrepareAsyncWakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::WakeUpResponse>>(PrepareAsyncWakeUpRaw(context, request, cq));
    }
    // 休眠
    virtual ::grpc::Status Hibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::speechService::HibernateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::HibernateResponse>> AsyncHibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::HibernateResponse>>(AsyncHibernateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::HibernateResponse>> PrepareAsyncHibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::HibernateResponse>>(PrepareAsyncHibernateRaw(context, request, cq));
    }
    // 设置语音音量
    // v2.1.0
    virtual ::grpc::Status SetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::speechService::SetVoiceVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetVoiceVolumeResponse>> AsyncSetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetVoiceVolumeResponse>>(AsyncSetVoiceVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetVoiceVolumeResponse>> PrepareAsyncSetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetVoiceVolumeResponse>>(PrepareAsyncSetVoiceVolumeRaw(context, request, cq));
    }
    // 查询语音音量
    // v2.1.0
    virtual ::grpc::Status GetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::speechService::GetVoiceVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::GetVoiceVolumeResponse>> AsyncGetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::GetVoiceVolumeResponse>>(AsyncGetVoiceVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::GetVoiceVolumeResponse>> PrepareAsyncGetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::GetVoiceVolumeResponse>>(PrepareAsyncGetVoiceVolumeRaw(context, request, cq));
    }
    // 配置参数(当前仅支持AIUI模块)
    // v2.1.0
    // AIUI模块参数配置参考: https://aiui.xfyun.cn/docs/access_docs (开发-评估板/量产板 => AIUI SDK => 参数配置)
    virtual ::grpc::Status SetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::speechService::SetParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetParamsResponse>> AsyncSetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetParamsResponse>>(AsyncSetParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetParamsResponse>> PrepareAsyncSetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetParamsResponse>>(PrepareAsyncSetParamsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // ListenSpeechEvent方法为监听语音事件变更状态流, 具体类型参考: SpeechEvent
      // ListenSpeechEventRequest中可配置相关状态消息过滤,
      virtual void ListenSpeechEvent(::grpc::ClientContext* context, ::speechService::ListenSpeechEventRequest* request, ::grpc::experimental::ClientReadReactor< ::speechService::ListenSpeechEventResponse>* reactor) = 0;
      // TextToSpeech(TTS)方法实现文本输入语音合成自动音频输出
      virtual void TextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TextToSpeech(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::TextToSpeechResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void TextToSpeech(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::TextToSpeechResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // SpeechStop方法实现打断语音功能
      virtual void SpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpeechStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SpeechStopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SpeechStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SpeechStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 唤醒
      virtual void WakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WakeUp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::WakeUpResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void WakeUp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::WakeUpResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 休眠
      virtual void Hibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Hibernate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::HibernateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Hibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Hibernate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::HibernateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 设置语音音量
      // v2.1.0
      virtual void SetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 查询语音音量
      // v2.1.0
      virtual void GetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::GetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::GetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 配置参数(当前仅支持AIUI模块)
      // v2.1.0
      // AIUI模块参数配置参考: https://aiui.xfyun.cn/docs/access_docs (开发-评估板/量产板 => AIUI SDK => 参数配置)
      virtual void SetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void SetParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientReaderInterface< ::speechService::ListenSpeechEventResponse>* ListenSpeechEventRaw(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::speechService::ListenSpeechEventResponse>* AsyncListenSpeechEventRaw(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::speechService::ListenSpeechEventResponse>* PrepareAsyncListenSpeechEventRaw(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::TextToSpeechResponse>* AsyncTextToSpeechRaw(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::TextToSpeechResponse>* PrepareAsyncTextToSpeechRaw(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SpeechStopResponse>* AsyncSpeechStopRaw(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SpeechStopResponse>* PrepareAsyncSpeechStopRaw(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::WakeUpResponse>* AsyncWakeUpRaw(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::WakeUpResponse>* PrepareAsyncWakeUpRaw(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::HibernateResponse>* AsyncHibernateRaw(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::HibernateResponse>* PrepareAsyncHibernateRaw(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetVoiceVolumeResponse>* AsyncSetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetVoiceVolumeResponse>* PrepareAsyncSetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::GetVoiceVolumeResponse>* AsyncGetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::GetVoiceVolumeResponse>* PrepareAsyncGetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetParamsResponse>* AsyncSetParamsRaw(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::speechService::SetParamsResponse>* PrepareAsyncSetParamsRaw(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReader< ::speechService::ListenSpeechEventResponse>> ListenSpeechEvent(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::speechService::ListenSpeechEventResponse>>(ListenSpeechEventRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::speechService::ListenSpeechEventResponse>> AsyncListenSpeechEvent(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::speechService::ListenSpeechEventResponse>>(AsyncListenSpeechEventRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::speechService::ListenSpeechEventResponse>> PrepareAsyncListenSpeechEvent(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::speechService::ListenSpeechEventResponse>>(PrepareAsyncListenSpeechEventRaw(context, request, cq));
    }
    ::grpc::Status TextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::speechService::TextToSpeechResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::TextToSpeechResponse>> AsyncTextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::TextToSpeechResponse>>(AsyncTextToSpeechRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::TextToSpeechResponse>> PrepareAsyncTextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::TextToSpeechResponse>>(PrepareAsyncTextToSpeechRaw(context, request, cq));
    }
    ::grpc::Status SpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::speechService::SpeechStopResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SpeechStopResponse>> AsyncSpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SpeechStopResponse>>(AsyncSpeechStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SpeechStopResponse>> PrepareAsyncSpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SpeechStopResponse>>(PrepareAsyncSpeechStopRaw(context, request, cq));
    }
    ::grpc::Status WakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::speechService::WakeUpResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::WakeUpResponse>> AsyncWakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::WakeUpResponse>>(AsyncWakeUpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::WakeUpResponse>> PrepareAsyncWakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::WakeUpResponse>>(PrepareAsyncWakeUpRaw(context, request, cq));
    }
    ::grpc::Status Hibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::speechService::HibernateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::HibernateResponse>> AsyncHibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::HibernateResponse>>(AsyncHibernateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::HibernateResponse>> PrepareAsyncHibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::HibernateResponse>>(PrepareAsyncHibernateRaw(context, request, cq));
    }
    ::grpc::Status SetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::speechService::SetVoiceVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetVoiceVolumeResponse>> AsyncSetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetVoiceVolumeResponse>>(AsyncSetVoiceVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetVoiceVolumeResponse>> PrepareAsyncSetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetVoiceVolumeResponse>>(PrepareAsyncSetVoiceVolumeRaw(context, request, cq));
    }
    ::grpc::Status GetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::speechService::GetVoiceVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::GetVoiceVolumeResponse>> AsyncGetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::GetVoiceVolumeResponse>>(AsyncGetVoiceVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::GetVoiceVolumeResponse>> PrepareAsyncGetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::GetVoiceVolumeResponse>>(PrepareAsyncGetVoiceVolumeRaw(context, request, cq));
    }
    ::grpc::Status SetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::speechService::SetParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetParamsResponse>> AsyncSetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetParamsResponse>>(AsyncSetParamsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetParamsResponse>> PrepareAsyncSetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::speechService::SetParamsResponse>>(PrepareAsyncSetParamsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ListenSpeechEvent(::grpc::ClientContext* context, ::speechService::ListenSpeechEventRequest* request, ::grpc::experimental::ClientReadReactor< ::speechService::ListenSpeechEventResponse>* reactor) override;
      void TextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response, std::function<void(::grpc::Status)>) override;
      void TextToSpeech(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::TextToSpeechResponse* response, std::function<void(::grpc::Status)>) override;
      void TextToSpeech(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void TextToSpeech(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::TextToSpeechResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response, std::function<void(::grpc::Status)>) override;
      void SpeechStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SpeechStopResponse* response, std::function<void(::grpc::Status)>) override;
      void SpeechStop(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SpeechStop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SpeechStopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void WakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response, std::function<void(::grpc::Status)>) override;
      void WakeUp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::WakeUpResponse* response, std::function<void(::grpc::Status)>) override;
      void WakeUp(::grpc::ClientContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void WakeUp(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::WakeUpResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Hibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response, std::function<void(::grpc::Status)>) override;
      void Hibernate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::HibernateResponse* response, std::function<void(::grpc::Status)>) override;
      void Hibernate(::grpc::ClientContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Hibernate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::HibernateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void SetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void SetVoiceVolume(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::GetVoiceVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVoiceVolume(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetVoiceVolume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::GetVoiceVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void SetParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void SetParams(::grpc::ClientContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void SetParams(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::speechService::SetParamsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientReader< ::speechService::ListenSpeechEventResponse>* ListenSpeechEventRaw(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request) override;
    ::grpc::ClientAsyncReader< ::speechService::ListenSpeechEventResponse>* AsyncListenSpeechEventRaw(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::speechService::ListenSpeechEventResponse>* PrepareAsyncListenSpeechEventRaw(::grpc::ClientContext* context, const ::speechService::ListenSpeechEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::TextToSpeechResponse>* AsyncTextToSpeechRaw(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::TextToSpeechResponse>* PrepareAsyncTextToSpeechRaw(::grpc::ClientContext* context, const ::speechService::TextToSpeechRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::SpeechStopResponse>* AsyncSpeechStopRaw(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::SpeechStopResponse>* PrepareAsyncSpeechStopRaw(::grpc::ClientContext* context, const ::speechService::SpeechStopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::WakeUpResponse>* AsyncWakeUpRaw(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::WakeUpResponse>* PrepareAsyncWakeUpRaw(::grpc::ClientContext* context, const ::speechService::WakeUpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::HibernateResponse>* AsyncHibernateRaw(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::HibernateResponse>* PrepareAsyncHibernateRaw(::grpc::ClientContext* context, const ::speechService::HibernateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::SetVoiceVolumeResponse>* AsyncSetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::SetVoiceVolumeResponse>* PrepareAsyncSetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::SetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::GetVoiceVolumeResponse>* AsyncGetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::GetVoiceVolumeResponse>* PrepareAsyncGetVoiceVolumeRaw(::grpc::ClientContext* context, const ::speechService::GetVoiceVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::SetParamsResponse>* AsyncSetParamsRaw(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::speechService::SetParamsResponse>* PrepareAsyncSetParamsRaw(::grpc::ClientContext* context, const ::speechService::SetParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ListenSpeechEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_TextToSpeech_;
    const ::grpc::internal::RpcMethod rpcmethod_SpeechStop_;
    const ::grpc::internal::RpcMethod rpcmethod_WakeUp_;
    const ::grpc::internal::RpcMethod rpcmethod_Hibernate_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVoiceVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVoiceVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_SetParams_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // ListenSpeechEvent方法为监听语音事件变更状态流, 具体类型参考: SpeechEvent
    // ListenSpeechEventRequest中可配置相关状态消息过滤,
    virtual ::grpc::Status ListenSpeechEvent(::grpc::ServerContext* context, const ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerWriter< ::speechService::ListenSpeechEventResponse>* writer);
    // TextToSpeech(TTS)方法实现文本输入语音合成自动音频输出
    virtual ::grpc::Status TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response);
    // SpeechStop方法实现打断语音功能
    virtual ::grpc::Status SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response);
    // 唤醒
    virtual ::grpc::Status WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response);
    // 休眠
    virtual ::grpc::Status Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response);
    // 设置语音音量
    // v2.1.0
    virtual ::grpc::Status SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response);
    // 查询语音音量
    // v2.1.0
    virtual ::grpc::Status GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response);
    // 配置参数(当前仅支持AIUI模块)
    // v2.1.0
    // AIUI模块参数配置参考: https://aiui.xfyun.cn/docs/access_docs (开发-评估板/量产板 => AIUI SDK => 参数配置)
    virtual ::grpc::Status SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListenSpeechEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListenSpeechEvent() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListenSpeechEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenSpeechEvent(::grpc::ServerContext* context, const ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerWriter< ::speechService::ListenSpeechEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListenSpeechEvent(::grpc::ServerContext* context, ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerAsyncWriter< ::speechService::ListenSpeechEventResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TextToSpeech : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TextToSpeech() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_TextToSpeech() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTextToSpeech(::grpc::ServerContext* context, ::speechService::TextToSpeechRequest* request, ::grpc::ServerAsyncResponseWriter< ::speechService::TextToSpeechResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpeechStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SpeechStop() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SpeechStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpeechStop(::grpc::ServerContext* context, ::speechService::SpeechStopRequest* request, ::grpc::ServerAsyncResponseWriter< ::speechService::SpeechStopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WakeUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WakeUp() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_WakeUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWakeUp(::grpc::ServerContext* context, ::speechService::WakeUpRequest* request, ::grpc::ServerAsyncResponseWriter< ::speechService::WakeUpResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Hibernate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Hibernate() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Hibernate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHibernate(::grpc::ServerContext* context, ::speechService::HibernateRequest* request, ::grpc::ServerAsyncResponseWriter< ::speechService::HibernateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetVoiceVolume() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVoiceVolume(::grpc::ServerContext* context, ::speechService::SetVoiceVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::speechService::SetVoiceVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVoiceVolume() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVoiceVolume(::grpc::ServerContext* context, ::speechService::GetVoiceVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::speechService::GetVoiceVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetParams() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SetParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetParams(::grpc::ServerContext* context, ::speechService::SetParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::speechService::SetParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListenSpeechEvent<WithAsyncMethod_TextToSpeech<WithAsyncMethod_SpeechStop<WithAsyncMethod_WakeUp<WithAsyncMethod_Hibernate<WithAsyncMethod_SetVoiceVolume<WithAsyncMethod_GetVoiceVolume<WithAsyncMethod_SetParams<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListenSpeechEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListenSpeechEvent() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackServerStreamingHandler< ::speechService::ListenSpeechEventRequest, ::speechService::ListenSpeechEventResponse>(
          [this] { return this->ListenSpeechEvent(); }));
    }
    ~ExperimentalWithCallbackMethod_ListenSpeechEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenSpeechEvent(::grpc::ServerContext* context, const ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerWriter< ::speechService::ListenSpeechEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::speechService::ListenSpeechEventRequest, ::speechService::ListenSpeechEventResponse>* ListenSpeechEvent() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::speechService::ListenSpeechEventRequest, ::speechService::ListenSpeechEventResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TextToSpeech : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_TextToSpeech() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::speechService::TextToSpeechRequest, ::speechService::TextToSpeechResponse>(
          [this](::grpc::ServerContext* context,
                 const ::speechService::TextToSpeechRequest* request,
                 ::speechService::TextToSpeechResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->TextToSpeech(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_TextToSpeech(
        ::grpc::experimental::MessageAllocator< ::speechService::TextToSpeechRequest, ::speechService::TextToSpeechResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::speechService::TextToSpeechRequest, ::speechService::TextToSpeechResponse>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TextToSpeech() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SpeechStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SpeechStop() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::speechService::SpeechStopRequest, ::speechService::SpeechStopResponse>(
          [this](::grpc::ServerContext* context,
                 const ::speechService::SpeechStopRequest* request,
                 ::speechService::SpeechStopResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SpeechStop(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SpeechStop(
        ::grpc::experimental::MessageAllocator< ::speechService::SpeechStopRequest, ::speechService::SpeechStopResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::speechService::SpeechStopRequest, ::speechService::SpeechStopResponse>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SpeechStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WakeUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_WakeUp() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::speechService::WakeUpRequest, ::speechService::WakeUpResponse>(
          [this](::grpc::ServerContext* context,
                 const ::speechService::WakeUpRequest* request,
                 ::speechService::WakeUpResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->WakeUp(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_WakeUp(
        ::grpc::experimental::MessageAllocator< ::speechService::WakeUpRequest, ::speechService::WakeUpResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::speechService::WakeUpRequest, ::speechService::WakeUpResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WakeUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Hibernate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Hibernate() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::speechService::HibernateRequest, ::speechService::HibernateResponse>(
          [this](::grpc::ServerContext* context,
                 const ::speechService::HibernateRequest* request,
                 ::speechService::HibernateResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Hibernate(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Hibernate(
        ::grpc::experimental::MessageAllocator< ::speechService::HibernateRequest, ::speechService::HibernateResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::speechService::HibernateRequest, ::speechService::HibernateResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Hibernate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetVoiceVolume() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::speechService::SetVoiceVolumeRequest, ::speechService::SetVoiceVolumeResponse>(
          [this](::grpc::ServerContext* context,
                 const ::speechService::SetVoiceVolumeRequest* request,
                 ::speechService::SetVoiceVolumeResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetVoiceVolume(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetVoiceVolume(
        ::grpc::experimental::MessageAllocator< ::speechService::SetVoiceVolumeRequest, ::speechService::SetVoiceVolumeResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::speechService::SetVoiceVolumeRequest, ::speechService::SetVoiceVolumeResponse>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_GetVoiceVolume() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::speechService::GetVoiceVolumeRequest, ::speechService::GetVoiceVolumeResponse>(
          [this](::grpc::ServerContext* context,
                 const ::speechService::GetVoiceVolumeRequest* request,
                 ::speechService::GetVoiceVolumeResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetVoiceVolume(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetVoiceVolume(
        ::grpc::experimental::MessageAllocator< ::speechService::GetVoiceVolumeRequest, ::speechService::GetVoiceVolumeResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::speechService::GetVoiceVolumeRequest, ::speechService::GetVoiceVolumeResponse>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_SetParams() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::speechService::SetParamsRequest, ::speechService::SetParamsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::speechService::SetParamsRequest* request,
                 ::speechService::SetParamsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->SetParams(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_SetParams(
        ::grpc::experimental::MessageAllocator< ::speechService::SetParamsRequest, ::speechService::SetParamsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::speechService::SetParamsRequest, ::speechService::SetParamsResponse>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_ListenSpeechEvent<ExperimentalWithCallbackMethod_TextToSpeech<ExperimentalWithCallbackMethod_SpeechStop<ExperimentalWithCallbackMethod_WakeUp<ExperimentalWithCallbackMethod_Hibernate<ExperimentalWithCallbackMethod_SetVoiceVolume<ExperimentalWithCallbackMethod_GetVoiceVolume<ExperimentalWithCallbackMethod_SetParams<Service > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ListenSpeechEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListenSpeechEvent() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListenSpeechEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenSpeechEvent(::grpc::ServerContext* context, const ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerWriter< ::speechService::ListenSpeechEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TextToSpeech : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TextToSpeech() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_TextToSpeech() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpeechStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SpeechStop() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SpeechStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WakeUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WakeUp() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_WakeUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Hibernate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Hibernate() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Hibernate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetVoiceVolume() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVoiceVolume() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetParams() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SetParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListenSpeechEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListenSpeechEvent() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ListenSpeechEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenSpeechEvent(::grpc::ServerContext* context, const ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerWriter< ::speechService::ListenSpeechEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListenSpeechEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TextToSpeech : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TextToSpeech() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_TextToSpeech() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTextToSpeech(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpeechStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SpeechStop() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SpeechStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpeechStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WakeUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WakeUp() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_WakeUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWakeUp(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Hibernate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Hibernate() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Hibernate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHibernate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetVoiceVolume() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVoiceVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetVoiceVolume() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVoiceVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_SetParams() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SetParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetParams(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListenSpeechEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListenSpeechEvent() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->ListenSpeechEvent(); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListenSpeechEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListenSpeechEvent(::grpc::ServerContext* context, const ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerWriter< ::speechService::ListenSpeechEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ListenSpeechEvent() {
      return new ::grpc::internal::UnimplementedWriteReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TextToSpeech : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_TextToSpeech() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->TextToSpeech(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_TextToSpeech() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void TextToSpeech(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SpeechStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SpeechStop() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SpeechStop(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SpeechStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SpeechStop(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WakeUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_WakeUp() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->WakeUp(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_WakeUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void WakeUp(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Hibernate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Hibernate() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Hibernate(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Hibernate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Hibernate(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetVoiceVolume() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetVoiceVolume(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetVoiceVolume(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_GetVoiceVolume() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetVoiceVolume(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetVoiceVolume(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_SetParams() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->SetParams(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_SetParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void SetParams(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TextToSpeech : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TextToSpeech() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::speechService::TextToSpeechRequest, ::speechService::TextToSpeechResponse>(std::bind(&WithStreamedUnaryMethod_TextToSpeech<BaseClass>::StreamedTextToSpeech, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TextToSpeech() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TextToSpeech(::grpc::ServerContext* context, const ::speechService::TextToSpeechRequest* request, ::speechService::TextToSpeechResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTextToSpeech(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::speechService::TextToSpeechRequest,::speechService::TextToSpeechResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpeechStop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SpeechStop() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::speechService::SpeechStopRequest, ::speechService::SpeechStopResponse>(std::bind(&WithStreamedUnaryMethod_SpeechStop<BaseClass>::StreamedSpeechStop, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SpeechStop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpeechStop(::grpc::ServerContext* context, const ::speechService::SpeechStopRequest* request, ::speechService::SpeechStopResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpeechStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::speechService::SpeechStopRequest,::speechService::SpeechStopResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WakeUp : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WakeUp() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::speechService::WakeUpRequest, ::speechService::WakeUpResponse>(std::bind(&WithStreamedUnaryMethod_WakeUp<BaseClass>::StreamedWakeUp, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WakeUp() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WakeUp(::grpc::ServerContext* context, const ::speechService::WakeUpRequest* request, ::speechService::WakeUpResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWakeUp(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::speechService::WakeUpRequest,::speechService::WakeUpResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Hibernate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Hibernate() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::speechService::HibernateRequest, ::speechService::HibernateResponse>(std::bind(&WithStreamedUnaryMethod_Hibernate<BaseClass>::StreamedHibernate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Hibernate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Hibernate(::grpc::ServerContext* context, const ::speechService::HibernateRequest* request, ::speechService::HibernateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHibernate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::speechService::HibernateRequest,::speechService::HibernateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetVoiceVolume() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::speechService::SetVoiceVolumeRequest, ::speechService::SetVoiceVolumeResponse>(std::bind(&WithStreamedUnaryMethod_SetVoiceVolume<BaseClass>::StreamedSetVoiceVolume, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVoiceVolume(::grpc::ServerContext* context, const ::speechService::SetVoiceVolumeRequest* request, ::speechService::SetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVoiceVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::speechService::SetVoiceVolumeRequest,::speechService::SetVoiceVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVoiceVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetVoiceVolume() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::speechService::GetVoiceVolumeRequest, ::speechService::GetVoiceVolumeResponse>(std::bind(&WithStreamedUnaryMethod_GetVoiceVolume<BaseClass>::StreamedGetVoiceVolume, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetVoiceVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVoiceVolume(::grpc::ServerContext* context, const ::speechService::GetVoiceVolumeRequest* request, ::speechService::GetVoiceVolumeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVoiceVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::speechService::GetVoiceVolumeRequest,::speechService::GetVoiceVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetParams : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_SetParams() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::speechService::SetParamsRequest, ::speechService::SetParamsResponse>(std::bind(&WithStreamedUnaryMethod_SetParams<BaseClass>::StreamedSetParams, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SetParams() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetParams(::grpc::ServerContext* context, const ::speechService::SetParamsRequest* request, ::speechService::SetParamsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetParams(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::speechService::SetParamsRequest,::speechService::SetParamsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_TextToSpeech<WithStreamedUnaryMethod_SpeechStop<WithStreamedUnaryMethod_WakeUp<WithStreamedUnaryMethod_Hibernate<WithStreamedUnaryMethod_SetVoiceVolume<WithStreamedUnaryMethod_GetVoiceVolume<WithStreamedUnaryMethod_SetParams<Service > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_ListenSpeechEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_ListenSpeechEvent() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler< ::speechService::ListenSpeechEventRequest, ::speechService::ListenSpeechEventResponse>(std::bind(&WithSplitStreamingMethod_ListenSpeechEvent<BaseClass>::StreamedListenSpeechEvent, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_ListenSpeechEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListenSpeechEvent(::grpc::ServerContext* context, const ::speechService::ListenSpeechEventRequest* request, ::grpc::ServerWriter< ::speechService::ListenSpeechEventResponse>* writer) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedListenSpeechEvent(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::speechService::ListenSpeechEventRequest,::speechService::ListenSpeechEventResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_ListenSpeechEvent<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_ListenSpeechEvent<WithStreamedUnaryMethod_TextToSpeech<WithStreamedUnaryMethod_SpeechStop<WithStreamedUnaryMethod_WakeUp<WithStreamedUnaryMethod_Hibernate<WithStreamedUnaryMethod_SetVoiceVolume<WithStreamedUnaryMethod_GetVoiceVolume<WithStreamedUnaryMethod_SetParams<Service > > > > > > > > StreamedService;
};

}  // namespace speechService


#endif  // GRPC_speech_2eproto__INCLUDED
