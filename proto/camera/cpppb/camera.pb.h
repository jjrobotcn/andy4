// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camera.proto

#ifndef PROTOBUF_INCLUDED_camera_2eproto
#define PROTOBUF_INCLUDED_camera_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_camera_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_camera_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_camera_2eproto();
namespace cameraService {
class DvrDateVideosFilter;
class DvrDateVideosFilterDefaultTypeInternal;
extern DvrDateVideosFilterDefaultTypeInternal _DvrDateVideosFilter_default_instance_;
class DvrListDateVideosRequest;
class DvrListDateVideosRequestDefaultTypeInternal;
extern DvrListDateVideosRequestDefaultTypeInternal _DvrListDateVideosRequest_default_instance_;
class DvrListDateVideosResponse;
class DvrListDateVideosResponseDefaultTypeInternal;
extern DvrListDateVideosResponseDefaultTypeInternal _DvrListDateVideosResponse_default_instance_;
class DvrListDatesRequest;
class DvrListDatesRequestDefaultTypeInternal;
extern DvrListDatesRequestDefaultTypeInternal _DvrListDatesRequest_default_instance_;
class DvrListDatesResponse;
class DvrListDatesResponseDefaultTypeInternal;
extern DvrListDatesResponseDefaultTypeInternal _DvrListDatesResponse_default_instance_;
class LiveH264StreamRequest;
class LiveH264StreamRequestDefaultTypeInternal;
extern LiveH264StreamRequestDefaultTypeInternal _LiveH264StreamRequest_default_instance_;
class LiveH264StreamResponse;
class LiveH264StreamResponseDefaultTypeInternal;
extern LiveH264StreamResponseDefaultTypeInternal _LiveH264StreamResponse_default_instance_;
}  // namespace cameraService
namespace google {
namespace protobuf {
template<> ::cameraService::DvrDateVideosFilter* Arena::CreateMaybeMessage<::cameraService::DvrDateVideosFilter>(Arena*);
template<> ::cameraService::DvrListDateVideosRequest* Arena::CreateMaybeMessage<::cameraService::DvrListDateVideosRequest>(Arena*);
template<> ::cameraService::DvrListDateVideosResponse* Arena::CreateMaybeMessage<::cameraService::DvrListDateVideosResponse>(Arena*);
template<> ::cameraService::DvrListDatesRequest* Arena::CreateMaybeMessage<::cameraService::DvrListDatesRequest>(Arena*);
template<> ::cameraService::DvrListDatesResponse* Arena::CreateMaybeMessage<::cameraService::DvrListDatesResponse>(Arena*);
template<> ::cameraService::LiveH264StreamRequest* Arena::CreateMaybeMessage<::cameraService::LiveH264StreamRequest>(Arena*);
template<> ::cameraService::LiveH264StreamResponse* Arena::CreateMaybeMessage<::cameraService::LiveH264StreamResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace cameraService {

// ===================================================================

class LiveH264StreamRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cameraService.LiveH264StreamRequest) */ {
 public:
  LiveH264StreamRequest();
  virtual ~LiveH264StreamRequest();

  LiveH264StreamRequest(const LiveH264StreamRequest& from);

  inline LiveH264StreamRequest& operator=(const LiveH264StreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiveH264StreamRequest(LiveH264StreamRequest&& from) noexcept
    : LiveH264StreamRequest() {
    *this = ::std::move(from);
  }

  inline LiveH264StreamRequest& operator=(LiveH264StreamRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LiveH264StreamRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiveH264StreamRequest* internal_default_instance() {
    return reinterpret_cast<const LiveH264StreamRequest*>(
               &_LiveH264StreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LiveH264StreamRequest* other);
  friend void swap(LiveH264StreamRequest& a, LiveH264StreamRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiveH264StreamRequest* New() const final {
    return CreateMaybeMessage<LiveH264StreamRequest>(nullptr);
  }

  LiveH264StreamRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LiveH264StreamRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LiveH264StreamRequest& from);
  void MergeFrom(const LiveH264StreamRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveH264StreamRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cameraService.LiveH264StreamRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_camera_2eproto;
};
// -------------------------------------------------------------------

class LiveH264StreamResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cameraService.LiveH264StreamResponse) */ {
 public:
  LiveH264StreamResponse();
  virtual ~LiveH264StreamResponse();

  LiveH264StreamResponse(const LiveH264StreamResponse& from);

  inline LiveH264StreamResponse& operator=(const LiveH264StreamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LiveH264StreamResponse(LiveH264StreamResponse&& from) noexcept
    : LiveH264StreamResponse() {
    *this = ::std::move(from);
  }

  inline LiveH264StreamResponse& operator=(LiveH264StreamResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LiveH264StreamResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiveH264StreamResponse* internal_default_instance() {
    return reinterpret_cast<const LiveH264StreamResponse*>(
               &_LiveH264StreamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LiveH264StreamResponse* other);
  friend void swap(LiveH264StreamResponse& a, LiveH264StreamResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LiveH264StreamResponse* New() const final {
    return CreateMaybeMessage<LiveH264StreamResponse>(nullptr);
  }

  LiveH264StreamResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LiveH264StreamResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LiveH264StreamResponse& from);
  void MergeFrom(const LiveH264StreamResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveH264StreamResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes frame = 1;
  void clear_frame();
  static const int kFrameFieldNumber = 1;
  const ::std::string& frame() const;
  void set_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_frame(::std::string&& value);
  #endif
  void set_frame(const char* value);
  void set_frame(const void* value, size_t size);
  ::std::string* mutable_frame();
  ::std::string* release_frame();
  void set_allocated_frame(::std::string* frame);

  // @@protoc_insertion_point(class_scope:cameraService.LiveH264StreamResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr frame_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_camera_2eproto;
};
// -------------------------------------------------------------------

class DvrListDatesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cameraService.DvrListDatesRequest) */ {
 public:
  DvrListDatesRequest();
  virtual ~DvrListDatesRequest();

  DvrListDatesRequest(const DvrListDatesRequest& from);

  inline DvrListDatesRequest& operator=(const DvrListDatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DvrListDatesRequest(DvrListDatesRequest&& from) noexcept
    : DvrListDatesRequest() {
    *this = ::std::move(from);
  }

  inline DvrListDatesRequest& operator=(DvrListDatesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DvrListDatesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DvrListDatesRequest* internal_default_instance() {
    return reinterpret_cast<const DvrListDatesRequest*>(
               &_DvrListDatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DvrListDatesRequest* other);
  friend void swap(DvrListDatesRequest& a, DvrListDatesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DvrListDatesRequest* New() const final {
    return CreateMaybeMessage<DvrListDatesRequest>(nullptr);
  }

  DvrListDatesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DvrListDatesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DvrListDatesRequest& from);
  void MergeFrom(const DvrListDatesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DvrListDatesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cameraService.DvrListDatesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_camera_2eproto;
};
// -------------------------------------------------------------------

class DvrListDatesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cameraService.DvrListDatesResponse) */ {
 public:
  DvrListDatesResponse();
  virtual ~DvrListDatesResponse();

  DvrListDatesResponse(const DvrListDatesResponse& from);

  inline DvrListDatesResponse& operator=(const DvrListDatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DvrListDatesResponse(DvrListDatesResponse&& from) noexcept
    : DvrListDatesResponse() {
    *this = ::std::move(from);
  }

  inline DvrListDatesResponse& operator=(DvrListDatesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DvrListDatesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DvrListDatesResponse* internal_default_instance() {
    return reinterpret_cast<const DvrListDatesResponse*>(
               &_DvrListDatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(DvrListDatesResponse* other);
  friend void swap(DvrListDatesResponse& a, DvrListDatesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DvrListDatesResponse* New() const final {
    return CreateMaybeMessage<DvrListDatesResponse>(nullptr);
  }

  DvrListDatesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DvrListDatesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DvrListDatesResponse& from);
  void MergeFrom(const DvrListDatesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DvrListDatesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string date_list = 1;
  int date_list_size() const;
  void clear_date_list();
  static const int kDateListFieldNumber = 1;
  const ::std::string& date_list(int index) const;
  ::std::string* mutable_date_list(int index);
  void set_date_list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_date_list(int index, ::std::string&& value);
  #endif
  void set_date_list(int index, const char* value);
  void set_date_list(int index, const char* value, size_t size);
  ::std::string* add_date_list();
  void add_date_list(const ::std::string& value);
  #if LANG_CXX11
  void add_date_list(::std::string&& value);
  #endif
  void add_date_list(const char* value);
  void add_date_list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& date_list() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_date_list();

  // @@protoc_insertion_point(class_scope:cameraService.DvrListDatesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> date_list_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_camera_2eproto;
};
// -------------------------------------------------------------------

class DvrDateVideosFilter final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cameraService.DvrDateVideosFilter) */ {
 public:
  DvrDateVideosFilter();
  virtual ~DvrDateVideosFilter();

  DvrDateVideosFilter(const DvrDateVideosFilter& from);

  inline DvrDateVideosFilter& operator=(const DvrDateVideosFilter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DvrDateVideosFilter(DvrDateVideosFilter&& from) noexcept
    : DvrDateVideosFilter() {
    *this = ::std::move(from);
  }

  inline DvrDateVideosFilter& operator=(DvrDateVideosFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DvrDateVideosFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DvrDateVideosFilter* internal_default_instance() {
    return reinterpret_cast<const DvrDateVideosFilter*>(
               &_DvrDateVideosFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(DvrDateVideosFilter* other);
  friend void swap(DvrDateVideosFilter& a, DvrDateVideosFilter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DvrDateVideosFilter* New() const final {
    return CreateMaybeMessage<DvrDateVideosFilter>(nullptr);
  }

  DvrDateVideosFilter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DvrDateVideosFilter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DvrDateVideosFilter& from);
  void MergeFrom(const DvrDateVideosFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DvrDateVideosFilter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hour_start = 1;
  void clear_hour_start();
  static const int kHourStartFieldNumber = 1;
  const ::std::string& hour_start() const;
  void set_hour_start(const ::std::string& value);
  #if LANG_CXX11
  void set_hour_start(::std::string&& value);
  #endif
  void set_hour_start(const char* value);
  void set_hour_start(const char* value, size_t size);
  ::std::string* mutable_hour_start();
  ::std::string* release_hour_start();
  void set_allocated_hour_start(::std::string* hour_start);

  // string hour_end = 2;
  void clear_hour_end();
  static const int kHourEndFieldNumber = 2;
  const ::std::string& hour_end() const;
  void set_hour_end(const ::std::string& value);
  #if LANG_CXX11
  void set_hour_end(::std::string&& value);
  #endif
  void set_hour_end(const char* value);
  void set_hour_end(const char* value, size_t size);
  ::std::string* mutable_hour_end();
  ::std::string* release_hour_end();
  void set_allocated_hour_end(::std::string* hour_end);

  // uint32 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cameraService.DvrDateVideosFilter)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hour_start_;
  ::google::protobuf::internal::ArenaStringPtr hour_end_;
  ::google::protobuf::uint32 limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_camera_2eproto;
};
// -------------------------------------------------------------------

class DvrListDateVideosRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cameraService.DvrListDateVideosRequest) */ {
 public:
  DvrListDateVideosRequest();
  virtual ~DvrListDateVideosRequest();

  DvrListDateVideosRequest(const DvrListDateVideosRequest& from);

  inline DvrListDateVideosRequest& operator=(const DvrListDateVideosRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DvrListDateVideosRequest(DvrListDateVideosRequest&& from) noexcept
    : DvrListDateVideosRequest() {
    *this = ::std::move(from);
  }

  inline DvrListDateVideosRequest& operator=(DvrListDateVideosRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DvrListDateVideosRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DvrListDateVideosRequest* internal_default_instance() {
    return reinterpret_cast<const DvrListDateVideosRequest*>(
               &_DvrListDateVideosRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DvrListDateVideosRequest* other);
  friend void swap(DvrListDateVideosRequest& a, DvrListDateVideosRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DvrListDateVideosRequest* New() const final {
    return CreateMaybeMessage<DvrListDateVideosRequest>(nullptr);
  }

  DvrListDateVideosRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DvrListDateVideosRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DvrListDateVideosRequest& from);
  void MergeFrom(const DvrListDateVideosRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DvrListDateVideosRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string date = 1;
  void clear_date();
  static const int kDateFieldNumber = 1;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // .cameraService.DvrDateVideosFilter filter = 2;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 2;
  const ::cameraService::DvrDateVideosFilter& filter() const;
  ::cameraService::DvrDateVideosFilter* release_filter();
  ::cameraService::DvrDateVideosFilter* mutable_filter();
  void set_allocated_filter(::cameraService::DvrDateVideosFilter* filter);

  // @@protoc_insertion_point(class_scope:cameraService.DvrListDateVideosRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::cameraService::DvrDateVideosFilter* filter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_camera_2eproto;
};
// -------------------------------------------------------------------

class DvrListDateVideosResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cameraService.DvrListDateVideosResponse) */ {
 public:
  DvrListDateVideosResponse();
  virtual ~DvrListDateVideosResponse();

  DvrListDateVideosResponse(const DvrListDateVideosResponse& from);

  inline DvrListDateVideosResponse& operator=(const DvrListDateVideosResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DvrListDateVideosResponse(DvrListDateVideosResponse&& from) noexcept
    : DvrListDateVideosResponse() {
    *this = ::std::move(from);
  }

  inline DvrListDateVideosResponse& operator=(DvrListDateVideosResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DvrListDateVideosResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DvrListDateVideosResponse* internal_default_instance() {
    return reinterpret_cast<const DvrListDateVideosResponse*>(
               &_DvrListDateVideosResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DvrListDateVideosResponse* other);
  friend void swap(DvrListDateVideosResponse& a, DvrListDateVideosResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DvrListDateVideosResponse* New() const final {
    return CreateMaybeMessage<DvrListDateVideosResponse>(nullptr);
  }

  DvrListDateVideosResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DvrListDateVideosResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DvrListDateVideosResponse& from);
  void MergeFrom(const DvrListDateVideosResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DvrListDateVideosResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string videos_static = 1;
  int videos_static_size() const;
  void clear_videos_static();
  static const int kVideosStaticFieldNumber = 1;
  const ::std::string& videos_static(int index) const;
  ::std::string* mutable_videos_static(int index);
  void set_videos_static(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_videos_static(int index, ::std::string&& value);
  #endif
  void set_videos_static(int index, const char* value);
  void set_videos_static(int index, const char* value, size_t size);
  ::std::string* add_videos_static();
  void add_videos_static(const ::std::string& value);
  #if LANG_CXX11
  void add_videos_static(::std::string&& value);
  #endif
  void add_videos_static(const char* value);
  void add_videos_static(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& videos_static() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_videos_static();

  // @@protoc_insertion_point(class_scope:cameraService.DvrListDateVideosResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> videos_static_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_camera_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LiveH264StreamRequest

// -------------------------------------------------------------------

// LiveH264StreamResponse

// bytes frame = 1;
inline void LiveH264StreamResponse::clear_frame() {
  frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LiveH264StreamResponse::frame() const {
  // @@protoc_insertion_point(field_get:cameraService.LiveH264StreamResponse.frame)
  return frame_.GetNoArena();
}
inline void LiveH264StreamResponse::set_frame(const ::std::string& value) {
  
  frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cameraService.LiveH264StreamResponse.frame)
}
#if LANG_CXX11
inline void LiveH264StreamResponse::set_frame(::std::string&& value) {
  
  frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cameraService.LiveH264StreamResponse.frame)
}
#endif
inline void LiveH264StreamResponse::set_frame(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cameraService.LiveH264StreamResponse.frame)
}
inline void LiveH264StreamResponse::set_frame(const void* value, size_t size) {
  
  frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cameraService.LiveH264StreamResponse.frame)
}
inline ::std::string* LiveH264StreamResponse::mutable_frame() {
  
  // @@protoc_insertion_point(field_mutable:cameraService.LiveH264StreamResponse.frame)
  return frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LiveH264StreamResponse::release_frame() {
  // @@protoc_insertion_point(field_release:cameraService.LiveH264StreamResponse.frame)
  
  return frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LiveH264StreamResponse::set_allocated_frame(::std::string* frame) {
  if (frame != nullptr) {
    
  } else {
    
  }
  frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), frame);
  // @@protoc_insertion_point(field_set_allocated:cameraService.LiveH264StreamResponse.frame)
}

// -------------------------------------------------------------------

// DvrListDatesRequest

// -------------------------------------------------------------------

// DvrListDatesResponse

// repeated string date_list = 1;
inline int DvrListDatesResponse::date_list_size() const {
  return date_list_.size();
}
inline void DvrListDatesResponse::clear_date_list() {
  date_list_.Clear();
}
inline const ::std::string& DvrListDatesResponse::date_list(int index) const {
  // @@protoc_insertion_point(field_get:cameraService.DvrListDatesResponse.date_list)
  return date_list_.Get(index);
}
inline ::std::string* DvrListDatesResponse::mutable_date_list(int index) {
  // @@protoc_insertion_point(field_mutable:cameraService.DvrListDatesResponse.date_list)
  return date_list_.Mutable(index);
}
inline void DvrListDatesResponse::set_date_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cameraService.DvrListDatesResponse.date_list)
  date_list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DvrListDatesResponse::set_date_list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cameraService.DvrListDatesResponse.date_list)
  date_list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DvrListDatesResponse::set_date_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  date_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cameraService.DvrListDatesResponse.date_list)
}
inline void DvrListDatesResponse::set_date_list(int index, const char* value, size_t size) {
  date_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cameraService.DvrListDatesResponse.date_list)
}
inline ::std::string* DvrListDatesResponse::add_date_list() {
  // @@protoc_insertion_point(field_add_mutable:cameraService.DvrListDatesResponse.date_list)
  return date_list_.Add();
}
inline void DvrListDatesResponse::add_date_list(const ::std::string& value) {
  date_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cameraService.DvrListDatesResponse.date_list)
}
#if LANG_CXX11
inline void DvrListDatesResponse::add_date_list(::std::string&& value) {
  date_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cameraService.DvrListDatesResponse.date_list)
}
#endif
inline void DvrListDatesResponse::add_date_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  date_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cameraService.DvrListDatesResponse.date_list)
}
inline void DvrListDatesResponse::add_date_list(const char* value, size_t size) {
  date_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cameraService.DvrListDatesResponse.date_list)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DvrListDatesResponse::date_list() const {
  // @@protoc_insertion_point(field_list:cameraService.DvrListDatesResponse.date_list)
  return date_list_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DvrListDatesResponse::mutable_date_list() {
  // @@protoc_insertion_point(field_mutable_list:cameraService.DvrListDatesResponse.date_list)
  return &date_list_;
}

// -------------------------------------------------------------------

// DvrDateVideosFilter

// string hour_start = 1;
inline void DvrDateVideosFilter::clear_hour_start() {
  hour_start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DvrDateVideosFilter::hour_start() const {
  // @@protoc_insertion_point(field_get:cameraService.DvrDateVideosFilter.hour_start)
  return hour_start_.GetNoArena();
}
inline void DvrDateVideosFilter::set_hour_start(const ::std::string& value) {
  
  hour_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cameraService.DvrDateVideosFilter.hour_start)
}
#if LANG_CXX11
inline void DvrDateVideosFilter::set_hour_start(::std::string&& value) {
  
  hour_start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cameraService.DvrDateVideosFilter.hour_start)
}
#endif
inline void DvrDateVideosFilter::set_hour_start(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hour_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cameraService.DvrDateVideosFilter.hour_start)
}
inline void DvrDateVideosFilter::set_hour_start(const char* value, size_t size) {
  
  hour_start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cameraService.DvrDateVideosFilter.hour_start)
}
inline ::std::string* DvrDateVideosFilter::mutable_hour_start() {
  
  // @@protoc_insertion_point(field_mutable:cameraService.DvrDateVideosFilter.hour_start)
  return hour_start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DvrDateVideosFilter::release_hour_start() {
  // @@protoc_insertion_point(field_release:cameraService.DvrDateVideosFilter.hour_start)
  
  return hour_start_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DvrDateVideosFilter::set_allocated_hour_start(::std::string* hour_start) {
  if (hour_start != nullptr) {
    
  } else {
    
  }
  hour_start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hour_start);
  // @@protoc_insertion_point(field_set_allocated:cameraService.DvrDateVideosFilter.hour_start)
}

// string hour_end = 2;
inline void DvrDateVideosFilter::clear_hour_end() {
  hour_end_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DvrDateVideosFilter::hour_end() const {
  // @@protoc_insertion_point(field_get:cameraService.DvrDateVideosFilter.hour_end)
  return hour_end_.GetNoArena();
}
inline void DvrDateVideosFilter::set_hour_end(const ::std::string& value) {
  
  hour_end_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cameraService.DvrDateVideosFilter.hour_end)
}
#if LANG_CXX11
inline void DvrDateVideosFilter::set_hour_end(::std::string&& value) {
  
  hour_end_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cameraService.DvrDateVideosFilter.hour_end)
}
#endif
inline void DvrDateVideosFilter::set_hour_end(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hour_end_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cameraService.DvrDateVideosFilter.hour_end)
}
inline void DvrDateVideosFilter::set_hour_end(const char* value, size_t size) {
  
  hour_end_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cameraService.DvrDateVideosFilter.hour_end)
}
inline ::std::string* DvrDateVideosFilter::mutable_hour_end() {
  
  // @@protoc_insertion_point(field_mutable:cameraService.DvrDateVideosFilter.hour_end)
  return hour_end_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DvrDateVideosFilter::release_hour_end() {
  // @@protoc_insertion_point(field_release:cameraService.DvrDateVideosFilter.hour_end)
  
  return hour_end_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DvrDateVideosFilter::set_allocated_hour_end(::std::string* hour_end) {
  if (hour_end != nullptr) {
    
  } else {
    
  }
  hour_end_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hour_end);
  // @@protoc_insertion_point(field_set_allocated:cameraService.DvrDateVideosFilter.hour_end)
}

// uint32 limit = 3;
inline void DvrDateVideosFilter::clear_limit() {
  limit_ = 0u;
}
inline ::google::protobuf::uint32 DvrDateVideosFilter::limit() const {
  // @@protoc_insertion_point(field_get:cameraService.DvrDateVideosFilter.limit)
  return limit_;
}
inline void DvrDateVideosFilter::set_limit(::google::protobuf::uint32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:cameraService.DvrDateVideosFilter.limit)
}

// -------------------------------------------------------------------

// DvrListDateVideosRequest

// string date = 1;
inline void DvrListDateVideosRequest::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DvrListDateVideosRequest::date() const {
  // @@protoc_insertion_point(field_get:cameraService.DvrListDateVideosRequest.date)
  return date_.GetNoArena();
}
inline void DvrListDateVideosRequest::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cameraService.DvrListDateVideosRequest.date)
}
#if LANG_CXX11
inline void DvrListDateVideosRequest::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cameraService.DvrListDateVideosRequest.date)
}
#endif
inline void DvrListDateVideosRequest::set_date(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cameraService.DvrListDateVideosRequest.date)
}
inline void DvrListDateVideosRequest::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cameraService.DvrListDateVideosRequest.date)
}
inline ::std::string* DvrListDateVideosRequest::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:cameraService.DvrListDateVideosRequest.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DvrListDateVideosRequest::release_date() {
  // @@protoc_insertion_point(field_release:cameraService.DvrListDateVideosRequest.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DvrListDateVideosRequest::set_allocated_date(::std::string* date) {
  if (date != nullptr) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:cameraService.DvrListDateVideosRequest.date)
}

// .cameraService.DvrDateVideosFilter filter = 2;
inline bool DvrListDateVideosRequest::has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline void DvrListDateVideosRequest::clear_filter() {
  if (GetArenaNoVirtual() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::cameraService::DvrDateVideosFilter& DvrListDateVideosRequest::filter() const {
  const ::cameraService::DvrDateVideosFilter* p = filter_;
  // @@protoc_insertion_point(field_get:cameraService.DvrListDateVideosRequest.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::cameraService::DvrDateVideosFilter*>(
      &::cameraService::_DvrDateVideosFilter_default_instance_);
}
inline ::cameraService::DvrDateVideosFilter* DvrListDateVideosRequest::release_filter() {
  // @@protoc_insertion_point(field_release:cameraService.DvrListDateVideosRequest.filter)
  
  ::cameraService::DvrDateVideosFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::cameraService::DvrDateVideosFilter* DvrListDateVideosRequest::mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::cameraService::DvrDateVideosFilter>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:cameraService.DvrListDateVideosRequest.filter)
  return filter_;
}
inline void DvrListDateVideosRequest::set_allocated_filter(::cameraService::DvrDateVideosFilter* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:cameraService.DvrListDateVideosRequest.filter)
}

// -------------------------------------------------------------------

// DvrListDateVideosResponse

// repeated string videos_static = 1;
inline int DvrListDateVideosResponse::videos_static_size() const {
  return videos_static_.size();
}
inline void DvrListDateVideosResponse::clear_videos_static() {
  videos_static_.Clear();
}
inline const ::std::string& DvrListDateVideosResponse::videos_static(int index) const {
  // @@protoc_insertion_point(field_get:cameraService.DvrListDateVideosResponse.videos_static)
  return videos_static_.Get(index);
}
inline ::std::string* DvrListDateVideosResponse::mutable_videos_static(int index) {
  // @@protoc_insertion_point(field_mutable:cameraService.DvrListDateVideosResponse.videos_static)
  return videos_static_.Mutable(index);
}
inline void DvrListDateVideosResponse::set_videos_static(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cameraService.DvrListDateVideosResponse.videos_static)
  videos_static_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DvrListDateVideosResponse::set_videos_static(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:cameraService.DvrListDateVideosResponse.videos_static)
  videos_static_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DvrListDateVideosResponse::set_videos_static(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  videos_static_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cameraService.DvrListDateVideosResponse.videos_static)
}
inline void DvrListDateVideosResponse::set_videos_static(int index, const char* value, size_t size) {
  videos_static_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cameraService.DvrListDateVideosResponse.videos_static)
}
inline ::std::string* DvrListDateVideosResponse::add_videos_static() {
  // @@protoc_insertion_point(field_add_mutable:cameraService.DvrListDateVideosResponse.videos_static)
  return videos_static_.Add();
}
inline void DvrListDateVideosResponse::add_videos_static(const ::std::string& value) {
  videos_static_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cameraService.DvrListDateVideosResponse.videos_static)
}
#if LANG_CXX11
inline void DvrListDateVideosResponse::add_videos_static(::std::string&& value) {
  videos_static_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:cameraService.DvrListDateVideosResponse.videos_static)
}
#endif
inline void DvrListDateVideosResponse::add_videos_static(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  videos_static_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cameraService.DvrListDateVideosResponse.videos_static)
}
inline void DvrListDateVideosResponse::add_videos_static(const char* value, size_t size) {
  videos_static_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cameraService.DvrListDateVideosResponse.videos_static)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DvrListDateVideosResponse::videos_static() const {
  // @@protoc_insertion_point(field_list:cameraService.DvrListDateVideosResponse.videos_static)
  return videos_static_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DvrListDateVideosResponse::mutable_videos_static() {
  // @@protoc_insertion_point(field_mutable_list:cameraService.DvrListDateVideosResponse.videos_static)
  return &videos_static_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cameraService

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_camera_2eproto
