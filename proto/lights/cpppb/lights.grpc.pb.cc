// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: lights.proto

#include "lights.pb.h"
#include "lights.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace lightsService {

static const char* LightsService_method_names[] = {
  "/lightsService.LightsService/PreviewLight",
  "/lightsService.LightsService/PlayLight",
  "/lightsService.LightsService/StopLight",
  "/lightsService.LightsService/ListLights",
  "/lightsService.LightsService/NewLight",
  "/lightsService.LightsService/UpdateLight",
  "/lightsService.LightsService/DeleteLights",
  "/lightsService.LightsService/State",
  "/lightsService.LightsService/Switch",
};

std::unique_ptr< LightsService::Stub> LightsService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< LightsService::Stub> stub(new LightsService::Stub(channel));
  return stub;
}

LightsService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_PreviewLight_(LightsService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_PlayLight_(LightsService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StopLight_(LightsService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ListLights_(LightsService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_NewLight_(LightsService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_UpdateLight_(LightsService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeleteLights_(LightsService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_State_(LightsService_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Switch_(LightsService_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status LightsService::Stub::PreviewLight(::grpc::ClientContext* context, const ::lightsService::PreviewLightRequest& request, ::lightsService::PreviewLightResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_PreviewLight_, context, request, response);
}

void LightsService::Stub::experimental_async::PreviewLight(::grpc::ClientContext* context, const ::lightsService::PreviewLightRequest* request, ::lightsService::PreviewLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PreviewLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::PreviewLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::PreviewLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PreviewLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::PreviewLight(::grpc::ClientContext* context, const ::lightsService::PreviewLightRequest* request, ::lightsService::PreviewLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PreviewLight_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::PreviewLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::PreviewLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PreviewLight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::PreviewLightResponse>* LightsService::Stub::AsyncPreviewLightRaw(::grpc::ClientContext* context, const ::lightsService::PreviewLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::PreviewLightResponse>::Create(channel_.get(), cq, rpcmethod_PreviewLight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::PreviewLightResponse>* LightsService::Stub::PrepareAsyncPreviewLightRaw(::grpc::ClientContext* context, const ::lightsService::PreviewLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::PreviewLightResponse>::Create(channel_.get(), cq, rpcmethod_PreviewLight_, context, request, false);
}

::grpc::Status LightsService::Stub::PlayLight(::grpc::ClientContext* context, const ::lightsService::PlayLightRequest& request, ::lightsService::PlayLightResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_PlayLight_, context, request, response);
}

void LightsService::Stub::experimental_async::PlayLight(::grpc::ClientContext* context, const ::lightsService::PlayLightRequest* request, ::lightsService::PlayLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PlayLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::PlayLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::PlayLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PlayLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::PlayLight(::grpc::ClientContext* context, const ::lightsService::PlayLightRequest* request, ::lightsService::PlayLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PlayLight_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::PlayLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::PlayLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PlayLight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::PlayLightResponse>* LightsService::Stub::AsyncPlayLightRaw(::grpc::ClientContext* context, const ::lightsService::PlayLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::PlayLightResponse>::Create(channel_.get(), cq, rpcmethod_PlayLight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::PlayLightResponse>* LightsService::Stub::PrepareAsyncPlayLightRaw(::grpc::ClientContext* context, const ::lightsService::PlayLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::PlayLightResponse>::Create(channel_.get(), cq, rpcmethod_PlayLight_, context, request, false);
}

::grpc::Status LightsService::Stub::StopLight(::grpc::ClientContext* context, const ::lightsService::StopLightRequest& request, ::lightsService::StopLightResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StopLight_, context, request, response);
}

void LightsService::Stub::experimental_async::StopLight(::grpc::ClientContext* context, const ::lightsService::StopLightRequest* request, ::lightsService::StopLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::StopLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::StopLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StopLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::StopLight(::grpc::ClientContext* context, const ::lightsService::StopLightRequest* request, ::lightsService::StopLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopLight_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::StopLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::StopLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StopLight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::StopLightResponse>* LightsService::Stub::AsyncStopLightRaw(::grpc::ClientContext* context, const ::lightsService::StopLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::StopLightResponse>::Create(channel_.get(), cq, rpcmethod_StopLight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::StopLightResponse>* LightsService::Stub::PrepareAsyncStopLightRaw(::grpc::ClientContext* context, const ::lightsService::StopLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::StopLightResponse>::Create(channel_.get(), cq, rpcmethod_StopLight_, context, request, false);
}

::grpc::Status LightsService::Stub::ListLights(::grpc::ClientContext* context, const ::lightsService::ListLightsRequest& request, ::lightsService::ListLightsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ListLights_, context, request, response);
}

void LightsService::Stub::experimental_async::ListLights(::grpc::ClientContext* context, const ::lightsService::ListLightsRequest* request, ::lightsService::ListLightsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ListLights_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::ListLights(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::ListLightsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ListLights_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::ListLights(::grpc::ClientContext* context, const ::lightsService::ListLightsRequest* request, ::lightsService::ListLightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ListLights_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::ListLights(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::ListLightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ListLights_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::ListLightsResponse>* LightsService::Stub::AsyncListLightsRaw(::grpc::ClientContext* context, const ::lightsService::ListLightsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::ListLightsResponse>::Create(channel_.get(), cq, rpcmethod_ListLights_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::ListLightsResponse>* LightsService::Stub::PrepareAsyncListLightsRaw(::grpc::ClientContext* context, const ::lightsService::ListLightsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::ListLightsResponse>::Create(channel_.get(), cq, rpcmethod_ListLights_, context, request, false);
}

::grpc::Status LightsService::Stub::NewLight(::grpc::ClientContext* context, const ::lightsService::NewLightRequest& request, ::lightsService::NewLightResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_NewLight_, context, request, response);
}

void LightsService::Stub::experimental_async::NewLight(::grpc::ClientContext* context, const ::lightsService::NewLightRequest* request, ::lightsService::NewLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_NewLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::NewLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::NewLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_NewLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::NewLight(::grpc::ClientContext* context, const ::lightsService::NewLightRequest* request, ::lightsService::NewLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_NewLight_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::NewLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::NewLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_NewLight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::NewLightResponse>* LightsService::Stub::AsyncNewLightRaw(::grpc::ClientContext* context, const ::lightsService::NewLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::NewLightResponse>::Create(channel_.get(), cq, rpcmethod_NewLight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::NewLightResponse>* LightsService::Stub::PrepareAsyncNewLightRaw(::grpc::ClientContext* context, const ::lightsService::NewLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::NewLightResponse>::Create(channel_.get(), cq, rpcmethod_NewLight_, context, request, false);
}

::grpc::Status LightsService::Stub::UpdateLight(::grpc::ClientContext* context, const ::lightsService::UpdateLightRequest& request, ::lightsService::UpdateLightResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_UpdateLight_, context, request, response);
}

void LightsService::Stub::experimental_async::UpdateLight(::grpc::ClientContext* context, const ::lightsService::UpdateLightRequest* request, ::lightsService::UpdateLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_UpdateLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::UpdateLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::UpdateLightResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_UpdateLight_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::UpdateLight(::grpc::ClientContext* context, const ::lightsService::UpdateLightRequest* request, ::lightsService::UpdateLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_UpdateLight_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::UpdateLight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::UpdateLightResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_UpdateLight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::UpdateLightResponse>* LightsService::Stub::AsyncUpdateLightRaw(::grpc::ClientContext* context, const ::lightsService::UpdateLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::UpdateLightResponse>::Create(channel_.get(), cq, rpcmethod_UpdateLight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::UpdateLightResponse>* LightsService::Stub::PrepareAsyncUpdateLightRaw(::grpc::ClientContext* context, const ::lightsService::UpdateLightRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::UpdateLightResponse>::Create(channel_.get(), cq, rpcmethod_UpdateLight_, context, request, false);
}

::grpc::Status LightsService::Stub::DeleteLights(::grpc::ClientContext* context, const ::lightsService::DeleteLightsRequest& request, ::lightsService::DeleteLightsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_DeleteLights_, context, request, response);
}

void LightsService::Stub::experimental_async::DeleteLights(::grpc::ClientContext* context, const ::lightsService::DeleteLightsRequest* request, ::lightsService::DeleteLightsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteLights_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::DeleteLights(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::DeleteLightsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteLights_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::DeleteLights(::grpc::ClientContext* context, const ::lightsService::DeleteLightsRequest* request, ::lightsService::DeleteLightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteLights_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::DeleteLights(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::DeleteLightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_DeleteLights_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::DeleteLightsResponse>* LightsService::Stub::AsyncDeleteLightsRaw(::grpc::ClientContext* context, const ::lightsService::DeleteLightsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::DeleteLightsResponse>::Create(channel_.get(), cq, rpcmethod_DeleteLights_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::DeleteLightsResponse>* LightsService::Stub::PrepareAsyncDeleteLightsRaw(::grpc::ClientContext* context, const ::lightsService::DeleteLightsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::DeleteLightsResponse>::Create(channel_.get(), cq, rpcmethod_DeleteLights_, context, request, false);
}

::grpc::Status LightsService::Stub::State(::grpc::ClientContext* context, const ::lightsService::StateRequest& request, ::lightsService::StateResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_State_, context, request, response);
}

void LightsService::Stub::experimental_async::State(::grpc::ClientContext* context, const ::lightsService::StateRequest* request, ::lightsService::StateResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_State_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::State(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::StateResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_State_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::State(::grpc::ClientContext* context, const ::lightsService::StateRequest* request, ::lightsService::StateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_State_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::State(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::StateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_State_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::StateResponse>* LightsService::Stub::AsyncStateRaw(::grpc::ClientContext* context, const ::lightsService::StateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::StateResponse>::Create(channel_.get(), cq, rpcmethod_State_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::StateResponse>* LightsService::Stub::PrepareAsyncStateRaw(::grpc::ClientContext* context, const ::lightsService::StateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::StateResponse>::Create(channel_.get(), cq, rpcmethod_State_, context, request, false);
}

::grpc::Status LightsService::Stub::Switch(::grpc::ClientContext* context, const ::lightsService::SwitchRequest& request, ::lightsService::SwitchResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Switch_, context, request, response);
}

void LightsService::Stub::experimental_async::Switch(::grpc::ClientContext* context, const ::lightsService::SwitchRequest* request, ::lightsService::SwitchResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Switch_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::Switch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::SwitchResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Switch_, context, request, response, std::move(f));
}

void LightsService::Stub::experimental_async::Switch(::grpc::ClientContext* context, const ::lightsService::SwitchRequest* request, ::lightsService::SwitchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Switch_, context, request, response, reactor);
}

void LightsService::Stub::experimental_async::Switch(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::lightsService::SwitchResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Switch_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::lightsService::SwitchResponse>* LightsService::Stub::AsyncSwitchRaw(::grpc::ClientContext* context, const ::lightsService::SwitchRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::SwitchResponse>::Create(channel_.get(), cq, rpcmethod_Switch_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::lightsService::SwitchResponse>* LightsService::Stub::PrepareAsyncSwitchRaw(::grpc::ClientContext* context, const ::lightsService::SwitchRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::lightsService::SwitchResponse>::Create(channel_.get(), cq, rpcmethod_Switch_, context, request, false);
}

LightsService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::PreviewLightRequest, ::lightsService::PreviewLightResponse>(
          std::mem_fn(&LightsService::Service::PreviewLight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::PlayLightRequest, ::lightsService::PlayLightResponse>(
          std::mem_fn(&LightsService::Service::PlayLight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::StopLightRequest, ::lightsService::StopLightResponse>(
          std::mem_fn(&LightsService::Service::StopLight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::ListLightsRequest, ::lightsService::ListLightsResponse>(
          std::mem_fn(&LightsService::Service::ListLights), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::NewLightRequest, ::lightsService::NewLightResponse>(
          std::mem_fn(&LightsService::Service::NewLight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::UpdateLightRequest, ::lightsService::UpdateLightResponse>(
          std::mem_fn(&LightsService::Service::UpdateLight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::DeleteLightsRequest, ::lightsService::DeleteLightsResponse>(
          std::mem_fn(&LightsService::Service::DeleteLights), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::StateRequest, ::lightsService::StateResponse>(
          std::mem_fn(&LightsService::Service::State), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LightsService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LightsService::Service, ::lightsService::SwitchRequest, ::lightsService::SwitchResponse>(
          std::mem_fn(&LightsService::Service::Switch), this)));
}

LightsService::Service::~Service() {
}

::grpc::Status LightsService::Service::PreviewLight(::grpc::ServerContext* context, const ::lightsService::PreviewLightRequest* request, ::lightsService::PreviewLightResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::PlayLight(::grpc::ServerContext* context, const ::lightsService::PlayLightRequest* request, ::lightsService::PlayLightResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::StopLight(::grpc::ServerContext* context, const ::lightsService::StopLightRequest* request, ::lightsService::StopLightResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::ListLights(::grpc::ServerContext* context, const ::lightsService::ListLightsRequest* request, ::lightsService::ListLightsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::NewLight(::grpc::ServerContext* context, const ::lightsService::NewLightRequest* request, ::lightsService::NewLightResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::UpdateLight(::grpc::ServerContext* context, const ::lightsService::UpdateLightRequest* request, ::lightsService::UpdateLightResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::DeleteLights(::grpc::ServerContext* context, const ::lightsService::DeleteLightsRequest* request, ::lightsService::DeleteLightsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::State(::grpc::ServerContext* context, const ::lightsService::StateRequest* request, ::lightsService::StateResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LightsService::Service::Switch(::grpc::ServerContext* context, const ::lightsService::SwitchRequest* request, ::lightsService::SwitchResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace lightsService

