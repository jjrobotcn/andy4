// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lights.proto

package lightsService

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 灯光类型
type LightType int32

const (
	// 保留， 不使用
	LightType_UNDEFINED LightType = 0
	// 嘴部灯光
	LightType_MOUTH LightType = 1
	// 手臂灯光
	LightType_HANDS LightType = 2
	// 耳朵灯光
	LightType_EARS LightType = 3
)

var LightType_name = map[int32]string{
	0: "UNDEFINED",
	1: "MOUTH",
	2: "HANDS",
	3: "EARS",
}

var LightType_value = map[string]int32{
	"UNDEFINED": 0,
	"MOUTH":     1,
	"HANDS":     2,
	"EARS":      3,
}

func (x LightType) String() string {
	return proto.EnumName(LightType_name, int32(x))
}

func (LightType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{0}
}

// 播放模式
type PlayMode int32

const (
	// 预置模式 默认为ALWAYS
	PlayMode_PRESET PlayMode = 0
	// 常亮模式
	PlayMode_ALWAYS PlayMode = 1
	// 滚动模式
	// [1,2,3] => [2,3,1] => [3,1,2]
	PlayMode_MARQUEE PlayMode = 2
	// 闪烁模式
	// [true, true] => [false, false]
	PlayMode_FLASH PlayMode = 3
	// 跳动模式
	// [true, false, true, false] => [false, true, false, true]
	PlayMode_TICKTOCK PlayMode = 4
)

var PlayMode_name = map[int32]string{
	0: "PRESET",
	1: "ALWAYS",
	2: "MARQUEE",
	3: "FLASH",
	4: "TICKTOCK",
}

var PlayMode_value = map[string]int32{
	"PRESET":   0,
	"ALWAYS":   1,
	"MARQUEE":  2,
	"FLASH":    3,
	"TICKTOCK": 4,
}

func (x PlayMode) String() string {
	return proto.EnumName(PlayMode_name, int32(x))
}

func (PlayMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{1}
}

// 预览灯光请求
type PreviewLightRequest struct {
	// 灯光id
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreviewLightRequest) Reset()         { *m = PreviewLightRequest{} }
func (m *PreviewLightRequest) String() string { return proto.CompactTextString(m) }
func (*PreviewLightRequest) ProtoMessage()    {}
func (*PreviewLightRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{0}
}
func (m *PreviewLightRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreviewLightRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreviewLightRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreviewLightRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreviewLightRequest.Merge(m, src)
}
func (m *PreviewLightRequest) XXX_Size() int {
	return m.Size()
}
func (m *PreviewLightRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PreviewLightRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PreviewLightRequest proto.InternalMessageInfo

func (m *PreviewLightRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// 预览灯光结果
type PreviewLightResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreviewLightResponse) Reset()         { *m = PreviewLightResponse{} }
func (m *PreviewLightResponse) String() string { return proto.CompactTextString(m) }
func (*PreviewLightResponse) ProtoMessage()    {}
func (*PreviewLightResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{1}
}
func (m *PreviewLightResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreviewLightResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreviewLightResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreviewLightResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreviewLightResponse.Merge(m, src)
}
func (m *PreviewLightResponse) XXX_Size() int {
	return m.Size()
}
func (m *PreviewLightResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PreviewLightResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PreviewLightResponse proto.InternalMessageInfo

// 播放灯光请求
type PlayLightRequest struct {
	// 灯光类型
	Ltype LightType `protobuf:"varint,1,opt,name=ltype,proto3,enum=lightsService.LightType" json:"ltype,omitempty"`
	// 灯光id
	// name参数非空时将优先匹配
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// 灯光名
	// 仅匹配
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayLightRequest) Reset()         { *m = PlayLightRequest{} }
func (m *PlayLightRequest) String() string { return proto.CompactTextString(m) }
func (*PlayLightRequest) ProtoMessage()    {}
func (*PlayLightRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{2}
}
func (m *PlayLightRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayLightRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayLightRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayLightRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayLightRequest.Merge(m, src)
}
func (m *PlayLightRequest) XXX_Size() int {
	return m.Size()
}
func (m *PlayLightRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayLightRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlayLightRequest proto.InternalMessageInfo

func (m *PlayLightRequest) GetLtype() LightType {
	if m != nil {
		return m.Ltype
	}
	return LightType_UNDEFINED
}

func (m *PlayLightRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PlayLightRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// 播放灯光请求结果
type PlayLightResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayLightResponse) Reset()         { *m = PlayLightResponse{} }
func (m *PlayLightResponse) String() string { return proto.CompactTextString(m) }
func (*PlayLightResponse) ProtoMessage()    {}
func (*PlayLightResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{3}
}
func (m *PlayLightResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayLightResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayLightResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayLightResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayLightResponse.Merge(m, src)
}
func (m *PlayLightResponse) XXX_Size() int {
	return m.Size()
}
func (m *PlayLightResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayLightResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlayLightResponse proto.InternalMessageInfo

// 停止灯光请求
type StopLightRequest struct {
	// 灯光类型列表
	Ltypes               []LightType `protobuf:"varint,1,rep,packed,name=ltypes,proto3,enum=lightsService.LightType" json:"ltypes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *StopLightRequest) Reset()         { *m = StopLightRequest{} }
func (m *StopLightRequest) String() string { return proto.CompactTextString(m) }
func (*StopLightRequest) ProtoMessage()    {}
func (*StopLightRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{4}
}
func (m *StopLightRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopLightRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopLightRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopLightRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopLightRequest.Merge(m, src)
}
func (m *StopLightRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopLightRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopLightRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopLightRequest proto.InternalMessageInfo

func (m *StopLightRequest) GetLtypes() []LightType {
	if m != nil {
		return m.Ltypes
	}
	return nil
}

// 停止灯光结果
type StopLightResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopLightResponse) Reset()         { *m = StopLightResponse{} }
func (m *StopLightResponse) String() string { return proto.CompactTextString(m) }
func (*StopLightResponse) ProtoMessage()    {}
func (*StopLightResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{5}
}
func (m *StopLightResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopLightResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopLightResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopLightResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopLightResponse.Merge(m, src)
}
func (m *StopLightResponse) XXX_Size() int {
	return m.Size()
}
func (m *StopLightResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StopLightResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StopLightResponse proto.InternalMessageInfo

// 灯光数据明细
type LightInfo struct {
	// 灯光类型
	Ltype LightType `protobuf:"varint,1,opt,name=ltype,proto3,enum=lightsService.LightType" json:"ltype,omitempty"`
	// 灯光id
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// 灯光名
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// 灯光帧列表
	Frames               []*LightFrame `protobuf:"bytes,4,rep,name=frames,proto3" json:"frames,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LightInfo) Reset()         { *m = LightInfo{} }
func (m *LightInfo) String() string { return proto.CompactTextString(m) }
func (*LightInfo) ProtoMessage()    {}
func (*LightInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{6}
}
func (m *LightInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LightInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LightInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LightInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LightInfo.Merge(m, src)
}
func (m *LightInfo) XXX_Size() int {
	return m.Size()
}
func (m *LightInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LightInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LightInfo proto.InternalMessageInfo

func (m *LightInfo) GetLtype() LightType {
	if m != nil {
		return m.Ltype
	}
	return LightType_UNDEFINED
}

func (m *LightInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LightInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LightInfo) GetFrames() []*LightFrame {
	if m != nil {
		return m.Frames
	}
	return nil
}

// 灯光帧
type LightFrame struct {
	// 灯光hex数据列表
	// e.g. #31ebd1
	Colors []string `protobuf:"bytes,1,rep,name=colors,proto3" json:"colors,omitempty"`
	// 播放速度
	Speed uint32 `protobuf:"varint,2,opt,name=speed,proto3" json:"speed,omitempty"`
	// 播放模式
	Mode                 PlayMode `protobuf:"varint,3,opt,name=mode,proto3,enum=lightsService.PlayMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LightFrame) Reset()         { *m = LightFrame{} }
func (m *LightFrame) String() string { return proto.CompactTextString(m) }
func (*LightFrame) ProtoMessage()    {}
func (*LightFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{7}
}
func (m *LightFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LightFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LightFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LightFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LightFrame.Merge(m, src)
}
func (m *LightFrame) XXX_Size() int {
	return m.Size()
}
func (m *LightFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_LightFrame.DiscardUnknown(m)
}

var xxx_messageInfo_LightFrame proto.InternalMessageInfo

func (m *LightFrame) GetColors() []string {
	if m != nil {
		return m.Colors
	}
	return nil
}

func (m *LightFrame) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *LightFrame) GetMode() PlayMode {
	if m != nil {
		return m.Mode
	}
	return PlayMode_PRESET
}

// 获取灯光数据请求
type ListLightsRequest struct {
	// 灯光类型
	Ltype                LightType `protobuf:"varint,1,opt,name=ltype,proto3,enum=lightsService.LightType" json:"ltype,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ListLightsRequest) Reset()         { *m = ListLightsRequest{} }
func (m *ListLightsRequest) String() string { return proto.CompactTextString(m) }
func (*ListLightsRequest) ProtoMessage()    {}
func (*ListLightsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{8}
}
func (m *ListLightsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListLightsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListLightsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListLightsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListLightsRequest.Merge(m, src)
}
func (m *ListLightsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListLightsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListLightsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListLightsRequest proto.InternalMessageInfo

func (m *ListLightsRequest) GetLtype() LightType {
	if m != nil {
		return m.Ltype
	}
	return LightType_UNDEFINED
}

// 获取灯光数据结果
type ListLightsResponse struct {
	// 灯光数据明细列表
	LightsInfo           []*LightInfo `protobuf:"bytes,1,rep,name=lights_info,json=lightsInfo,proto3" json:"lights_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ListLightsResponse) Reset()         { *m = ListLightsResponse{} }
func (m *ListLightsResponse) String() string { return proto.CompactTextString(m) }
func (*ListLightsResponse) ProtoMessage()    {}
func (*ListLightsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{9}
}
func (m *ListLightsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListLightsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListLightsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListLightsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListLightsResponse.Merge(m, src)
}
func (m *ListLightsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListLightsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListLightsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListLightsResponse proto.InternalMessageInfo

func (m *ListLightsResponse) GetLightsInfo() []*LightInfo {
	if m != nil {
		return m.LightsInfo
	}
	return nil
}

// 创建灯光请求
type NewLightRequest struct {
	// 灯光数据明细
	LightInfo            *LightInfo `protobuf:"bytes,1,opt,name=light_info,json=lightInfo,proto3" json:"light_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NewLightRequest) Reset()         { *m = NewLightRequest{} }
func (m *NewLightRequest) String() string { return proto.CompactTextString(m) }
func (*NewLightRequest) ProtoMessage()    {}
func (*NewLightRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{10}
}
func (m *NewLightRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewLightRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewLightRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewLightRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewLightRequest.Merge(m, src)
}
func (m *NewLightRequest) XXX_Size() int {
	return m.Size()
}
func (m *NewLightRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewLightRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewLightRequest proto.InternalMessageInfo

func (m *NewLightRequest) GetLightInfo() *LightInfo {
	if m != nil {
		return m.LightInfo
	}
	return nil
}

// 创建灯光结果
type NewLightResponse struct {
	// 灯光数据明细
	LightInfo            *LightInfo `protobuf:"bytes,1,opt,name=light_info,json=lightInfo,proto3" json:"light_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *NewLightResponse) Reset()         { *m = NewLightResponse{} }
func (m *NewLightResponse) String() string { return proto.CompactTextString(m) }
func (*NewLightResponse) ProtoMessage()    {}
func (*NewLightResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{11}
}
func (m *NewLightResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewLightResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewLightResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewLightResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewLightResponse.Merge(m, src)
}
func (m *NewLightResponse) XXX_Size() int {
	return m.Size()
}
func (m *NewLightResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NewLightResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NewLightResponse proto.InternalMessageInfo

func (m *NewLightResponse) GetLightInfo() *LightInfo {
	if m != nil {
		return m.LightInfo
	}
	return nil
}

// 更新灯光数据请求
type UpdateLightRequest struct {
	// 灯光数据明细
	LightInfo            *LightInfo `protobuf:"bytes,1,opt,name=light_info,json=lightInfo,proto3" json:"light_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *UpdateLightRequest) Reset()         { *m = UpdateLightRequest{} }
func (m *UpdateLightRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateLightRequest) ProtoMessage()    {}
func (*UpdateLightRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{12}
}
func (m *UpdateLightRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLightRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLightRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLightRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLightRequest.Merge(m, src)
}
func (m *UpdateLightRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLightRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLightRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLightRequest proto.InternalMessageInfo

func (m *UpdateLightRequest) GetLightInfo() *LightInfo {
	if m != nil {
		return m.LightInfo
	}
	return nil
}

// 更新灯光数据结果
type UpdateLightResponse struct {
	// 灯光数据明细
	LightInfo            *LightInfo `protobuf:"bytes,1,opt,name=light_info,json=lightInfo,proto3" json:"light_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *UpdateLightResponse) Reset()         { *m = UpdateLightResponse{} }
func (m *UpdateLightResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateLightResponse) ProtoMessage()    {}
func (*UpdateLightResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{13}
}
func (m *UpdateLightResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLightResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLightResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLightResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLightResponse.Merge(m, src)
}
func (m *UpdateLightResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLightResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLightResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLightResponse proto.InternalMessageInfo

func (m *UpdateLightResponse) GetLightInfo() *LightInfo {
	if m != nil {
		return m.LightInfo
	}
	return nil
}

// 删除灯光请求
type DeleteLightsRequest struct {
	// 删除灯光id列表
	LightsId             []string `protobuf:"bytes,1,rep,name=lights_id,json=lightsId,proto3" json:"lights_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteLightsRequest) Reset()         { *m = DeleteLightsRequest{} }
func (m *DeleteLightsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteLightsRequest) ProtoMessage()    {}
func (*DeleteLightsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{14}
}
func (m *DeleteLightsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteLightsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteLightsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteLightsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteLightsRequest.Merge(m, src)
}
func (m *DeleteLightsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteLightsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteLightsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteLightsRequest proto.InternalMessageInfo

func (m *DeleteLightsRequest) GetLightsId() []string {
	if m != nil {
		return m.LightsId
	}
	return nil
}

// 删除灯光结果
type DeleteLightsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteLightsResponse) Reset()         { *m = DeleteLightsResponse{} }
func (m *DeleteLightsResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteLightsResponse) ProtoMessage()    {}
func (*DeleteLightsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e08e6632b915473, []int{15}
}
func (m *DeleteLightsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteLightsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteLightsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteLightsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteLightsResponse.Merge(m, src)
}
func (m *DeleteLightsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteLightsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteLightsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteLightsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("lightsService.LightType", LightType_name, LightType_value)
	proto.RegisterEnum("lightsService.PlayMode", PlayMode_name, PlayMode_value)
	proto.RegisterType((*PreviewLightRequest)(nil), "lightsService.PreviewLightRequest")
	proto.RegisterType((*PreviewLightResponse)(nil), "lightsService.PreviewLightResponse")
	proto.RegisterType((*PlayLightRequest)(nil), "lightsService.PlayLightRequest")
	proto.RegisterType((*PlayLightResponse)(nil), "lightsService.PlayLightResponse")
	proto.RegisterType((*StopLightRequest)(nil), "lightsService.StopLightRequest")
	proto.RegisterType((*StopLightResponse)(nil), "lightsService.StopLightResponse")
	proto.RegisterType((*LightInfo)(nil), "lightsService.LightInfo")
	proto.RegisterType((*LightFrame)(nil), "lightsService.LightFrame")
	proto.RegisterType((*ListLightsRequest)(nil), "lightsService.ListLightsRequest")
	proto.RegisterType((*ListLightsResponse)(nil), "lightsService.ListLightsResponse")
	proto.RegisterType((*NewLightRequest)(nil), "lightsService.NewLightRequest")
	proto.RegisterType((*NewLightResponse)(nil), "lightsService.NewLightResponse")
	proto.RegisterType((*UpdateLightRequest)(nil), "lightsService.UpdateLightRequest")
	proto.RegisterType((*UpdateLightResponse)(nil), "lightsService.UpdateLightResponse")
	proto.RegisterType((*DeleteLightsRequest)(nil), "lightsService.DeleteLightsRequest")
	proto.RegisterType((*DeleteLightsResponse)(nil), "lightsService.DeleteLightsResponse")
}

func init() { proto.RegisterFile("lights.proto", fileDescriptor_8e08e6632b915473) }

var fileDescriptor_8e08e6632b915473 = []byte{
	// 764 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0x5f, 0x6f, 0x12, 0x4d,
	0x14, 0xc6, 0xbb, 0x40, 0x79, 0xd9, 0x03, 0xf4, 0xdd, 0x0e, 0x4d, 0x5f, 0x4a, 0xfb, 0x52, 0x3a,
	0xb5, 0xda, 0xd4, 0x04, 0x14, 0x2f, 0x8c, 0xbd, 0xc3, 0x42, 0x43, 0x2d, 0xd0, 0xba, 0x40, 0x8c,
	0x57, 0xcd, 0x5a, 0x06, 0xdc, 0x64, 0xbb, 0xb3, 0xb2, 0xdb, 0x2a, 0x89, 0x17, 0xc6, 0x8f, 0xa0,
	0x5f, 0xca, 0x4b, 0x13, 0xbf, 0x80, 0x69, 0xbc, 0xf3, 0x4b, 0x98, 0x9d, 0x19, 0xca, 0xfe, 0x01,
	0x2e, 0xaa, 0xde, 0xcd, 0x2c, 0xcf, 0x79, 0x7e, 0x67, 0x66, 0xce, 0x39, 0x01, 0x52, 0x86, 0x3e,
	0x78, 0xed, 0xd8, 0x45, 0x6b, 0x48, 0x1d, 0x8a, 0xd2, 0x7c, 0xd7, 0x26, 0xc3, 0x2b, 0xfd, 0x9c,
	0xe4, 0x36, 0x06, 0x94, 0x0e, 0x0c, 0x52, 0xd2, 0x2c, 0xbd, 0xa4, 0x99, 0x26, 0x75, 0x34, 0x47,
	0xa7, 0xa6, 0x10, 0xe3, 0x1d, 0xc8, 0x9c, 0x0e, 0xc9, 0x95, 0x4e, 0xde, 0x36, 0xdc, 0x28, 0x95,
	0xbc, 0xb9, 0x24, 0xb6, 0x83, 0x96, 0x20, 0xa2, 0xf7, 0xb2, 0x52, 0x41, 0xda, 0x95, 0xd5, 0x88,
	0xde, 0xc3, 0xab, 0xb0, 0xe2, 0x97, 0xd9, 0x16, 0x35, 0x6d, 0x82, 0xfb, 0xa0, 0x9c, 0x1a, 0xda,
	0xc8, 0x17, 0x5b, 0x84, 0x45, 0xc3, 0x19, 0x59, 0x84, 0x85, 0x2f, 0x95, 0xb3, 0x45, 0x5f, 0x3e,
	0x45, 0xa6, 0xed, 0x8c, 0x2c, 0xa2, 0x72, 0x99, 0x60, 0x45, 0xc6, 0x2c, 0x84, 0x20, 0x66, 0x6a,
	0x17, 0x24, 0x1b, 0x65, 0x5f, 0xd8, 0x1a, 0x67, 0x60, 0xd9, 0xc3, 0x11, 0xf0, 0x2a, 0x28, 0x6d,
	0x87, 0x5a, 0x3e, 0xf8, 0x03, 0x88, 0x33, 0x57, 0x3b, 0x2b, 0x15, 0xa2, 0x73, 0xe9, 0x42, 0xe7,
	0x5a, 0x7b, 0x5c, 0x84, 0xf5, 0x27, 0x09, 0x64, 0xf6, 0xe5, 0xc8, 0xec, 0xd3, 0xbf, 0x71, 0x22,
	0xf4, 0x10, 0xe2, 0xfd, 0xa1, 0x76, 0x41, 0xec, 0x6c, 0xac, 0x10, 0xdd, 0x4d, 0x96, 0xd7, 0xa6,
	0x99, 0x1e, 0xba, 0x0a, 0x55, 0x08, 0xf1, 0x00, 0x60, 0xf2, 0x15, 0xad, 0x42, 0xfc, 0x9c, 0x1a,
	0x74, 0xc8, 0x4f, 0x2a, 0xab, 0x62, 0x87, 0x56, 0x60, 0xd1, 0xb6, 0x08, 0xe1, 0xfc, 0xb4, 0xca,
	0x37, 0xe8, 0x3e, 0xc4, 0x2e, 0x68, 0x8f, 0xa7, 0xb0, 0x54, 0xfe, 0x2f, 0x00, 0x73, 0xef, 0xb6,
	0x49, 0x7b, 0x44, 0x65, 0x22, 0x7c, 0x00, 0xcb, 0x0d, 0xdd, 0x76, 0x18, 0xcc, 0xbe, 0xe5, 0xb3,
	0xe2, 0x13, 0x40, 0x5e, 0x13, 0x7e, 0xb1, 0xe8, 0x09, 0x24, 0x79, 0xdc, 0x99, 0x6e, 0xf6, 0x29,
	0x4b, 0x3d, 0x39, 0xdd, 0xcb, 0xbd, 0x79, 0x15, 0xf8, 0x0f, 0xee, 0x1a, 0x3f, 0x83, 0x7f, 0x5b,
	0x81, 0x32, 0x7d, 0x0c, 0x5c, 0x30, 0x36, 0x93, 0xe6, 0x9a, 0xc9, 0xc6, 0x78, 0x89, 0x8f, 0x41,
	0x69, 0x05, 0x6a, 0xf9, 0xf6, 0x66, 0x4d, 0x40, 0x5d, 0xab, 0xa7, 0x39, 0xe4, 0xcf, 0xe4, 0xd6,
	0x82, 0x8c, 0xcf, 0xee, 0x77, 0xd3, 0x2b, 0x43, 0xa6, 0x4a, 0x0c, 0x22, 0xfc, 0x6e, 0xde, 0x73,
	0x1d, 0xe4, 0xf1, 0x4b, 0xf4, 0x44, 0x09, 0x25, 0xc4, 0x6d, 0xb3, 0x7e, 0xf7, 0xc7, 0xf0, 0x24,
	0xf6, 0xf6, 0x45, 0x5b, 0xb8, 0x0f, 0x8d, 0xd2, 0x20, 0x77, 0x5b, 0xd5, 0xda, 0xe1, 0x51, 0xab,
	0x56, 0x55, 0x16, 0x90, 0x0c, 0x8b, 0xcd, 0x93, 0x6e, 0xa7, 0xae, 0x48, 0xee, 0xb2, 0x5e, 0x69,
	0x55, 0xdb, 0x4a, 0x04, 0x25, 0x20, 0x56, 0xab, 0xa8, 0x6d, 0x25, 0xba, 0x57, 0x87, 0xc4, 0xb8,
	0xce, 0x10, 0x40, 0xfc, 0x54, 0xad, 0xb5, 0x6b, 0x1d, 0x65, 0xc1, 0x5d, 0x57, 0x1a, 0x2f, 0x2a,
	0x2f, 0xdb, 0x8a, 0x84, 0x92, 0xf0, 0x4f, 0xb3, 0xa2, 0x3e, 0xef, 0xd6, 0x6a, 0x4a, 0xc4, 0x75,
	0x39, 0x6c, 0x54, 0xda, 0x75, 0x25, 0x8a, 0x52, 0x90, 0xe8, 0x1c, 0x1d, 0x1c, 0x77, 0x4e, 0x0e,
	0x8e, 0x95, 0x58, 0xf9, 0x67, 0x1c, 0xd2, 0x0d, 0xef, 0xc1, 0xd1, 0x07, 0x09, 0x52, 0xde, 0x01,
	0x85, 0x70, 0xb0, 0xc2, 0xc3, 0x43, 0x2e, 0xb7, 0x3d, 0x57, 0x23, 0x26, 0xc1, 0xbd, 0x8f, 0xdf,
	0x7e, 0x7c, 0x8e, 0x6c, 0xe1, 0x0d, 0x36, 0x40, 0xaf, 0xca, 0x25, 0x1e, 0x53, 0xb2, 0xb8, 0xf8,
	0x8c, 0x6d, 0xf7, 0xa5, 0x3d, 0xe4, 0x80, 0x7c, 0x33, 0xa2, 0xd0, 0xe6, 0x94, 0x06, 0xf3, 0xb1,
	0x0b, 0xb3, 0x05, 0x02, 0x7c, 0x87, 0x81, 0xf3, 0x78, 0x2d, 0x08, 0x36, 0xb4, 0x91, 0x8f, 0x7a,
	0x33, 0xbd, 0x42, 0xd4, 0xe0, 0x74, 0x0c, 0x51, 0xc3, 0x83, 0x6f, 0x16, 0xd5, 0x76, 0xa8, 0x35,
	0xa1, 0xbe, 0x73, 0x27, 0xd1, 0xb8, 0xb7, 0x51, 0x21, 0x54, 0x85, 0x81, 0xd9, 0x91, 0xdb, 0x9a,
	0xa3, 0x10, 0xe0, 0x1d, 0x06, 0xde, 0xc4, 0xb9, 0x00, 0xd8, 0xd0, 0x6d, 0x87, 0x83, 0x6d, 0x97,
	0x6c, 0x41, 0x62, 0xdc, 0xb8, 0x28, 0x1f, 0x70, 0x0d, 0x4c, 0x87, 0xdc, 0xe6, 0xcc, 0xdf, 0x05,
	0x73, 0x9b, 0x31, 0xff, 0xc7, 0xd9, 0x00, 0xd3, 0xf4, 0xbe, 0xeb, 0x7b, 0x48, 0x7a, 0xda, 0x11,
	0x05, 0x8f, 0x12, 0xee, 0xfc, 0x1c, 0x9e, 0x27, 0x11, 0xe8, 0xbb, 0x0c, 0x5d, 0xc0, 0xeb, 0x01,
	0xf4, 0x25, 0xd3, 0x4e, 0xe8, 0x6e, 0x61, 0x7b, 0x3b, 0x31, 0x54, 0xd8, 0x53, 0x5a, 0x3b, 0x54,
	0xd8, 0xd3, 0x5a, 0x79, 0x66, 0x61, 0xf7, 0x98, 0x78, 0x72, 0xe5, 0x4f, 0x53, 0x5f, 0xae, 0xf3,
	0xd2, 0xd7, 0xeb, 0xbc, 0xf4, 0xfd, 0x3a, 0x2f, 0xbd, 0x8a, 0xb3, 0xff, 0x0d, 0x8f, 0x7e, 0x05,
	0x00, 0x00, 0xff, 0xff, 0xf7, 0xfe, 0xcc, 0x6c, 0x74, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LightsServiceClient is the client API for LightsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LightsServiceClient interface {
	// 预览灯光
	// 创建灯光后使用此方法生成灯光文件
	// 在未生成灯光文件前调用PlayLight将无效
	PreviewLight(ctx context.Context, in *PreviewLightRequest, opts ...grpc.CallOption) (*PreviewLightResponse, error)
	// 播放灯光
	// 需在播放前执行PreviewLight生成灯光文件
	PlayLight(ctx context.Context, in *PlayLightRequest, opts ...grpc.CallOption) (*PlayLightResponse, error)
	// 停止灯光
	StopLight(ctx context.Context, in *StopLightRequest, opts ...grpc.CallOption) (*StopLightResponse, error)
	// 获取灯光数据
	ListLights(ctx context.Context, in *ListLightsRequest, opts ...grpc.CallOption) (*ListLightsResponse, error)
	// 创建灯光
	NewLight(ctx context.Context, in *NewLightRequest, opts ...grpc.CallOption) (*NewLightResponse, error)
	// 更新灯光数据
	UpdateLight(ctx context.Context, in *UpdateLightRequest, opts ...grpc.CallOption) (*UpdateLightResponse, error)
	// 删除灯光
	DeleteLights(ctx context.Context, in *DeleteLightsRequest, opts ...grpc.CallOption) (*DeleteLightsResponse, error)
}

type lightsServiceClient struct {
	cc *grpc.ClientConn
}

func NewLightsServiceClient(cc *grpc.ClientConn) LightsServiceClient {
	return &lightsServiceClient{cc}
}

func (c *lightsServiceClient) PreviewLight(ctx context.Context, in *PreviewLightRequest, opts ...grpc.CallOption) (*PreviewLightResponse, error) {
	out := new(PreviewLightResponse)
	err := c.cc.Invoke(ctx, "/lightsService.LightsService/PreviewLight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightsServiceClient) PlayLight(ctx context.Context, in *PlayLightRequest, opts ...grpc.CallOption) (*PlayLightResponse, error) {
	out := new(PlayLightResponse)
	err := c.cc.Invoke(ctx, "/lightsService.LightsService/PlayLight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightsServiceClient) StopLight(ctx context.Context, in *StopLightRequest, opts ...grpc.CallOption) (*StopLightResponse, error) {
	out := new(StopLightResponse)
	err := c.cc.Invoke(ctx, "/lightsService.LightsService/StopLight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightsServiceClient) ListLights(ctx context.Context, in *ListLightsRequest, opts ...grpc.CallOption) (*ListLightsResponse, error) {
	out := new(ListLightsResponse)
	err := c.cc.Invoke(ctx, "/lightsService.LightsService/ListLights", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightsServiceClient) NewLight(ctx context.Context, in *NewLightRequest, opts ...grpc.CallOption) (*NewLightResponse, error) {
	out := new(NewLightResponse)
	err := c.cc.Invoke(ctx, "/lightsService.LightsService/NewLight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightsServiceClient) UpdateLight(ctx context.Context, in *UpdateLightRequest, opts ...grpc.CallOption) (*UpdateLightResponse, error) {
	out := new(UpdateLightResponse)
	err := c.cc.Invoke(ctx, "/lightsService.LightsService/UpdateLight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightsServiceClient) DeleteLights(ctx context.Context, in *DeleteLightsRequest, opts ...grpc.CallOption) (*DeleteLightsResponse, error) {
	out := new(DeleteLightsResponse)
	err := c.cc.Invoke(ctx, "/lightsService.LightsService/DeleteLights", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LightsServiceServer is the server API for LightsService service.
type LightsServiceServer interface {
	// 预览灯光
	// 创建灯光后使用此方法生成灯光文件
	// 在未生成灯光文件前调用PlayLight将无效
	PreviewLight(context.Context, *PreviewLightRequest) (*PreviewLightResponse, error)
	// 播放灯光
	// 需在播放前执行PreviewLight生成灯光文件
	PlayLight(context.Context, *PlayLightRequest) (*PlayLightResponse, error)
	// 停止灯光
	StopLight(context.Context, *StopLightRequest) (*StopLightResponse, error)
	// 获取灯光数据
	ListLights(context.Context, *ListLightsRequest) (*ListLightsResponse, error)
	// 创建灯光
	NewLight(context.Context, *NewLightRequest) (*NewLightResponse, error)
	// 更新灯光数据
	UpdateLight(context.Context, *UpdateLightRequest) (*UpdateLightResponse, error)
	// 删除灯光
	DeleteLights(context.Context, *DeleteLightsRequest) (*DeleteLightsResponse, error)
}

// UnimplementedLightsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedLightsServiceServer struct {
}

func (*UnimplementedLightsServiceServer) PreviewLight(ctx context.Context, req *PreviewLightRequest) (*PreviewLightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreviewLight not implemented")
}
func (*UnimplementedLightsServiceServer) PlayLight(ctx context.Context, req *PlayLightRequest) (*PlayLightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayLight not implemented")
}
func (*UnimplementedLightsServiceServer) StopLight(ctx context.Context, req *StopLightRequest) (*StopLightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopLight not implemented")
}
func (*UnimplementedLightsServiceServer) ListLights(ctx context.Context, req *ListLightsRequest) (*ListLightsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLights not implemented")
}
func (*UnimplementedLightsServiceServer) NewLight(ctx context.Context, req *NewLightRequest) (*NewLightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewLight not implemented")
}
func (*UnimplementedLightsServiceServer) UpdateLight(ctx context.Context, req *UpdateLightRequest) (*UpdateLightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLight not implemented")
}
func (*UnimplementedLightsServiceServer) DeleteLights(ctx context.Context, req *DeleteLightsRequest) (*DeleteLightsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLights not implemented")
}

func RegisterLightsServiceServer(s *grpc.Server, srv LightsServiceServer) {
	s.RegisterService(&_LightsService_serviceDesc, srv)
}

func _LightsService_PreviewLight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreviewLightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightsServiceServer).PreviewLight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lightsService.LightsService/PreviewLight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightsServiceServer).PreviewLight(ctx, req.(*PreviewLightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightsService_PlayLight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayLightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightsServiceServer).PlayLight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lightsService.LightsService/PlayLight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightsServiceServer).PlayLight(ctx, req.(*PlayLightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightsService_StopLight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopLightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightsServiceServer).StopLight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lightsService.LightsService/StopLight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightsServiceServer).StopLight(ctx, req.(*StopLightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightsService_ListLights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLightsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightsServiceServer).ListLights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lightsService.LightsService/ListLights",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightsServiceServer).ListLights(ctx, req.(*ListLightsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightsService_NewLight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewLightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightsServiceServer).NewLight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lightsService.LightsService/NewLight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightsServiceServer).NewLight(ctx, req.(*NewLightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightsService_UpdateLight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightsServiceServer).UpdateLight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lightsService.LightsService/UpdateLight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightsServiceServer).UpdateLight(ctx, req.(*UpdateLightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightsService_DeleteLights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLightsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightsServiceServer).DeleteLights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lightsService.LightsService/DeleteLights",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightsServiceServer).DeleteLights(ctx, req.(*DeleteLightsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LightsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lightsService.LightsService",
	HandlerType: (*LightsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PreviewLight",
			Handler:    _LightsService_PreviewLight_Handler,
		},
		{
			MethodName: "PlayLight",
			Handler:    _LightsService_PlayLight_Handler,
		},
		{
			MethodName: "StopLight",
			Handler:    _LightsService_StopLight_Handler,
		},
		{
			MethodName: "ListLights",
			Handler:    _LightsService_ListLights_Handler,
		},
		{
			MethodName: "NewLight",
			Handler:    _LightsService_NewLight_Handler,
		},
		{
			MethodName: "UpdateLight",
			Handler:    _LightsService_UpdateLight_Handler,
		},
		{
			MethodName: "DeleteLights",
			Handler:    _LightsService_DeleteLights_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lights.proto",
}

func (m *PreviewLightRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreviewLightRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLights(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PreviewLightResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreviewLightResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayLightRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayLightRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ltype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.Ltype))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLights(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLights(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayLightResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayLightResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StopLightRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopLightRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ltypes) > 0 {
		dAtA2 := make([]byte, len(m.Ltypes)*10)
		var j1 int
		for _, num := range m.Ltypes {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintLights(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StopLightResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopLightResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LightInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LightInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ltype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.Ltype))
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLights(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLights(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Frames) > 0 {
		for _, msg := range m.Frames {
			dAtA[i] = 0x22
			i++
			i = encodeVarintLights(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LightFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LightFrame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Colors) > 0 {
		for _, s := range m.Colors {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Speed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.Speed))
	}
	if m.Mode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListLightsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListLightsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ltype != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.Ltype))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListLightsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListLightsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LightsInfo) > 0 {
		for _, msg := range m.LightsInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLights(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewLightRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewLightRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LightInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.LightInfo.Size()))
		n3, err3 := m.LightInfo.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewLightResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewLightResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LightInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.LightInfo.Size()))
		n4, err4 := m.LightInfo.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateLightRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLightRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LightInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.LightInfo.Size()))
		n5, err5 := m.LightInfo.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateLightResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLightResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LightInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLights(dAtA, i, uint64(m.LightInfo.Size()))
		n6, err6 := m.LightInfo.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteLightsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteLightsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LightsId) > 0 {
		for _, s := range m.LightsId {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteLightsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteLightsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintLights(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PreviewLightRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLights(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreviewLightResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayLightRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ltype != 0 {
		n += 1 + sovLights(uint64(m.Ltype))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLights(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLights(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayLightResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopLightRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ltypes) > 0 {
		l = 0
		for _, e := range m.Ltypes {
			l += sovLights(uint64(e))
		}
		n += 1 + sovLights(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopLightResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LightInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ltype != 0 {
		n += 1 + sovLights(uint64(m.Ltype))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLights(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLights(uint64(l))
	}
	if len(m.Frames) > 0 {
		for _, e := range m.Frames {
			l = e.Size()
			n += 1 + l + sovLights(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LightFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Colors) > 0 {
		for _, s := range m.Colors {
			l = len(s)
			n += 1 + l + sovLights(uint64(l))
		}
	}
	if m.Speed != 0 {
		n += 1 + sovLights(uint64(m.Speed))
	}
	if m.Mode != 0 {
		n += 1 + sovLights(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListLightsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ltype != 0 {
		n += 1 + sovLights(uint64(m.Ltype))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListLightsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LightsInfo) > 0 {
		for _, e := range m.LightsInfo {
			l = e.Size()
			n += 1 + l + sovLights(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewLightRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LightInfo != nil {
		l = m.LightInfo.Size()
		n += 1 + l + sovLights(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewLightResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LightInfo != nil {
		l = m.LightInfo.Size()
		n += 1 + l + sovLights(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLightRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LightInfo != nil {
		l = m.LightInfo.Size()
		n += 1 + l + sovLights(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLightResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LightInfo != nil {
		l = m.LightInfo.Size()
		n += 1 + l + sovLights(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteLightsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LightsId) > 0 {
		for _, s := range m.LightsId {
			l = len(s)
			n += 1 + l + sovLights(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteLightsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovLights(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLights(x uint64) (n int) {
	return sovLights(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PreviewLightRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreviewLightRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreviewLightRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreviewLightResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreviewLightResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreviewLightResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayLightRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayLightRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayLightRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltype", wireType)
			}
			m.Ltype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ltype |= LightType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayLightResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayLightResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayLightResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopLightRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopLightRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopLightRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v LightType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLights
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LightType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ltypes = append(m.Ltypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLights
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthLights
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthLights
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Ltypes) == 0 {
					m.Ltypes = make([]LightType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LightType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLights
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LightType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ltypes = append(m.Ltypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopLightResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopLightResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopLightResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LightInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LightInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LightInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltype", wireType)
			}
			m.Ltype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ltype |= LightType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frames = append(m.Frames, &LightFrame{})
			if err := m.Frames[len(m.Frames)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LightFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LightFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LightFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Colors = append(m.Colors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= PlayMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListLightsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListLightsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListLightsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltype", wireType)
			}
			m.Ltype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ltype |= LightType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListLightsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListLightsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListLightsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightsInfo = append(m.LightsInfo, &LightInfo{})
			if err := m.LightsInfo[len(m.LightsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewLightRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewLightRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewLightRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightInfo == nil {
				m.LightInfo = &LightInfo{}
			}
			if err := m.LightInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewLightResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewLightResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewLightResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightInfo == nil {
				m.LightInfo = &LightInfo{}
			}
			if err := m.LightInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLightRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLightRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLightRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightInfo == nil {
				m.LightInfo = &LightInfo{}
			}
			if err := m.LightInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLightResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLightResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLightResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LightInfo == nil {
				m.LightInfo = &LightInfo{}
			}
			if err := m.LightInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteLightsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteLightsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteLightsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LightsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLights
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLights
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLights
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LightsId = append(m.LightsId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteLightsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLights
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteLightsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteLightsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLights(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLights
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLights(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLights
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLights
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLights
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLights
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLights
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLights
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLights(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLights
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLights = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLights   = fmt.Errorf("proto: integer overflow")
)
