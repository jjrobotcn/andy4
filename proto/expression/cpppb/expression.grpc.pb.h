// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: expression.proto
#ifndef GRPC_expression_2eproto__INCLUDED
#define GRPC_expression_2eproto__INCLUDED

#include "expression.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class Channel;
class CompletionQueue;
class ServerCompletionQueue;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc_impl

namespace grpc {
class ServerContext;
}  // namespace grpc

namespace expressionService {

class ExpressionService final {
 public:
  static constexpr char const* service_full_name() {
    return "expressionService.ExpressionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // 播放表情
    virtual ::grpc::Status PlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::expressionService::PlayExpressionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::PlayExpressionsResponse>> AsyncPlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::PlayExpressionsResponse>>(AsyncPlayExpressionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::PlayExpressionsResponse>> PrepareAsyncPlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::PlayExpressionsResponse>>(PrepareAsyncPlayExpressionsRaw(context, request, cq));
    }
    // 停止表情
    virtual ::grpc::Status StopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::expressionService::StopExpressionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::StopExpressionResponse>> AsyncStopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::StopExpressionResponse>>(AsyncStopExpressionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::StopExpressionResponse>> PrepareAsyncStopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::StopExpressionResponse>>(PrepareAsyncStopExpressionRaw(context, request, cq));
    }
    // 上传表情
    virtual ::grpc::Status UploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::expressionService::UploadExpressionFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::UploadExpressionFileResponse>> AsyncUploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::UploadExpressionFileResponse>>(AsyncUploadExpressionFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::UploadExpressionFileResponse>> PrepareAsyncUploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::UploadExpressionFileResponse>>(PrepareAsyncUploadExpressionFileRaw(context, request, cq));
    }
    // 表情重命名
    // >= v1.1.0
    virtual ::grpc::Status Rename(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::expressionService::RenameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::RenameResponse>> AsyncRename(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::RenameResponse>>(AsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::RenameResponse>> PrepareAsyncRename(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::RenameResponse>>(PrepareAsyncRenameRaw(context, request, cq));
    }
    // 获取表情数据
    virtual ::grpc::Status ListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::expressionService::ListExpressionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::ListExpressionsResponse>> AsyncListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::ListExpressionsResponse>>(AsyncListExpressionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::ListExpressionsResponse>> PrepareAsyncListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::ListExpressionsResponse>>(PrepareAsyncListExpressionsRaw(context, request, cq));
    }
    // 删除表情
    virtual ::grpc::Status DeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::expressionService::DeleteExpressionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::DeleteExpressionsResponse>> AsyncDeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::DeleteExpressionsResponse>>(AsyncDeleteExpressionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::DeleteExpressionsResponse>> PrepareAsyncDeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::DeleteExpressionsResponse>>(PrepareAsyncDeleteExpressionsRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // 播放表情
      virtual void PlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::PlayExpressionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PlayExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::PlayExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 停止表情
      virtual void StopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopExpression(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::StopExpressionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StopExpression(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::StopExpressionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 上传表情
      virtual void UploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadExpressionFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::UploadExpressionFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UploadExpressionFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::UploadExpressionFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 表情重命名
      // >= v1.1.0
      virtual void Rename(::grpc::ClientContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::RenameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rename(::grpc::ClientContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 获取表情数据
      virtual void ListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::ListExpressionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ListExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::ListExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      // 删除表情
      virtual void DeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::DeleteExpressionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::DeleteExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::PlayExpressionsResponse>* AsyncPlayExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::PlayExpressionsResponse>* PrepareAsyncPlayExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::StopExpressionResponse>* AsyncStopExpressionRaw(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::StopExpressionResponse>* PrepareAsyncStopExpressionRaw(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::UploadExpressionFileResponse>* AsyncUploadExpressionFileRaw(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::UploadExpressionFileResponse>* PrepareAsyncUploadExpressionFileRaw(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::RenameResponse>* AsyncRenameRaw(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::RenameResponse>* PrepareAsyncRenameRaw(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::ListExpressionsResponse>* AsyncListExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::ListExpressionsResponse>* PrepareAsyncListExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::DeleteExpressionsResponse>* AsyncDeleteExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::expressionService::DeleteExpressionsResponse>* PrepareAsyncDeleteExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status PlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::expressionService::PlayExpressionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::PlayExpressionsResponse>> AsyncPlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::PlayExpressionsResponse>>(AsyncPlayExpressionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::PlayExpressionsResponse>> PrepareAsyncPlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::PlayExpressionsResponse>>(PrepareAsyncPlayExpressionsRaw(context, request, cq));
    }
    ::grpc::Status StopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::expressionService::StopExpressionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::StopExpressionResponse>> AsyncStopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::StopExpressionResponse>>(AsyncStopExpressionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::StopExpressionResponse>> PrepareAsyncStopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::StopExpressionResponse>>(PrepareAsyncStopExpressionRaw(context, request, cq));
    }
    ::grpc::Status UploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::expressionService::UploadExpressionFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::UploadExpressionFileResponse>> AsyncUploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::UploadExpressionFileResponse>>(AsyncUploadExpressionFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::UploadExpressionFileResponse>> PrepareAsyncUploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::UploadExpressionFileResponse>>(PrepareAsyncUploadExpressionFileRaw(context, request, cq));
    }
    ::grpc::Status Rename(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::expressionService::RenameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::RenameResponse>> AsyncRename(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::RenameResponse>>(AsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::RenameResponse>> PrepareAsyncRename(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::RenameResponse>>(PrepareAsyncRenameRaw(context, request, cq));
    }
    ::grpc::Status ListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::expressionService::ListExpressionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::ListExpressionsResponse>> AsyncListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::ListExpressionsResponse>>(AsyncListExpressionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::ListExpressionsResponse>> PrepareAsyncListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::ListExpressionsResponse>>(PrepareAsyncListExpressionsRaw(context, request, cq));
    }
    ::grpc::Status DeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::expressionService::DeleteExpressionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::DeleteExpressionsResponse>> AsyncDeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::DeleteExpressionsResponse>>(AsyncDeleteExpressionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::DeleteExpressionsResponse>> PrepareAsyncDeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::expressionService::DeleteExpressionsResponse>>(PrepareAsyncDeleteExpressionsRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void PlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response, std::function<void(::grpc::Status)>) override;
      void PlayExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::PlayExpressionsResponse* response, std::function<void(::grpc::Status)>) override;
      void PlayExpressions(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PlayExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::PlayExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response, std::function<void(::grpc::Status)>) override;
      void StopExpression(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::StopExpressionResponse* response, std::function<void(::grpc::Status)>) override;
      void StopExpression(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StopExpression(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::StopExpressionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadExpressionFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::UploadExpressionFileResponse* response, std::function<void(::grpc::Status)>) override;
      void UploadExpressionFile(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UploadExpressionFile(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::UploadExpressionFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Rename(::grpc::ClientContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response, std::function<void(::grpc::Status)>) override;
      void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::RenameResponse* response, std::function<void(::grpc::Status)>) override;
      void Rename(::grpc::ClientContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::ListExpressionsResponse* response, std::function<void(::grpc::Status)>) override;
      void ListExpressions(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ListExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::ListExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::DeleteExpressionsResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteExpressions(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void DeleteExpressions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::expressionService::DeleteExpressionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::expressionService::PlayExpressionsResponse>* AsyncPlayExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::PlayExpressionsResponse>* PrepareAsyncPlayExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::PlayExpressionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::StopExpressionResponse>* AsyncStopExpressionRaw(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::StopExpressionResponse>* PrepareAsyncStopExpressionRaw(::grpc::ClientContext* context, const ::expressionService::StopExpressionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::UploadExpressionFileResponse>* AsyncUploadExpressionFileRaw(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::UploadExpressionFileResponse>* PrepareAsyncUploadExpressionFileRaw(::grpc::ClientContext* context, const ::expressionService::UploadExpressionFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::RenameResponse>* AsyncRenameRaw(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::RenameResponse>* PrepareAsyncRenameRaw(::grpc::ClientContext* context, const ::expressionService::RenameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::ListExpressionsResponse>* AsyncListExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::ListExpressionsResponse>* PrepareAsyncListExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::ListExpressionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::DeleteExpressionsResponse>* AsyncDeleteExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::expressionService::DeleteExpressionsResponse>* PrepareAsyncDeleteExpressionsRaw(::grpc::ClientContext* context, const ::expressionService::DeleteExpressionsRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PlayExpressions_;
    const ::grpc::internal::RpcMethod rpcmethod_StopExpression_;
    const ::grpc::internal::RpcMethod rpcmethod_UploadExpressionFile_;
    const ::grpc::internal::RpcMethod rpcmethod_Rename_;
    const ::grpc::internal::RpcMethod rpcmethod_ListExpressions_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteExpressions_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // 播放表情
    virtual ::grpc::Status PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response);
    // 停止表情
    virtual ::grpc::Status StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response);
    // 上传表情
    virtual ::grpc::Status UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response);
    // 表情重命名
    // >= v1.1.0
    virtual ::grpc::Status Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response);
    // 获取表情数据
    virtual ::grpc::Status ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response);
    // 删除表情
    virtual ::grpc::Status DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_PlayExpressions() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PlayExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayExpressions(::grpc::ServerContext* context, ::expressionService::PlayExpressionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::expressionService::PlayExpressionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopExpression : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StopExpression() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_StopExpression() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopExpression(::grpc::ServerContext* context, ::expressionService::StopExpressionRequest* request, ::grpc::ServerAsyncResponseWriter< ::expressionService::StopExpressionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadExpressionFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UploadExpressionFile() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_UploadExpressionFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadExpressionFile(::grpc::ServerContext* context, ::expressionService::UploadExpressionFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::expressionService::UploadExpressionFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Rename() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRename(::grpc::ServerContext* context, ::expressionService::RenameRequest* request, ::grpc::ServerAsyncResponseWriter< ::expressionService::RenameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListExpressions() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ListExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListExpressions(::grpc::ServerContext* context, ::expressionService::ListExpressionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::expressionService::ListExpressionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeleteExpressions() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_DeleteExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteExpressions(::grpc::ServerContext* context, ::expressionService::DeleteExpressionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::expressionService::DeleteExpressionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PlayExpressions<WithAsyncMethod_StopExpression<WithAsyncMethod_UploadExpressionFile<WithAsyncMethod_Rename<WithAsyncMethod_ListExpressions<WithAsyncMethod_DeleteExpressions<Service > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PlayExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_PlayExpressions() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::expressionService::PlayExpressionsRequest, ::expressionService::PlayExpressionsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::expressionService::PlayExpressionsRequest* request,
                 ::expressionService::PlayExpressionsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->PlayExpressions(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_PlayExpressions(
        ::grpc::experimental::MessageAllocator< ::expressionService::PlayExpressionsRequest, ::expressionService::PlayExpressionsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::expressionService::PlayExpressionsRequest, ::expressionService::PlayExpressionsResponse>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PlayExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StopExpression : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_StopExpression() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::expressionService::StopExpressionRequest, ::expressionService::StopExpressionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::expressionService::StopExpressionRequest* request,
                 ::expressionService::StopExpressionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StopExpression(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StopExpression(
        ::grpc::experimental::MessageAllocator< ::expressionService::StopExpressionRequest, ::expressionService::StopExpressionResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::expressionService::StopExpressionRequest, ::expressionService::StopExpressionResponse>*>(
          ::grpc::Service::experimental().GetHandler(1))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StopExpression() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UploadExpressionFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_UploadExpressionFile() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::expressionService::UploadExpressionFileRequest, ::expressionService::UploadExpressionFileResponse>(
          [this](::grpc::ServerContext* context,
                 const ::expressionService::UploadExpressionFileRequest* request,
                 ::expressionService::UploadExpressionFileResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UploadExpressionFile(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UploadExpressionFile(
        ::grpc::experimental::MessageAllocator< ::expressionService::UploadExpressionFileRequest, ::expressionService::UploadExpressionFileResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::expressionService::UploadExpressionFileRequest, ::expressionService::UploadExpressionFileResponse>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UploadExpressionFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_Rename() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::expressionService::RenameRequest, ::expressionService::RenameResponse>(
          [this](::grpc::ServerContext* context,
                 const ::expressionService::RenameRequest* request,
                 ::expressionService::RenameResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Rename(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Rename(
        ::grpc::experimental::MessageAllocator< ::expressionService::RenameRequest, ::expressionService::RenameResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::expressionService::RenameRequest, ::expressionService::RenameResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_ListExpressions() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::expressionService::ListExpressionsRequest, ::expressionService::ListExpressionsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::expressionService::ListExpressionsRequest* request,
                 ::expressionService::ListExpressionsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ListExpressions(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ListExpressions(
        ::grpc::experimental::MessageAllocator< ::expressionService::ListExpressionsRequest, ::expressionService::ListExpressionsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::expressionService::ListExpressionsRequest, ::expressionService::ListExpressionsResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithCallbackMethod_DeleteExpressions() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::expressionService::DeleteExpressionsRequest, ::expressionService::DeleteExpressionsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::expressionService::DeleteExpressionsRequest* request,
                 ::expressionService::DeleteExpressionsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->DeleteExpressions(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_DeleteExpressions(
        ::grpc::experimental::MessageAllocator< ::expressionService::DeleteExpressionsRequest, ::expressionService::DeleteExpressionsResponse>* allocator) {
      static_cast<::grpc::internal::CallbackUnaryHandler< ::expressionService::DeleteExpressionsRequest, ::expressionService::DeleteExpressionsResponse>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_PlayExpressions<ExperimentalWithCallbackMethod_StopExpression<ExperimentalWithCallbackMethod_UploadExpressionFile<ExperimentalWithCallbackMethod_Rename<ExperimentalWithCallbackMethod_ListExpressions<ExperimentalWithCallbackMethod_DeleteExpressions<Service > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PlayExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_PlayExpressions() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PlayExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopExpression : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StopExpression() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_StopExpression() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UploadExpressionFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UploadExpressionFile() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_UploadExpressionFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Rename() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListExpressions() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ListExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeleteExpressions() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_DeleteExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_PlayExpressions() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PlayExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayExpressions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopExpression : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_StopExpression() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_StopExpression() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopExpression(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadExpressionFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_UploadExpressionFile() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_UploadExpressionFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadExpressionFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Rename() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRename(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ListExpressions() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ListExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListExpressions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeleteExpressions() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_DeleteExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteExpressions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PlayExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_PlayExpressions() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->PlayExpressions(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_PlayExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PlayExpressions(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StopExpression : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_StopExpression() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StopExpression(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StopExpression() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StopExpression(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UploadExpressionFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_UploadExpressionFile() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UploadExpressionFile(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UploadExpressionFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UploadExpressionFile(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_Rename() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Rename(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Rename(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_ListExpressions() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ListExpressions(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ListExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ListExpressions(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteExpressions() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->DeleteExpressions(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void DeleteExpressions(::grpc::ServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_PlayExpressions() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::expressionService::PlayExpressionsRequest, ::expressionService::PlayExpressionsResponse>(std::bind(&WithStreamedUnaryMethod_PlayExpressions<BaseClass>::StreamedPlayExpressions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PlayExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayExpressions(::grpc::ServerContext* context, const ::expressionService::PlayExpressionsRequest* request, ::expressionService::PlayExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayExpressions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::expressionService::PlayExpressionsRequest,::expressionService::PlayExpressionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopExpression : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_StopExpression() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::expressionService::StopExpressionRequest, ::expressionService::StopExpressionResponse>(std::bind(&WithStreamedUnaryMethod_StopExpression<BaseClass>::StreamedStopExpression, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StopExpression() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopExpression(::grpc::ServerContext* context, const ::expressionService::StopExpressionRequest* request, ::expressionService::StopExpressionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopExpression(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::expressionService::StopExpressionRequest,::expressionService::StopExpressionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadExpressionFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UploadExpressionFile() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::expressionService::UploadExpressionFileRequest, ::expressionService::UploadExpressionFileResponse>(std::bind(&WithStreamedUnaryMethod_UploadExpressionFile<BaseClass>::StreamedUploadExpressionFile, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UploadExpressionFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadExpressionFile(::grpc::ServerContext* context, const ::expressionService::UploadExpressionFileRequest* request, ::expressionService::UploadExpressionFileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadExpressionFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::expressionService::UploadExpressionFileRequest,::expressionService::UploadExpressionFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Rename() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::expressionService::RenameRequest, ::expressionService::RenameResponse>(std::bind(&WithStreamedUnaryMethod_Rename<BaseClass>::StreamedRename, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Rename(::grpc::ServerContext* context, const ::expressionService::RenameRequest* request, ::expressionService::RenameResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRename(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::expressionService::RenameRequest,::expressionService::RenameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ListExpressions() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::expressionService::ListExpressionsRequest, ::expressionService::ListExpressionsResponse>(std::bind(&WithStreamedUnaryMethod_ListExpressions<BaseClass>::StreamedListExpressions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ListExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListExpressions(::grpc::ServerContext* context, const ::expressionService::ListExpressionsRequest* request, ::expressionService::ListExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListExpressions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::expressionService::ListExpressionsRequest,::expressionService::ListExpressionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteExpressions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeleteExpressions() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::expressionService::DeleteExpressionsRequest, ::expressionService::DeleteExpressionsResponse>(std::bind(&WithStreamedUnaryMethod_DeleteExpressions<BaseClass>::StreamedDeleteExpressions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeleteExpressions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteExpressions(::grpc::ServerContext* context, const ::expressionService::DeleteExpressionsRequest* request, ::expressionService::DeleteExpressionsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteExpressions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::expressionService::DeleteExpressionsRequest,::expressionService::DeleteExpressionsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PlayExpressions<WithStreamedUnaryMethod_StopExpression<WithStreamedUnaryMethod_UploadExpressionFile<WithStreamedUnaryMethod_Rename<WithStreamedUnaryMethod_ListExpressions<WithStreamedUnaryMethod_DeleteExpressions<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PlayExpressions<WithStreamedUnaryMethod_StopExpression<WithStreamedUnaryMethod_UploadExpressionFile<WithStreamedUnaryMethod_Rename<WithStreamedUnaryMethod_ListExpressions<WithStreamedUnaryMethod_DeleteExpressions<Service > > > > > > StreamedService;
};

}  // namespace expressionService


#endif  // GRPC_expression_2eproto__INCLUDED
