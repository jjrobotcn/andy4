// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: expression.proto

package expressionService

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 表情对象
type ExpressionInfo struct {
	// 表情id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// 表情名
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// 预览图
	PreviewB64           string   `protobuf:"bytes,3,opt,name=preview_b64,json=previewB64,proto3" json:"preview_b64,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExpressionInfo) Reset()         { *m = ExpressionInfo{} }
func (m *ExpressionInfo) String() string { return proto.CompactTextString(m) }
func (*ExpressionInfo) ProtoMessage()    {}
func (*ExpressionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{0}
}
func (m *ExpressionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExpressionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExpressionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExpressionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExpressionInfo.Merge(m, src)
}
func (m *ExpressionInfo) XXX_Size() int {
	return m.Size()
}
func (m *ExpressionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ExpressionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ExpressionInfo proto.InternalMessageInfo

func (m *ExpressionInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ExpressionInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExpressionInfo) GetPreviewB64() string {
	if m != nil {
		return m.PreviewB64
	}
	return ""
}

// 播放表情请求
type PlayExpressionsRequest struct {
	// 播放的表情对象列表
	// 可仅填入id项或表情名
	ExpressionsInfo []*ExpressionInfo `protobuf:"bytes,1,rep,name=expressions_info,json=expressionsInfo,proto3" json:"expressions_info,omitempty"`
	// 循环播放
	// 0: 持续循环
	LoopTimes uint32 `protobuf:"varint,2,opt,name=loop_times,json=loopTimes,proto3" json:"loop_times,omitempty"`
	// 切换间隔ms
	// 每套表情间的间隔
	Duration             uint32   `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayExpressionsRequest) Reset()         { *m = PlayExpressionsRequest{} }
func (m *PlayExpressionsRequest) String() string { return proto.CompactTextString(m) }
func (*PlayExpressionsRequest) ProtoMessage()    {}
func (*PlayExpressionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{1}
}
func (m *PlayExpressionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayExpressionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayExpressionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayExpressionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayExpressionsRequest.Merge(m, src)
}
func (m *PlayExpressionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *PlayExpressionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayExpressionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlayExpressionsRequest proto.InternalMessageInfo

func (m *PlayExpressionsRequest) GetExpressionsInfo() []*ExpressionInfo {
	if m != nil {
		return m.ExpressionsInfo
	}
	return nil
}

func (m *PlayExpressionsRequest) GetLoopTimes() uint32 {
	if m != nil {
		return m.LoopTimes
	}
	return 0
}

func (m *PlayExpressionsRequest) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// 播放表情结果
type PlayExpressionsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayExpressionsResponse) Reset()         { *m = PlayExpressionsResponse{} }
func (m *PlayExpressionsResponse) String() string { return proto.CompactTextString(m) }
func (*PlayExpressionsResponse) ProtoMessage()    {}
func (*PlayExpressionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{2}
}
func (m *PlayExpressionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayExpressionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayExpressionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayExpressionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayExpressionsResponse.Merge(m, src)
}
func (m *PlayExpressionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *PlayExpressionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayExpressionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlayExpressionsResponse proto.InternalMessageInfo

// 停止表情请求
type StopExpressionRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopExpressionRequest) Reset()         { *m = StopExpressionRequest{} }
func (m *StopExpressionRequest) String() string { return proto.CompactTextString(m) }
func (*StopExpressionRequest) ProtoMessage()    {}
func (*StopExpressionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{3}
}
func (m *StopExpressionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopExpressionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopExpressionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopExpressionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopExpressionRequest.Merge(m, src)
}
func (m *StopExpressionRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopExpressionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopExpressionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopExpressionRequest proto.InternalMessageInfo

// 停止表情结果
type StopExpressionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopExpressionResponse) Reset()         { *m = StopExpressionResponse{} }
func (m *StopExpressionResponse) String() string { return proto.CompactTextString(m) }
func (*StopExpressionResponse) ProtoMessage()    {}
func (*StopExpressionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{4}
}
func (m *StopExpressionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopExpressionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopExpressionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopExpressionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopExpressionResponse.Merge(m, src)
}
func (m *StopExpressionResponse) XXX_Size() int {
	return m.Size()
}
func (m *StopExpressionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StopExpressionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StopExpressionResponse proto.InternalMessageInfo

// 上传表情请求
type UploadExpressionFileRequest struct {
	// 表情名
	// 为空时将产生随机表情名
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// 表情zip文件
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadExpressionFileRequest) Reset()         { *m = UploadExpressionFileRequest{} }
func (m *UploadExpressionFileRequest) String() string { return proto.CompactTextString(m) }
func (*UploadExpressionFileRequest) ProtoMessage()    {}
func (*UploadExpressionFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{5}
}
func (m *UploadExpressionFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadExpressionFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadExpressionFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadExpressionFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadExpressionFileRequest.Merge(m, src)
}
func (m *UploadExpressionFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadExpressionFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadExpressionFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadExpressionFileRequest proto.InternalMessageInfo

func (m *UploadExpressionFileRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UploadExpressionFileRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 上传表情结果
type UploadExpressionFileResponse struct {
	// 表情对象
	ExpressionInfo       *ExpressionInfo `protobuf:"bytes,1,opt,name=expression_info,json=expressionInfo,proto3" json:"expression_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UploadExpressionFileResponse) Reset()         { *m = UploadExpressionFileResponse{} }
func (m *UploadExpressionFileResponse) String() string { return proto.CompactTextString(m) }
func (*UploadExpressionFileResponse) ProtoMessage()    {}
func (*UploadExpressionFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{6}
}
func (m *UploadExpressionFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadExpressionFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadExpressionFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadExpressionFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadExpressionFileResponse.Merge(m, src)
}
func (m *UploadExpressionFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadExpressionFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadExpressionFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadExpressionFileResponse proto.InternalMessageInfo

func (m *UploadExpressionFileResponse) GetExpressionInfo() *ExpressionInfo {
	if m != nil {
		return m.ExpressionInfo
	}
	return nil
}

// 获取表情数据请求
type ListExpressionsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListExpressionsRequest) Reset()         { *m = ListExpressionsRequest{} }
func (m *ListExpressionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListExpressionsRequest) ProtoMessage()    {}
func (*ListExpressionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{7}
}
func (m *ListExpressionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListExpressionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListExpressionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListExpressionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListExpressionsRequest.Merge(m, src)
}
func (m *ListExpressionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListExpressionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListExpressionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListExpressionsRequest proto.InternalMessageInfo

// 获取表情数据结果
type ListExpressionsResponse struct {
	// 表情对象列表
	ExpressionsInfo      []*ExpressionInfo `protobuf:"bytes,1,rep,name=expressions_info,json=expressionsInfo,proto3" json:"expressions_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ListExpressionsResponse) Reset()         { *m = ListExpressionsResponse{} }
func (m *ListExpressionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListExpressionsResponse) ProtoMessage()    {}
func (*ListExpressionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{8}
}
func (m *ListExpressionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListExpressionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListExpressionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListExpressionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListExpressionsResponse.Merge(m, src)
}
func (m *ListExpressionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListExpressionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListExpressionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListExpressionsResponse proto.InternalMessageInfo

func (m *ListExpressionsResponse) GetExpressionsInfo() []*ExpressionInfo {
	if m != nil {
		return m.ExpressionsInfo
	}
	return nil
}

// 删除表情请求
type DeleteExpressionsRequest struct {
	// 删除表情id列表
	ExpressionsId        []string `protobuf:"bytes,1,rep,name=expressions_id,json=expressionsId,proto3" json:"expressions_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteExpressionsRequest) Reset()         { *m = DeleteExpressionsRequest{} }
func (m *DeleteExpressionsRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteExpressionsRequest) ProtoMessage()    {}
func (*DeleteExpressionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{9}
}
func (m *DeleteExpressionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteExpressionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteExpressionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteExpressionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteExpressionsRequest.Merge(m, src)
}
func (m *DeleteExpressionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteExpressionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteExpressionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteExpressionsRequest proto.InternalMessageInfo

func (m *DeleteExpressionsRequest) GetExpressionsId() []string {
	if m != nil {
		return m.ExpressionsId
	}
	return nil
}

// 删除表情结果
type DeleteExpressionsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteExpressionsResponse) Reset()         { *m = DeleteExpressionsResponse{} }
func (m *DeleteExpressionsResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteExpressionsResponse) ProtoMessage()    {}
func (*DeleteExpressionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{10}
}
func (m *DeleteExpressionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteExpressionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteExpressionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteExpressionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteExpressionsResponse.Merge(m, src)
}
func (m *DeleteExpressionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteExpressionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteExpressionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteExpressionsResponse proto.InternalMessageInfo

// 表情重命名请求
type RenameRequest struct {
	// 表情id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// 新表情名
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenameRequest) Reset()         { *m = RenameRequest{} }
func (m *RenameRequest) String() string { return proto.CompactTextString(m) }
func (*RenameRequest) ProtoMessage()    {}
func (*RenameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{11}
}
func (m *RenameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenameRequest.Merge(m, src)
}
func (m *RenameRequest) XXX_Size() int {
	return m.Size()
}
func (m *RenameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RenameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RenameRequest proto.InternalMessageInfo

func (m *RenameRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RenameRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// 表情重命名结果
type RenameResponse struct {
	// 表情id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// 表情名
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenameResponse) Reset()         { *m = RenameResponse{} }
func (m *RenameResponse) String() string { return proto.CompactTextString(m) }
func (*RenameResponse) ProtoMessage()    {}
func (*RenameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fcc7550768b3bd34, []int{12}
}
func (m *RenameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenameResponse.Merge(m, src)
}
func (m *RenameResponse) XXX_Size() int {
	return m.Size()
}
func (m *RenameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RenameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RenameResponse proto.InternalMessageInfo

func (m *RenameResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RenameResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*ExpressionInfo)(nil), "expressionService.ExpressionInfo")
	proto.RegisterType((*PlayExpressionsRequest)(nil), "expressionService.PlayExpressionsRequest")
	proto.RegisterType((*PlayExpressionsResponse)(nil), "expressionService.PlayExpressionsResponse")
	proto.RegisterType((*StopExpressionRequest)(nil), "expressionService.StopExpressionRequest")
	proto.RegisterType((*StopExpressionResponse)(nil), "expressionService.StopExpressionResponse")
	proto.RegisterType((*UploadExpressionFileRequest)(nil), "expressionService.UploadExpressionFileRequest")
	proto.RegisterType((*UploadExpressionFileResponse)(nil), "expressionService.UploadExpressionFileResponse")
	proto.RegisterType((*ListExpressionsRequest)(nil), "expressionService.ListExpressionsRequest")
	proto.RegisterType((*ListExpressionsResponse)(nil), "expressionService.ListExpressionsResponse")
	proto.RegisterType((*DeleteExpressionsRequest)(nil), "expressionService.DeleteExpressionsRequest")
	proto.RegisterType((*DeleteExpressionsResponse)(nil), "expressionService.DeleteExpressionsResponse")
	proto.RegisterType((*RenameRequest)(nil), "expressionService.RenameRequest")
	proto.RegisterType((*RenameResponse)(nil), "expressionService.RenameResponse")
}

func init() { proto.RegisterFile("expression.proto", fileDescriptor_fcc7550768b3bd34) }

var fileDescriptor_fcc7550768b3bd34 = []byte{
	// 606 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x95, 0xcf, 0x6e, 0xd3, 0x4a,
	0x14, 0xc6, 0xef, 0xa4, 0x55, 0x75, 0x73, 0xda, 0xb8, 0x64, 0x04, 0x8d, 0xe3, 0x96, 0x90, 0x0e,
	0x54, 0xa4, 0x01, 0x12, 0x94, 0x46, 0x5d, 0xb0, 0xa3, 0x22, 0x48, 0xa0, 0x2e, 0x90, 0x4b, 0xd7,
	0x91, 0x8b, 0xa7, 0xd1, 0x20, 0xd7, 0x63, 0x3c, 0xd3, 0x40, 0xb6, 0xbc, 0x02, 0x2c, 0x58, 0xc2,
	0xdb, 0xb0, 0x44, 0xe2, 0x05, 0x50, 0xc4, 0x1b, 0xf0, 0x02, 0xc8, 0x93, 0x49, 0xe3, 0x38, 0xd3,
	0xc8, 0x0b, 0x76, 0xf1, 0xcc, 0xf9, 0xf3, 0x3b, 0x67, 0xbe, 0x4f, 0x81, 0x1b, 0xf4, 0x43, 0x14,
	0x53, 0x21, 0x18, 0x0f, 0x5b, 0x51, 0xcc, 0x25, 0xc7, 0xe5, 0xd9, 0xc9, 0x09, 0x8d, 0x87, 0xec,
	0x0d, 0x75, 0x76, 0x06, 0x9c, 0x0f, 0x02, 0xda, 0xf6, 0x22, 0xd6, 0xf6, 0xc2, 0x90, 0x4b, 0x4f,
	0x32, 0x1e, 0x8a, 0x49, 0x02, 0x39, 0x05, 0xab, 0x77, 0x95, 0xf2, 0x22, 0x3c, 0xe7, 0xd8, 0x82,
	0x02, 0xf3, 0x6d, 0x54, 0x47, 0x8d, 0xa2, 0x5b, 0x60, 0x3e, 0xc6, 0xb0, 0x1a, 0x7a, 0x17, 0xd4,
	0x2e, 0xa8, 0x13, 0xf5, 0x1b, 0xdf, 0x81, 0xf5, 0x28, 0xa6, 0x43, 0x46, 0xdf, 0xf7, 0xcf, 0x0e,
	0xbb, 0xf6, 0x8a, 0xba, 0x02, 0x7d, 0x74, 0x74, 0xd8, 0x25, 0xdf, 0x10, 0x6c, 0xbd, 0x0a, 0xbc,
	0xd1, 0xac, 0xb6, 0x70, 0xe9, 0xbb, 0x4b, 0x2a, 0x24, 0x3e, 0x4e, 0x63, 0x8b, 0x3e, 0x0b, 0xcf,
	0xb9, 0x8d, 0xea, 0x2b, 0x8d, 0xf5, 0xce, 0x6e, 0x6b, 0x81, 0xbe, 0x35, 0x0f, 0xe7, 0x6e, 0xa6,
	0x52, 0x15, 0xed, 0x6d, 0x80, 0x80, 0xf3, 0xa8, 0x2f, 0xd9, 0x05, 0x15, 0x8a, 0xb1, 0xe4, 0x16,
	0x93, 0x93, 0xd7, 0xc9, 0x01, 0x76, 0xe0, 0x7f, 0xff, 0x32, 0x56, 0x13, 0x2b, 0xca, 0x92, 0x7b,
	0xf5, 0x4d, 0xaa, 0x50, 0x59, 0x40, 0x14, 0x11, 0x0f, 0x05, 0x25, 0x15, 0xb8, 0x75, 0x22, 0x79,
	0x34, 0xbb, 0xd2, 0xf0, 0xc4, 0x86, 0xad, 0xec, 0x85, 0x4e, 0xe9, 0xc1, 0xf6, 0x69, 0x14, 0x70,
	0xcf, 0x9f, 0xdd, 0x3d, 0x67, 0x01, 0x9d, 0x4e, 0x3d, 0xdd, 0x22, 0x4a, 0x6d, 0x11, 0xc3, 0xaa,
	0xef, 0x49, 0x4f, 0x51, 0x6f, 0xb8, 0xea, 0x37, 0x79, 0x0b, 0x3b, 0xe6, 0x32, 0x93, 0x36, 0xf8,
	0x25, 0xa4, 0x56, 0x30, 0x5d, 0x1e, 0xca, 0xb7, 0x3c, 0x8b, 0xce, 0x7d, 0x27, 0xc3, 0x1c, 0x33,
	0x21, 0x17, 0xdf, 0x88, 0x0c, 0xa0, 0xb2, 0x70, 0xa3, 0x01, 0xfe, 0xe9, 0xf3, 0x91, 0xa7, 0x60,
	0x3f, 0xa3, 0x01, 0x95, 0xd4, 0x20, 0x94, 0x3d, 0xb0, 0xe6, 0x3a, 0xf9, 0xaa, 0x4f, 0xd1, 0x2d,
	0xa5, 0x8b, 0xf8, 0x64, 0x1b, 0xaa, 0x86, 0x12, 0xfa, 0x55, 0x0e, 0xa0, 0xe4, 0xd2, 0x64, 0xd9,
	0xd3, 0xa2, 0x39, 0xd4, 0x4d, 0xba, 0x60, 0x4d, 0x93, 0xf4, 0xd0, 0x39, 0xb2, 0x3a, 0x7f, 0xd6,
	0xa0, 0xdc, 0xcb, 0x2e, 0x00, 0x7f, 0x41, 0xb0, 0x99, 0x51, 0x19, 0xde, 0x37, 0x2c, 0xca, 0x6c,
	0x16, 0xa7, 0x99, 0x27, 0x54, 0xcf, 0xda, 0xfa, 0xf8, 0xf3, 0xf7, 0xa7, 0x42, 0x83, 0xdc, 0x55,
	0x56, 0x1f, 0x76, 0xda, 0xb3, 0xd4, 0x76, 0x14, 0x78, 0xa3, 0x7e, 0x6a, 0x6f, 0x4f, 0x50, 0x13,
	0x7f, 0x46, 0x60, 0xcd, 0x8b, 0x19, 0x37, 0x0c, 0xed, 0x8c, 0x46, 0x70, 0xf6, 0x73, 0x44, 0x6a,
	0xae, 0x47, 0x8a, 0xeb, 0x3e, 0x21, 0x06, 0x2e, 0x21, 0x79, 0x94, 0xe2, 0x4a, 0xb0, 0x46, 0x70,
	0xd3, 0xe4, 0x00, 0xdc, 0x32, 0x74, 0x5c, 0xe2, 0x38, 0xa7, 0x9d, 0x3b, 0x5e, 0x73, 0xfe, 0x87,
	0x05, 0xac, 0x4d, 0x1e, 0x1e, 0xd7, 0x0d, 0xc9, 0x73, 0x42, 0x72, 0x76, 0x97, 0x44, 0xe8, 0x82,
	0xf7, 0xd4, 0xe0, 0x35, 0x52, 0x35, 0x0c, 0x1e, 0xab, 0xd0, 0x64, 0xde, 0x44, 0x21, 0x19, 0xb3,
	0x19, 0x15, 0x62, 0xb6, 0xaa, 0x51, 0x21, 0xd7, 0x78, 0x77, 0xa9, 0x42, 0x02, 0x26, 0x64, 0x56,
	0x21, 0x5f, 0x11, 0x94, 0x17, 0xbc, 0x85, 0x1f, 0x18, 0x3a, 0x5e, 0x67, 0x62, 0xe7, 0x61, 0xbe,
	0x60, 0x0d, 0xf8, 0x58, 0x01, 0x36, 0xc9, 0x9e, 0x01, 0xd0, 0x57, 0x59, 0x19, 0xc4, 0xa3, 0x8d,
	0xef, 0xe3, 0x1a, 0xfa, 0x31, 0xae, 0xa1, 0x5f, 0xe3, 0x1a, 0x3a, 0x5b, 0x53, 0x7f, 0x6a, 0x07,
	0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xa5, 0x3d, 0xc4, 0xfa, 0x19, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExpressionServiceClient is the client API for ExpressionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExpressionServiceClient interface {
	// 播放表情
	PlayExpressions(ctx context.Context, in *PlayExpressionsRequest, opts ...grpc.CallOption) (*PlayExpressionsResponse, error)
	// 停止表情
	StopExpression(ctx context.Context, in *StopExpressionRequest, opts ...grpc.CallOption) (*StopExpressionResponse, error)
	// 上传表情
	UploadExpressionFile(ctx context.Context, in *UploadExpressionFileRequest, opts ...grpc.CallOption) (*UploadExpressionFileResponse, error)
	// 表情重命名
	// >= v1.1.0
	Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error)
	// 获取表情数据
	ListExpressions(ctx context.Context, in *ListExpressionsRequest, opts ...grpc.CallOption) (*ListExpressionsResponse, error)
	// 删除表情
	DeleteExpressions(ctx context.Context, in *DeleteExpressionsRequest, opts ...grpc.CallOption) (*DeleteExpressionsResponse, error)
}

type expressionServiceClient struct {
	cc *grpc.ClientConn
}

func NewExpressionServiceClient(cc *grpc.ClientConn) ExpressionServiceClient {
	return &expressionServiceClient{cc}
}

func (c *expressionServiceClient) PlayExpressions(ctx context.Context, in *PlayExpressionsRequest, opts ...grpc.CallOption) (*PlayExpressionsResponse, error) {
	out := new(PlayExpressionsResponse)
	err := c.cc.Invoke(ctx, "/expressionService.ExpressionService/PlayExpressions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expressionServiceClient) StopExpression(ctx context.Context, in *StopExpressionRequest, opts ...grpc.CallOption) (*StopExpressionResponse, error) {
	out := new(StopExpressionResponse)
	err := c.cc.Invoke(ctx, "/expressionService.ExpressionService/StopExpression", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expressionServiceClient) UploadExpressionFile(ctx context.Context, in *UploadExpressionFileRequest, opts ...grpc.CallOption) (*UploadExpressionFileResponse, error) {
	out := new(UploadExpressionFileResponse)
	err := c.cc.Invoke(ctx, "/expressionService.ExpressionService/UploadExpressionFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expressionServiceClient) Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error) {
	out := new(RenameResponse)
	err := c.cc.Invoke(ctx, "/expressionService.ExpressionService/Rename", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expressionServiceClient) ListExpressions(ctx context.Context, in *ListExpressionsRequest, opts ...grpc.CallOption) (*ListExpressionsResponse, error) {
	out := new(ListExpressionsResponse)
	err := c.cc.Invoke(ctx, "/expressionService.ExpressionService/ListExpressions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expressionServiceClient) DeleteExpressions(ctx context.Context, in *DeleteExpressionsRequest, opts ...grpc.CallOption) (*DeleteExpressionsResponse, error) {
	out := new(DeleteExpressionsResponse)
	err := c.cc.Invoke(ctx, "/expressionService.ExpressionService/DeleteExpressions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExpressionServiceServer is the server API for ExpressionService service.
type ExpressionServiceServer interface {
	// 播放表情
	PlayExpressions(context.Context, *PlayExpressionsRequest) (*PlayExpressionsResponse, error)
	// 停止表情
	StopExpression(context.Context, *StopExpressionRequest) (*StopExpressionResponse, error)
	// 上传表情
	UploadExpressionFile(context.Context, *UploadExpressionFileRequest) (*UploadExpressionFileResponse, error)
	// 表情重命名
	// >= v1.1.0
	Rename(context.Context, *RenameRequest) (*RenameResponse, error)
	// 获取表情数据
	ListExpressions(context.Context, *ListExpressionsRequest) (*ListExpressionsResponse, error)
	// 删除表情
	DeleteExpressions(context.Context, *DeleteExpressionsRequest) (*DeleteExpressionsResponse, error)
}

// UnimplementedExpressionServiceServer can be embedded to have forward compatible implementations.
type UnimplementedExpressionServiceServer struct {
}

func (*UnimplementedExpressionServiceServer) PlayExpressions(ctx context.Context, req *PlayExpressionsRequest) (*PlayExpressionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayExpressions not implemented")
}
func (*UnimplementedExpressionServiceServer) StopExpression(ctx context.Context, req *StopExpressionRequest) (*StopExpressionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopExpression not implemented")
}
func (*UnimplementedExpressionServiceServer) UploadExpressionFile(ctx context.Context, req *UploadExpressionFileRequest) (*UploadExpressionFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadExpressionFile not implemented")
}
func (*UnimplementedExpressionServiceServer) Rename(ctx context.Context, req *RenameRequest) (*RenameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rename not implemented")
}
func (*UnimplementedExpressionServiceServer) ListExpressions(ctx context.Context, req *ListExpressionsRequest) (*ListExpressionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExpressions not implemented")
}
func (*UnimplementedExpressionServiceServer) DeleteExpressions(ctx context.Context, req *DeleteExpressionsRequest) (*DeleteExpressionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExpressions not implemented")
}

func RegisterExpressionServiceServer(s *grpc.Server, srv ExpressionServiceServer) {
	s.RegisterService(&_ExpressionService_serviceDesc, srv)
}

func _ExpressionService_PlayExpressions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayExpressionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpressionServiceServer).PlayExpressions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/expressionService.ExpressionService/PlayExpressions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpressionServiceServer).PlayExpressions(ctx, req.(*PlayExpressionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpressionService_StopExpression_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopExpressionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpressionServiceServer).StopExpression(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/expressionService.ExpressionService/StopExpression",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpressionServiceServer).StopExpression(ctx, req.(*StopExpressionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpressionService_UploadExpressionFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadExpressionFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpressionServiceServer).UploadExpressionFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/expressionService.ExpressionService/UploadExpressionFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpressionServiceServer).UploadExpressionFile(ctx, req.(*UploadExpressionFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpressionService_Rename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpressionServiceServer).Rename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/expressionService.ExpressionService/Rename",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpressionServiceServer).Rename(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpressionService_ListExpressions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExpressionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpressionServiceServer).ListExpressions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/expressionService.ExpressionService/ListExpressions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpressionServiceServer).ListExpressions(ctx, req.(*ListExpressionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpressionService_DeleteExpressions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExpressionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpressionServiceServer).DeleteExpressions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/expressionService.ExpressionService/DeleteExpressions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpressionServiceServer).DeleteExpressions(ctx, req.(*DeleteExpressionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExpressionService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "expressionService.ExpressionService",
	HandlerType: (*ExpressionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PlayExpressions",
			Handler:    _ExpressionService_PlayExpressions_Handler,
		},
		{
			MethodName: "StopExpression",
			Handler:    _ExpressionService_StopExpression_Handler,
		},
		{
			MethodName: "UploadExpressionFile",
			Handler:    _ExpressionService_UploadExpressionFile_Handler,
		},
		{
			MethodName: "Rename",
			Handler:    _ExpressionService_Rename_Handler,
		},
		{
			MethodName: "ListExpressions",
			Handler:    _ExpressionService_ListExpressions_Handler,
		},
		{
			MethodName: "DeleteExpressions",
			Handler:    _ExpressionService_DeleteExpressions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "expression.proto",
}

func (m *ExpressionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExpressionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PreviewB64) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.PreviewB64)))
		i += copy(dAtA[i:], m.PreviewB64)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayExpressionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayExpressionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExpressionsInfo) > 0 {
		for _, msg := range m.ExpressionsInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExpression(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LoopTimes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintExpression(dAtA, i, uint64(m.LoopTimes))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintExpression(dAtA, i, uint64(m.Duration))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlayExpressionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayExpressionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StopExpressionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopExpressionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StopExpressionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopExpressionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadExpressionFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadExpressionFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadExpressionFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadExpressionFileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpressionInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExpression(dAtA, i, uint64(m.ExpressionInfo.Size()))
		n1, err1 := m.ExpressionInfo.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListExpressionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListExpressionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListExpressionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListExpressionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExpressionsInfo) > 0 {
		for _, msg := range m.ExpressionsInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintExpression(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteExpressionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteExpressionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExpressionsId) > 0 {
		for _, s := range m.ExpressionsId {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteExpressionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteExpressionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenameRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RenameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenameResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintExpression(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintExpression(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ExpressionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	l = len(m.PreviewB64)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayExpressionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExpressionsInfo) > 0 {
		for _, e := range m.ExpressionsInfo {
			l = e.Size()
			n += 1 + l + sovExpression(uint64(l))
		}
	}
	if m.LoopTimes != 0 {
		n += 1 + sovExpression(uint64(m.LoopTimes))
	}
	if m.Duration != 0 {
		n += 1 + sovExpression(uint64(m.Duration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayExpressionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopExpressionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopExpressionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadExpressionFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadExpressionFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpressionInfo != nil {
		l = m.ExpressionInfo.Size()
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListExpressionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListExpressionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExpressionsInfo) > 0 {
		for _, e := range m.ExpressionsInfo {
			l = e.Size()
			n += 1 + l + sovExpression(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteExpressionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ExpressionsId) > 0 {
		for _, s := range m.ExpressionsId {
			l = len(s)
			n += 1 + l + sovExpression(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteExpressionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovExpression(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovExpression(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExpression(x uint64) (n int) {
	return sovExpression(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExpressionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpressionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpressionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewB64", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewB64 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayExpressionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayExpressionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayExpressionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressionsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressionsInfo = append(m.ExpressionsInfo, &ExpressionInfo{})
			if err := m.ExpressionsInfo[len(m.ExpressionsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopTimes", wireType)
			}
			m.LoopTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoopTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayExpressionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayExpressionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayExpressionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopExpressionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopExpressionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopExpressionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopExpressionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopExpressionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopExpressionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadExpressionFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadExpressionFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadExpressionFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadExpressionFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadExpressionFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadExpressionFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpressionInfo == nil {
				m.ExpressionInfo = &ExpressionInfo{}
			}
			if err := m.ExpressionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListExpressionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListExpressionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListExpressionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListExpressionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListExpressionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListExpressionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressionsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressionsInfo = append(m.ExpressionsInfo, &ExpressionInfo{})
			if err := m.ExpressionsInfo[len(m.ExpressionsInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteExpressionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteExpressionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteExpressionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressionsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressionsId = append(m.ExpressionsId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteExpressionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteExpressionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteExpressionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExpression
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExpression
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExpression(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthExpression
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExpression(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExpression
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExpression
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExpression
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthExpression
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowExpression
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipExpression(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthExpression
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthExpression = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExpression   = fmt.Errorf("proto: integer overflow")
)
